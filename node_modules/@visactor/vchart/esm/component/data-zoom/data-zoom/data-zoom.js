import { isFunction, isNil, isNumber, isValid, last, maxInArray, minInArray, uniqArray } from "@visactor/vutils";

import { mergeSpec } from "@visactor/vutils-extension";

import { ComponentTypeEnum } from "../../interface";

import { DataFilterBaseComponent } from "../data-filter-base-component";

import { DataZoom as DataZoomComponent } from "@visactor/vrender-components";

import { transformToGraphic } from "../../../util/style";

import { LinearScale, isContinuous, isDiscrete } from "@visactor/vscale";

import { LayoutLevel, LayoutZIndex } from "../../../constant/layout";

import { ChartEvent } from "../../../constant/event";

import { Factory } from "../../../core/factory";

import { DataZoomSpecTransformer } from "./data-zoom-transformer";

import { getFormatFunction } from "../../util";

import { dataZoom } from "../../../theme/builtin/common/component/data-zoom";

import { isReverse, statePointToData } from "../util";

export class DataZoom extends DataFilterBaseComponent {
    constructor(spec, options) {
        var _a;
        super(spec, options), this.type = ComponentTypeEnum.dataZoom, this.name = ComponentTypeEnum.dataZoom, 
        this.transformerConstructor = DataZoomSpecTransformer, this.specKey = "dataZoom", 
        this.layoutZIndex = LayoutZIndex.DataZoom, this.layoutLevel = LayoutLevel.DataZoom, 
        this.layoutType = "region-relative", this._isReverseCache = !1, this._dataToPositionX = datum => {
            const offsetLeft = this._isHorizontal ? 0 : this._middleHandlerSize, offsetHandler = this._isHorizontal ? this._startHandlerSize / 2 : 0, xScale = this._isHorizontal ? this._stateScale : this._valueScale, xField = this._isHorizontal ? this._stateField : this._valueField;
            return xScale.scale(datum[xField]) + this.getLayoutStartPoint().x + offsetLeft + offsetHandler;
        }, this._dataToPositionX2 = datum => {
            const offsetLeft = this._isHorizontal ? 0 : this._middleHandlerSize, offsetHandler = this._isHorizontal ? this._startHandlerSize / 2 : 0, xScale = this._isHorizontal ? this._stateScale : this._valueScale, min = xScale.domain()[0];
            return xScale.scale(min) + this.getLayoutStartPoint().x + offsetLeft + offsetHandler;
        }, this._dataToPositionY = datum => {
            const offsetTop = this._isHorizontal ? this._middleHandlerSize : 0, offsetHandler = this._isHorizontal ? 0 : this._startHandlerSize / 2, yScale = this._isHorizontal ? this._valueScale : this._getPreviewStateScale(), yField = this._isHorizontal ? this._valueField : this._stateField;
            return yScale.scale(datum[yField]) + this.getLayoutStartPoint().y + offsetTop + offsetHandler;
        }, this._dataToPositionY2 = datum => {
            const offsetTop = this._isHorizontal ? this._middleHandlerSize : 0, offsetHandler = this._isHorizontal ? 0 : this._startHandlerSize / 2, yScale = this._isHorizontal ? this._valueScale : this._getPreviewStateScale(), min = yScale.domain()[0];
            return yScale.scale(min) + this.getLayoutStartPoint().y + offsetTop + offsetHandler;
        }, this._valueField = "y", this._filterMode = null !== (_a = spec.filterMode) && void 0 !== _a ? _a : "filter";
    }
    _handleChange(start, end, updateComponent, tag) {
        if (super._handleChange(start, end, updateComponent), this._shouldChange) if (updateComponent && this._component) this._component.setStartAndEnd(start, end); else {
            const axis = this._relatedAxisComponent, startValue = statePointToData(start, this._stateScale, isReverse(axis, this._isHorizontal)), endValue = statePointToData(end, this._stateScale, isReverse(axis, this._isHorizontal));
            if (!isValid(startValue) || !isValid(endValue)) return;
            this._start = start, this._end = end;
            (isFunction(this._spec.updateDataAfterChange) ? this._spec.updateDataAfterChange(start, end, startValue, endValue) : this._handleStateChange(startValue, endValue, tag)) && this.event.emit(ChartEvent.dataZoomChange, {
                model: this,
                value: {
                    filterData: "axis" !== this._filterMode,
                    start: start,
                    end: end,
                    startValue: this._startValue,
                    endValue: this._endValue,
                    newDomain: this._newDomain
                }
            });
        }
    }
    _handleDataCollectionChange() {
        this._data.getDataView().reRunAllTransform();
        const domain = this._computeDomainOfValueScale();
        domain && (this._valueScale || (this._valueScale = new LinearScale), this._valueScale.domain(domain), 
        this._updateValueScaleRange(), this._component && this._createOrUpdateComponent(!0));
    }
    created() {
        super.created(), this._initValueScale();
    }
    updateLayoutAttribute() {
        !1 !== this._cacheVisibility && super.updateLayoutAttribute();
    }
    _beforeLayoutEnd() {
        super._beforeLayoutEnd();
        const axis = this._relatedAxisComponent;
        (isReverse(axis, this._isHorizontal) && !this._isReverseCache || this._auto) && (this._isReverseCache = isReverse(axis, this._isHorizontal), 
        this.effect.onZoomChange());
    }
    clear() {
        if (this._component) {
            const container = this.getContainer();
            this._component.removeAllChild(), container && container.removeChild(this._component), 
            this._component = null;
        }
        super.clear();
    }
    getBoundsInRect(rect) {
        var _a, _b, _c, _d;
        const result = {
            x1: this.getLayoutStartPoint().x,
            y1: this.getLayoutStartPoint().y,
            x2: 0,
            y2: 0
        }, startHandlerScaleXSize = this._startHandlerSize * (null !== (_a = this._spec.startHandler.style.scaleX) && void 0 !== _a ? _a : 1), startHandlerScaleYSize = this._startHandlerSize * (null !== (_b = this._spec.startHandler.style.scaleY) && void 0 !== _b ? _b : 1), endHandlerScaleXSize = this._endHandlerSize * (null !== (_c = this._spec.endHandler.style.scaleX) && void 0 !== _c ? _c : 1), endHandlerScaleYSize = this._endHandlerSize * (null !== (_d = this._spec.endHandler.style.scaleY) && void 0 !== _d ? _d : 1), extendWidth = this._visible ? this._isHorizontal ? (startHandlerScaleXSize - this._startHandlerSize) / 2 + (endHandlerScaleXSize - this._endHandlerSize) / 2 : (Math.max(startHandlerScaleXSize, endHandlerScaleXSize) - this._width) / 2 : 0, extendHeight = this._visible ? this._isHorizontal ? (Math.max(startHandlerScaleYSize, endHandlerScaleYSize) - this._height) / 2 : (startHandlerScaleYSize - this._startHandlerSize) / 2 + (endHandlerScaleYSize - this._endHandlerSize) / 2 : 0;
        return this._isHorizontal ? (result.y2 = result.y1 + this._height + extendHeight, 
        result.x2 = result.x1 + rect.width + extendWidth) : (result.x2 = result.x1 + this._width + extendWidth, 
        result.y2 = result.y1 + rect.height + extendHeight), result;
    }
    setAttrFromSpec() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        super.setAttrFromSpec();
        const componentSize = this._isHorizontal ? Number(this._spec.height) : Number(this._spec.width);
        this._backgroundSize = null !== (_b = null === (_a = this._spec.background) || void 0 === _a ? void 0 : _a.size) && void 0 !== _b ? _b : 30, 
        this._middleHandlerSize = this._computeMiddleHandlerSize(), isNil(null === (_e = null === (_d = null === (_c = this._spec) || void 0 === _c ? void 0 : _c.startHandler) || void 0 === _d ? void 0 : _d.style) || void 0 === _e ? void 0 : _e.size) && (this._spec.startHandler.style.size = isNaN(componentSize) ? this._backgroundSize : componentSize - this._middleHandlerSize), 
        isNil(null === (_h = null === (_g = null === (_f = this._spec) || void 0 === _f ? void 0 : _f.endHandler) || void 0 === _g ? void 0 : _g.style) || void 0 === _h ? void 0 : _h.size) && (this._spec.endHandler.style.size = isNaN(componentSize) ? this._backgroundSize : componentSize - this._middleHandlerSize);
        const startHandlerVisible = null === (_j = this._spec.startHandler.style.visible) || void 0 === _j || _j, endHandlerVisible = null === (_k = this._spec.endHandler.style.visible) || void 0 === _k || _k;
        this._startHandlerSize = startHandlerVisible ? this._spec.startHandler.style.size : 0, 
        this._endHandlerSize = endHandlerVisible ? this._spec.endHandler.style.size : 0, 
        this._width = this._computeWidth(), this._height = this._computeHeight();
    }
    _initValueScale() {
        const domain = this._computeDomainOfValueScale();
        if (domain) {
            const valueScale = new LinearScale;
            valueScale.domain(domain), this._valueScale = valueScale;
        }
    }
    _updateScaleRange() {
        this._updateStateScaleRange(), this._updateValueScaleRange();
    }
    _updateStateScaleRange() {
        var _a, _b, _c;
        const handlerSize = this._startHandlerSize + this._endHandlerSize;
        if (!this._stateScale) return;
        let stateScaleRange;
        const defaultSize = this._isHorizontal ? this.getLayoutRect().width - handlerSize : this.getLayoutRect().height - handlerSize, defaultRange = null !== (_b = null === (_a = this._relatedAxisComponent) || void 0 === _a ? void 0 : _a.getScale().range()) && void 0 !== _b ? _b : [ this._startHandlerSize / 2, defaultSize + this._startHandlerSize / 2 ], compWidth = this._computeWidth(), compHeight = this._computeHeight();
        stateScaleRange = this._isHorizontal ? this._visible ? [ this._startHandlerSize / 2, compWidth - handlerSize + this._startHandlerSize / 2 ] : defaultRange : this._visible ? [ this._startHandlerSize / 2, compHeight - handlerSize + this._startHandlerSize / 2 ] : defaultRange, 
        this._stateScale.range(stateScaleRange), null === (_c = this._previewStateScale) || void 0 === _c || _c.range(isReverse(this._relatedAxisComponent, this._isHorizontal) ? stateScaleRange.reverse() : stateScaleRange);
    }
    _updateValueScaleRange() {
        if (!this._valueScale) return;
        const compWidth = this._computeWidth(), compHeight = this._computeHeight();
        this._isHorizontal ? this._valueScale.range([ compHeight - this._middleHandlerSize, 0 ]) : "left" === this.layoutOrient ? this._valueScale.range([ compWidth - this._middleHandlerSize, 0 ]) : this._valueScale.range([ 0, compWidth - this._middleHandlerSize ]);
    }
    _computeDomainOfValueScale() {
        const domain = this._data.getLatestData().map((d => d[this._valueField])), domainNum = domain.map((n => 1 * n));
        return domain.length ? [ minInArray(domainNum), maxInArray(domainNum) ] : null;
    }
    _isScaleValid(scale) {
        if (!scale || !scale.domain()) return !1;
        const domain = scale.domain();
        return (!isContinuous(scale.type) || domain[0] !== last(domain)) && (!isDiscrete(scale.type) || 1 !== uniqArray(domain).length);
    }
    _getXScale() {
        return this._relatedAxisComponent.getScale().type === this.stateScale.type && this._isHorizontal ? this.stateScale : this._isHorizontal ? this._stateScale : this._valueScale;
    }
    _getYScale() {
        return this._isHorizontal ? this._valueScale : this._stateScale;
    }
    _computeMiddleHandlerSize() {
        var _a, _b, _c, _d;
        let size = 0;
        if (null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.middleHandler) || void 0 === _b ? void 0 : _b.visible) {
            const middleHandlerIconSize = null !== (_c = this._spec.middleHandler.icon.style.size) && void 0 !== _c ? _c : 8, middleHandlerBackSize = null !== (_d = this._spec.middleHandler.background.size) && void 0 !== _d ? _d : 40;
            size += Math.max(middleHandlerIconSize, middleHandlerBackSize);
        }
        return size;
    }
    _computeWidth() {
        return !1 === this._visible ? 0 : isNumber(this._spec.width) ? this._spec.width : this._isHorizontal ? this.getLayoutRect().width : Math.max(this._startHandlerSize || 0, this._endHandlerSize || 0, this._backgroundSize || 0) + this._middleHandlerSize;
    }
    _computeHeight() {
        return !1 === this._visible ? 0 : isNumber(this._spec.height) ? this._spec.height : this._isHorizontal ? Math.max(this._startHandlerSize || 0, this._endHandlerSize || 0, this._backgroundSize || 0) + this._middleHandlerSize : this.getLayoutRect().height;
    }
    _getAttrs(isNeedPreview) {
        var _a, _b, _c, _d, _e;
        const spec = null !== (_a = this._spec) && void 0 !== _a ? _a : {};
        return Object.assign({
            zIndex: this.layoutZIndex,
            start: this._start,
            end: this._end,
            position: {
                x: this.getLayoutStartPoint().x,
                y: this.getLayoutStartPoint().y
            },
            orient: this._orient,
            size: {
                width: this._computeWidth(),
                height: this._computeHeight()
            },
            showDetail: spec.showDetail,
            brushSelect: null !== (_b = spec.brushSelect) && void 0 !== _b && _b,
            zoomLock: null !== (_c = spec.zoomLock) && void 0 !== _c && _c,
            minSpan: this._minSpan,
            maxSpan: this._maxSpan,
            delayType: spec.delayType,
            delayTime: isValid(spec.delayType) ? null !== (_d = spec.delayTime) && void 0 !== _d ? _d : 30 : 0,
            realTime: null === (_e = spec.realTime) || void 0 === _e || _e,
            previewData: isNeedPreview && this._data.getLatestData(),
            previewPointsX: isNeedPreview && this._dataToPositionX,
            previewPointsY: isNeedPreview && this._dataToPositionY,
            tolerance: this._spec.tolerance,
            isReverse: isReverse(this._relatedAxisComponent, this._isHorizontal)
        }, this._getComponentAttrs(isNeedPreview));
    }
    _getLayoutAttrs() {
        return {
            position: {
                x: this.getLayoutStartPoint().x,
                y: this.getLayoutStartPoint().y
            },
            size: {
                width: this._computeWidth(),
                height: this._computeHeight()
            }
        };
    }
    _createOrUpdateComponent(changeData) {
        if (this._visible) {
            const xScale = this._isHorizontal ? this._stateScale : this._valueScale, yScale = this._isHorizontal ? this._valueScale : this._stateScale, isNeedPreview = this._isScaleValid(xScale) && this._isScaleValid(yScale) && !1 !== this._spec.showBackgroundChart, attrs = this._getAttrs(isNeedPreview), axis = this._relatedAxisComponent;
            if (this._component) this._component.setAttributes(attrs), changeData && (this._component.setPreviewData(this._data.getDataView().latestData), 
            isNeedPreview && (this._isHorizontal ? this._component.setPreviewPointsY1(this._dataToPositionY2) : this._component.setPreviewPointsX1(this._dataToPositionX2), 
            this._component.setStatePointToData((state => statePointToData(state, this._stateScale, isReverse(axis, this._isHorizontal)))))); else {
                const container = this.getContainer();
                this._component = new DataZoomComponent(attrs), this._component.setPreviewData(this._data.getDataView().latestData), 
                this._isHorizontal ? isNeedPreview && this._component.setPreviewPointsY1(this._dataToPositionY2) : isNeedPreview && this._component.setPreviewPointsX1(this._dataToPositionX2), 
                this._component.setStatePointToData((state => statePointToData(state, this._stateScale, isReverse(axis, this._isHorizontal)))), 
                this._component.addEventListener("dataZoomChange", (e => {
                    const {start: start, end: end, tag: tag} = e.detail;
                    this._handleChange(start, end, void 0, tag);
                })), container.add(this._component);
            }
        }
    }
    _getComponentAttrs(isNeedPreview) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const {middleHandler: middleHandler = {}, startText: startText = {}, endText: endText = {}, backgroundChart: backgroundChart = {}, selectedBackgroundChart: selectedBackgroundChart = {}} = this._spec;
        return {
            backgroundStyle: transformToGraphic(null === (_a = this._spec.background) || void 0 === _a ? void 0 : _a.style),
            startHandlerStyle: transformToGraphic(null === (_b = this._spec.startHandler) || void 0 === _b ? void 0 : _b.style),
            middleHandlerStyle: middleHandler.visible ? {
                visible: !0,
                icon: transformToGraphic(null === (_c = middleHandler.icon) || void 0 === _c ? void 0 : _c.style),
                background: {
                    size: null === (_d = middleHandler.background) || void 0 === _d ? void 0 : _d.size,
                    style: transformToGraphic(null === (_e = middleHandler.background) || void 0 === _e ? void 0 : _e.style)
                }
            } : {
                visible: !1
            },
            endHandlerStyle: transformToGraphic(null === (_f = this._spec.endHandler) || void 0 === _f ? void 0 : _f.style),
            startTextStyle: {
                padding: startText.padding,
                formatMethod: this._getHandlerTextFormatMethod(startText),
                textStyle: transformToGraphic(startText.style)
            },
            endTextStyle: {
                padding: endText.padding,
                formatMethod: this._getHandlerTextFormatMethod(endText),
                textStyle: transformToGraphic(endText.style)
            },
            selectedBackgroundStyle: transformToGraphic(this._spec.selectedBackground.style),
            dragMaskStyle: transformToGraphic(null === (_g = this._spec.dragMask) || void 0 === _g ? void 0 : _g.style),
            backgroundChartStyle: isNeedPreview ? {
                line: mergeSpec(transformToGraphic(null === (_h = backgroundChart.line) || void 0 === _h ? void 0 : _h.style), {
                    fill: !1
                }),
                area: Object.assign({
                    curveType: "basis",
                    visible: !0
                }, transformToGraphic(null === (_j = backgroundChart.area) || void 0 === _j ? void 0 : _j.style))
            } : {
                line: {
                    visible: !1
                },
                area: {
                    visible: !1
                }
            },
            selectedBackgroundChartStyle: isNeedPreview ? {
                line: mergeSpec(transformToGraphic(null === (_k = selectedBackgroundChart.line) || void 0 === _k ? void 0 : _k.style), {
                    fill: !1
                }),
                area: Object.assign({
                    curveType: "basis",
                    visible: !0
                }, transformToGraphic(null === (_l = selectedBackgroundChart.area) || void 0 === _l ? void 0 : _l.style))
            } : {
                line: {
                    visible: !1
                },
                area: {
                    visible: !1
                }
            },
            disableTriggerEvent: this._option.disableTriggerEvent
        };
    }
    _getHandlerTextFormatMethod(spec) {
        const {formatMethod: formatMethod, formatter: formatter} = spec, {formatFunc: formatFunc} = getFormatFunction(formatMethod, formatter);
        return formatFunc ? text => formatFunc(text, {
            label: text
        }, formatter) : void 0;
    }
    _getNeedClearVRenderComponents() {
        return [ this._component ];
    }
    onDataUpdate() {
        super.onDataUpdate(), this._previewStateScale !== this._stateScale && (this._previewStateScale = null);
    }
    _getPreviewStateScale() {
        return this._previewStateScale || (isReverse(this._relatedAxisComponent, this._isHorizontal) ? (this._previewStateScale = this._stateScale.clone(), 
        this._previewStateScale.range(this._stateScale.range().reverse())) : this._previewStateScale = this._stateScale), 
        this._previewStateScale;
    }
}

DataZoom.type = ComponentTypeEnum.dataZoom, DataZoom.transformerConstructor = DataZoomSpecTransformer, 
DataZoom.builtInTheme = {
    dataZoom: dataZoom
}, DataZoom.specKey = "dataZoom";

export const registerDataZoom = () => {
    Factory.registerComponent(DataZoom.type, DataZoom);
};
//# sourceMappingURL=data-zoom.js.map
