import { eachSeries } from "../../util/model";

import { BaseComponent } from "../base/base-component";

import { ComponentTypeEnum } from "../interface";

import { dataFilterComputeDomain, dataFilterWithNewDomain, dataToStatePoint, getAxisBandSize, isReverse, lockStatisticsFilter, modeCheck, parseDomainFromStateAndValue, parseDomainFromState, statePointToData } from "./util";

import { registerDataSetInstanceParser, registerDataSetInstanceTransform } from "../../data/register";

import { BandScale, isContinuous, isDiscrete, LinearScale } from "@visactor/vscale";

import { getDirectionByOrient, getOrient } from "../axis/cartesian/util/common";

import { mixin, isNil, isEqual, isValid, array, minInArray, maxInArray, last, isValidNumber } from "@visactor/vutils";

import { dataViewParser, DataView } from "@visactor/vdataset";

import { CompilableData } from "../../compile/data/compilable-data";

import { Zoomable } from "../../interaction/zoom/zoomable";

import { TransformLevel } from "../../data/initialize";

import { AttributeLevel } from "../../constant/attribute";

import { DataFilterEvent } from "./data-filter-event";

import { ChartEvent } from "../../constant/event";

export class DataFilterBaseComponent extends BaseComponent {
    get isHorizontal() {
        return this._isHorizontal;
    }
    get stateScale() {
        return this._stateScale;
    }
    get relatedAxisComponent() {
        return this._relatedAxisComponent;
    }
    setStartAndEnd(start, end, rangeMode = [ "percent", "percent" ]) {
        const [startMode = "percent", endMode = "percent"] = rangeMode, startPercent = "percent" === startMode ? start : dataToStatePoint(start, this._stateScale, this._isHorizontal), endPercent = "percent" === endMode ? end : dataToStatePoint(end, this._stateScale, this._isHorizontal);
        this._handleChange(startPercent, endPercent, !0);
    }
    enableInteraction() {
        this._dataFilterEvent.enableInteraction();
    }
    disableInteraction() {
        this._dataFilterEvent.disableInteraction();
    }
    zoomIn(location) {
        this._dataFilterEvent.zoomIn(location);
    }
    zoomOut(location) {
        this._dataFilterEvent.zoomOut(location);
    }
    _initEvent() {
        var _a;
        this._dataFilterEvent.initZoomEvent(), null === (_a = this._relatedAxisComponent) || void 0 === _a || _a.event.on(ChartEvent.scaleRawDomainUpdate, (({model: model}) => {
            console.log("scaleRawDomainUpdate", model.getRawDomain());
        }));
    }
    _handleChange(start, end, updateComponent) {
        var _a, _b;
        null !== (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.zoomLock) && void 0 !== _b && _b || end - start !== this._spanCache && (end - start < this._minSpan || end - start > this._maxSpan) ? this._shouldChange = !1 : (this._shouldChange = !0, 
        this._spanCache = end - start);
    }
    _updateRangeFactor(tag) {
        const axis = this._relatedAxisComponent, axisScale = axis.getScale(), reverse = isReverse(axis, this._isHorizontal), newRangeFactor = reverse ? [ 1 - this._end, 1 - this._start ] : [ this._start, this._end ];
        if (reverse) switch (tag) {
          case "startHandler":
            axis.scaleRangeFactorEnd(newRangeFactor[1]);
            break;

          case "endHandler":
            axis.scaleRangeFactorStart(newRangeFactor[0]);
            break;

          default:
            axis.scaleRangeFactorStart(newRangeFactor[0], !0), axis.scaleRangeFactorEnd(newRangeFactor[1]);
        } else switch (tag) {
          case "startHandler":
            axis.scaleRangeFactorStart(newRangeFactor[0]);
            break;

          case "endHandler":
            axis.scaleRangeFactorEnd(newRangeFactor[1]);
            break;

          default:
            axis.scaleRangeFactorEnd(newRangeFactor[1], !0), axis.scaleRangeFactorStart(newRangeFactor[0]);
        }
        const newFactor = axisScale.rangeFactor();
        newFactor ? (this._start = reverse ? 1 - newFactor[1] : newFactor[0], this._end = reverse ? 1 - newFactor[0] : newFactor[1]) : (this._start = 0, 
        this._end = 1);
    }
    get visible() {
        return this._visible;
    }
    constructor(spec, options) {
        super(spec, options), this.layoutType = "none", this._orient = "left", this._cacheVisibility = void 0, 
        this._dataUpdating = !1, this._hasInitStateScale = !1, this._shouldChange = !0, 
        this._stateField = "x", this._handleStateChange = (startValue, endValue, tag) => {
            var _a, _b;
            return this._startValue = startValue, this._endValue = endValue, this._newDomain = parseDomainFromState(this._startValue, this._endValue, this._stateScale), 
            null === (_b = (_a = this.effect).onZoomChange) || void 0 === _b || _b.call(_a, tag), 
            !0;
        }, this.effect = {
            onZoomChange: tag => {
                var _a, _b;
                const axis = this._relatedAxisComponent;
                if (axis && "axis" === this._filterMode) {
                    const axisScale = axis.getScale(), axisSpec = axis.getSpec();
                    this._auto && getAxisBandSize(axisSpec) && this._spec.ignoreBandSize && (axisScale.bandwidth("auto"), 
                    axisScale.maxBandwidth("auto"), axisScale.minBandwidth("auto")), this._updateRangeFactor(tag), 
                    this._auto && (null === (_b = null === (_a = this._component) || void 0 === _a ? void 0 : _a.setStartAndEnd) || void 0 === _b || _b.call(_a, this._start, this._end)), 
                    axis.effect.scaleUpdate({
                        value: "force"
                    });
                } else eachSeries(this._regions, (s => {
                    var _a;
                    null === (_a = s.getViewData()) || void 0 === _a || _a.markRunning();
                }), {
                    userId: this._seriesUserId,
                    specIndex: this._seriesIndex
                }), eachSeries(this._regions, (s => {
                    s.reFilterViewData();
                }), {
                    userId: this._seriesUserId,
                    specIndex: this._seriesIndex
                });
            }
        }, this._visible = !0, this._orient = getOrient(spec), this._isHorizontal = "horizontal" === getDirectionByOrient(this._orient), 
        this._dataFilterEvent = new DataFilterEvent(this.type, this._spec, this._handleChange.bind(this), this.getLayoutRect.bind(this), (() => ({
            start: this._start,
            end: this._end
        })), (() => this._regions), (() => this._option).bind(this), (() => this.event));
    }
    created() {
        super.created(), this._setAxisFromSpec(), this._setRegionsFromSpec(), this._initEvent(), 
        this._initData(), this._initStateScale(), this._setStateFromSpec();
    }
    initLayout() {
        super.initLayout(), this._layout && (this._layout.layoutOrient = this._orient);
    }
    init(option) {
        super.init(option), this._addTransformToSeries(), 0 === this._start && 1 === this._end || this.effect.onZoomChange();
    }
    _compareSpec(spec, prevSpec) {
        const result = super._compareSpec(spec, prevSpec);
        return result.reMake || isEqual(prevSpec, spec) || (result.reRender = !0, result.reMake = !0), 
        result;
    }
    reInit(spec) {
        super.reInit(spec), this._marks.forEach((g => {
            g.getMarks().forEach((m => {
                this.initMarkStyleWithSpec(m, this._spec[m.name]);
            }));
        }));
    }
    onLayoutStart(layoutRect, viewRect) {
        super.onLayoutStart(layoutRect, viewRect);
        const isShown = this._autoUpdate(layoutRect);
        this._autoVisible(isShown), this._dataUpdating = !1;
    }
    updateLayoutAttribute() {
        this._visible && this._createOrUpdateComponent(), this._hasInitStateScale || (0 === this._start && 1 === this._end || (this._newDomain = parseDomainFromStateAndValue(this._spec.start, this._startValue, this._spec.end, this._endValue, this._stateScale), 
        this.effect.onZoomChange()), this._hasInitStateScale = !0);
    }
    _initAfterLayout() {
        this._stateScale = null, this._initStateScale(), this._updateScaleRange(), this._setStateFromAxis();
    }
    _beforeLayoutEnd() {
        this._hasInitStateScale ? this._updateScaleRange() : this._initAfterLayout();
    }
    onLayoutEnd() {
        var _a;
        this._beforeLayoutEnd();
        const isShown = !(0 === this._start && 1 === this._end);
        this._autoVisible(isShown), super.onLayoutEnd(), null === (_a = this._relatedAxisComponent) || void 0 === _a || _a.updateScaleRange();
    }
    getBoundsInRect(rect) {
        const result = {
            x1: this.getLayoutStartPoint().x,
            y1: this.getLayoutStartPoint().y,
            x2: 0,
            y2: 0
        };
        return this._isHorizontal ? (result.y2 = result.y1 + this._height, result.x2 = result.x1 + rect.width) : (result.x2 = result.x1 + this._width, 
        result.y2 = result.y1 + rect.height), result;
    }
    setAttrFromSpec() {
        var _a;
        super.setAttrFromSpec(), this._dataFilterEvent.setEventAttrFromSpec(), this._field = this._spec.field, 
        this._width = this._computeWidth(), this._height = this._computeHeight(), this._visible = null === (_a = this._spec.visible) || void 0 === _a || _a;
    }
    _setAxisFromSpec() {
        if (isValid(this._spec.axisId) ? this._relatedAxisComponent = this._option.getComponentByUserId(this._spec.axisId) : isValid(this._spec.axisIndex) && (this._relatedAxisComponent = this._option.getComponentByIndex("axes", this._spec.axisIndex)), 
        isNil(this._spec.field) && !this._relatedAxisComponent) {
            const axes = this._option.getComponentsByKey("axes"), sameOrientAxis = axes.find((cm => getDirectionByOrient(cm._orient) === getDirectionByOrient(this._orient)));
            if (sameOrientAxis) this._relatedAxisComponent = sameOrientAxis; else {
                const bandAxis = axes.find((cm => !isContinuous(cm.getScale().type)));
                this._relatedAxisComponent = bandAxis;
            }
        }
        this._relatedAxisComponent && "axis" === this._filterMode && (this._relatedAxisComponent.autoIndentOnce = !0);
    }
    _setRegionsFromSpec() {
        var _a, _b;
        this._regions = this._relatedAxisComponent ? this._relatedAxisComponent.getRegions() : this._option.getAllRegions();
        const bindSeriesFilter = this._relatedAxisComponent ? null === (_b = (_a = this._relatedAxisComponent).getBindSeriesFilter) || void 0 === _b ? void 0 : _b.call(_a) : null;
        if (isValid(bindSeriesFilter) && (isValid(bindSeriesFilter.userId) && (this._seriesUserId = array(bindSeriesFilter.userId)), 
        isValid(bindSeriesFilter.specIndex) && (this._seriesIndex = array(bindSeriesFilter.specIndex))), 
        isValid(this._spec.seriesId)) {
            const specSeriesId = array(this._spec.seriesId);
            this._seriesUserId ? this._seriesUserId = this._seriesUserId.filter((s => specSeriesId.includes(s))) : this._seriesUserId = specSeriesId;
        }
        if (isValid(this._spec.seriesIndex)) {
            const specSeriesIndex = array(this._spec.seriesIndex);
            this._seriesIndex ? this._seriesIndex = this._seriesIndex.filter((s => specSeriesIndex.includes(s))) : this._seriesIndex = specSeriesIndex;
        }
        if (isValid(this._spec.regionIndex)) {
            const regionsFromSpec = this._option.getRegionsInIndex(array(this._spec.regionIndex));
            this._regions = this._regions.filter((r => regionsFromSpec.includes(r)));
        } else if (isValid(this._spec.regionId)) {
            const ids = array(this._spec.regionId);
            this._regions = ids.length ? this._regions.filter((r => ids.includes(r.id))) : [];
        } else ;
    }
    _initData() {
        const dataCollection = [], seriesCollection = [], stateFields = [], valueFields = [];
        let isCategoryState;
        if (this._relatedAxisComponent) {
            const originalStateFields = {};
            eachSeries(this._regions, (s => {
                var _a, _b;
                const xAxisHelper = "cartesian" === s.coordinate ? s.getXAxisHelper() : "polar" === s.coordinate ? s.angleAxisHelper : null, yAxisHelper = "cartesian" === s.coordinate ? s.getYAxisHelper() : "polar" === s.coordinate ? s.radiusAxisHelper : null;
                if (!xAxisHelper || !yAxisHelper) return;
                const stateAxisHelper = xAxisHelper.getAxisId() === this._relatedAxisComponent.id ? xAxisHelper : yAxisHelper.getAxisId() === this._relatedAxisComponent.id ? yAxisHelper : this._isHorizontal ? xAxisHelper : yAxisHelper, valueAxisHelper = stateAxisHelper === xAxisHelper ? yAxisHelper : xAxisHelper, isValidateValueAxis = isContinuous(valueAxisHelper.getScale(0).type), isValidateStateAxis = isContinuous(stateAxisHelper.getScale(0).type);
                dataCollection.push(s.getRawData());
                const seriesSpec = s.getSpec(), xField = "cartesian" === s.coordinate ? array(seriesSpec.xField) : array(null !== (_a = seriesSpec.angleField) && void 0 !== _a ? _a : seriesSpec.categoryField), yField = "cartesian" === s.coordinate ? array(seriesSpec.yField) : array(null !== (_b = seriesSpec.radiusField) && void 0 !== _b ? _b : seriesSpec.valueField);
                if (originalStateFields[s.id] = "link" === s.type ? [ "from_xField" ] : stateAxisHelper === xAxisHelper ? xField : yField, 
                isValidateStateAxis ? (isCategoryState = !1, stateFields.push(originalStateFields[s.id])) : (isCategoryState = !0, 
                stateFields.push(originalStateFields[s.id][0])), this._valueField) {
                    const valueField = "link" === s.type ? [ "from_yField" ] : valueAxisHelper === xAxisHelper ? xField : yField;
                    isValidateValueAxis && valueFields.push(...valueField);
                }
            }), {
                userId: this._seriesUserId,
                specIndex: this._seriesIndex
            }), this._originalStateFields = originalStateFields;
        } else eachSeries(this._regions, (s => {
            dataCollection.push(s.getRawData()), seriesCollection.push(s), stateFields.push(this._field), 
            this._valueField && valueFields.push(this._spec.valueField);
        }), {
            userId: this._seriesUserId,
            specIndex: this._seriesIndex
        });
        const {dataSet: dataSet} = this._option;
        registerDataSetInstanceParser(dataSet, "dataview", dataViewParser), registerDataSetInstanceTransform(dataSet, "dataFilterComputeDomain", dataFilterComputeDomain);
        const data = new DataView(dataSet, {
            name: `${this.type}_${this.id}_data`
        });
        data.transform({
            type: "dataFilterComputeDomain",
            options: {
                input: {
                    dataCollection: dataCollection,
                    seriesCollection: seriesCollection,
                    stateFields: stateFields,
                    valueFields: valueFields,
                    isCategoryState: isCategoryState
                },
                output: {
                    stateField: this._stateField,
                    valueField: this._valueField
                }
            }
        }, !1), this._data = new CompilableData(this._option, data), data.reRunAllTransform(), 
        dataSet.multipleDataViewAddListener(dataCollection, "change", this._handleDataCollectionChange.bind(this));
    }
    _addTransformToSeries() {
        this._relatedAxisComponent && "axis" === this._filterMode || (registerDataSetInstanceTransform(this._option.dataSet, "dataFilterWithNewDomain", dataFilterWithNewDomain), 
        registerDataSetInstanceTransform(this._option.dataSet, "lockStatisticsFilter", lockStatisticsFilter), 
        eachSeries(this._regions, (s => {
            s.getViewDataStatistics().transform({
                type: "lockStatisticsFilter",
                options: {
                    originalFields: () => s.getViewDataStatistics().getFields(),
                    getNewDomain: () => this._newDomain,
                    field: () => {
                        var _a;
                        return null !== (_a = this._field) && void 0 !== _a ? _a : this._parseFieldOfSeries(s);
                    },
                    isContinuous: () => isContinuous(this._stateScale.type)
                },
                level: 1
            }, !1), s.addViewDataFilter({
                type: "dataFilterWithNewDomain",
                options: {
                    getNewDomain: () => this._newDomain,
                    field: () => {
                        var _a;
                        return null !== (_a = this._field) && void 0 !== _a ? _a : this._parseFieldOfSeries(s);
                    },
                    isContinuous: () => isContinuous(this._stateScale.type)
                },
                level: TransformLevel.dataZoomFilter
            });
        }), {
            userId: this._seriesUserId,
            specIndex: this._seriesIndex
        }));
    }
    onDataUpdate() {
        var _a;
        const domain = this._computeDomainOfStateScale(isContinuous(this._stateScale.type));
        this._stateScale.domain(domain, !1), this._handleChange(this._start, this._end, !0), 
        this._spec.auto && !isEqual(this._domainCache, domain) && (this._domainCache = domain, 
        this._dataUpdating = !0, null === (_a = this.getChart()) || void 0 === _a || _a.setLayoutTag(!0, null, !1));
    }
    _parseFieldOfSeries(s) {
        var _a;
        return null === (_a = this._originalStateFields) || void 0 === _a ? void 0 : _a[s.id];
    }
    _setStateFromSpec() {
        let start, end;
        if (this._auto = !!this._spec.auto, this._spec.rangeMode) {
            const [startMode, endMode] = this._spec.rangeMode;
            modeCheck("start", startMode, this._spec) && modeCheck("end", endMode, this._spec) && (start = "percent" === startMode ? this._spec.start : dataToStatePoint(this._spec.startValue, this._stateScale, this._isHorizontal), 
            end = "percent" === endMode ? this._spec.end : dataToStatePoint(this._spec.endValue, this._stateScale, this._isHorizontal));
        } else start = this._spec.start ? this._spec.start : this._spec.startValue ? dataToStatePoint(this._spec.startValue, this._stateScale, this._isHorizontal) : 0, 
        end = this._spec.end ? this._spec.end : this._spec.endValue ? dataToStatePoint(this._spec.endValue, this._stateScale, this._isHorizontal) : 1;
        this._start = Math.max(0, Math.min(1, start)), this._end = Math.max(0, Math.min(1, end));
    }
    _setStateFromAxis() {
        var _a, _b;
        this._setStateFromSpec();
        const axis = this._relatedAxisComponent;
        this._startValue = statePointToData(this._start, this._stateScale, isReverse(axis, this._isHorizontal)), 
        this._endValue = statePointToData(this._end, this._stateScale, isReverse(axis, this._isHorizontal)), 
        this._minSpan = null !== (_a = this._spec.minSpan) && void 0 !== _a ? _a : 0, this._maxSpan = null !== (_b = this._spec.maxSpan) && void 0 !== _b ? _b : 1, 
        isContinuous(this._stateScale.type) && this._stateScale.domain()[0] !== last(this._stateScale.domain()) && (this._spec.minValueSpan && (this._minSpan = this._spec.minValueSpan / (last(this._stateScale.domain()) - this._stateScale.domain()[0])), 
        this._spec.maxValueSpan && (this._maxSpan = this._spec.maxValueSpan / (last(this._stateScale.domain()) - this._stateScale.domain()[0]))), 
        this._minSpan = Math.max(0, this._minSpan), this._maxSpan = Math.min(this._maxSpan, 1), 
        axis && (axis && "axis" === this._filterMode || 0 === this._start && 1 === this._end || (this._newDomain = parseDomainFromState(this._startValue, this._endValue, this._stateScale)));
    }
    _initStateScale() {
        var _a, _b, _c, _d, _e, _f;
        const defaultRange = [ 0, 1 ];
        if (this._relatedAxisComponent) {
            const scale = this._relatedAxisComponent.getScale().clone();
            this._stateScale = scale, null === (_b = (_a = scale).maxBandwidth) || void 0 === _b || _b.call(_a, "auto", !0), 
            null === (_d = (_c = scale).minBandwidth) || void 0 === _d || _d.call(_c, "auto", !0), 
            null === (_f = (_e = scale).bandwidth) || void 0 === _f || _f.call(_e, "auto", !0), 
            scale.rangeFactor(defaultRange, !0).range(defaultRange);
        } else {
            let fieldLinear = !0;
            this._field && eachSeries(this._regions, (s => {
                const stats = s.getRawDataStatisticsByField(this._field);
                isValidNumber(null == stats ? void 0 : stats.min) && isValidNumber(null == stats ? void 0 : stats.max) || (fieldLinear = !1);
            }), {
                userId: this._seriesUserId,
                specIndex: this._seriesIndex
            }), this._stateScale = fieldLinear ? new LinearScale : new BandScale, this._stateScale.domain(this._computeDomainOfStateScale(fieldLinear), !0).range(defaultRange);
        }
    }
    _computeDomainOfStateScale(isContinuous) {
        if (this._spec.customDomain) return this._spec.customDomain;
        const domain = this._data.getLatestData().map((d => d[this._stateField]));
        if (isContinuous) {
            const domainNum = domain.map((n => 1 * n));
            return domain.length ? [ minInArray(domainNum), maxInArray(domainNum) ] : [ -1 / 0, 1 / 0 ];
        }
        return domain;
    }
    _autoVisible(isShown) {
        if (!this._auto) return;
        isShown ? this.show() : this.hide();
        const sizeKey = this._isHorizontal ? "height" : "width";
        this.layout.setLayoutRect({
            [sizeKey]: isShown ? this[`_${sizeKey}`] : 0
        }, {
            [sizeKey]: AttributeLevel.Built_In
        });
    }
    hide() {
        var _a;
        null === (_a = this._component) || void 0 === _a || _a.hideAll();
    }
    show() {
        var _a;
        null === (_a = this._component) || void 0 === _a || _a.showAll();
    }
    _autoUpdate(rect) {
        var _a, _b, _c, _d, _e, _f;
        if (!this._auto) return this._cacheVisibility = void 0, !0;
        const axis = this._relatedAxisComponent, axisSpec = null == axis ? void 0 : axis.getSpec(), axisScale = null == axis ? void 0 : axis.getScale(), bandSizeResult = getAxisBandSize(axisSpec);
        if (!this._dataUpdating && isDiscrete(axisScale.type) && (null == rect ? void 0 : rect.height) === (null === (_a = this._cacheRect) || void 0 === _a ? void 0 : _a.height) && (null == rect ? void 0 : rect.width) === (null === (_b = this._cacheRect) || void 0 === _b ? void 0 : _b.width) && this._fixedBandSize === (null == bandSizeResult ? void 0 : bandSizeResult.bandSize)) return this._cacheVisibility;
        let isShown = !0;
        if (this._isHorizontal && (null == rect ? void 0 : rect.width) !== (null === (_c = this._cacheRect) || void 0 === _c ? void 0 : _c.width) ? axisScale.range(axis.getInverse() ? [ rect.width, 0 ] : [ 0, rect.width ]) : (null == rect ? void 0 : rect.height) !== (null === (_d = this._cacheRect) || void 0 === _d ? void 0 : _d.height) && axisScale.range(axis.getInverse() ? [ 0, rect.height ] : [ rect.height, 0 ]), 
        this._cacheRect = {
            width: null == rect ? void 0 : rect.width,
            height: null == rect ? void 0 : rect.height
        }, this._fixedBandSize = null == bandSizeResult ? void 0 : bandSizeResult.bandSize, 
        isDiscrete(axisScale.type)) {
            bandSizeResult && (this._start || this._end) && (this.type === ComponentTypeEnum.scrollBar && (this._start = 0, 
            this._end = 1), this._updateRangeFactor());
            const [start, end] = null !== (_e = axisScale.rangeFactor()) && void 0 !== _e ? _e : [];
            isShown = (!isNil(start) || !isNil(end)) && !(0 === start && 1 === end);
        } else {
            const [start, end] = null !== (_f = axisScale.rangeFactor()) && void 0 !== _f ? _f : [ this._start, this._end ];
            isShown = !(0 === start && 1 === end);
        }
        return this.setStartAndEnd(this._start, this._end), this._cacheVisibility = isShown, 
        isShown;
    }
    _getNeedClearVRenderComponents() {
        return [ this._component ];
    }
}

mixin(DataFilterBaseComponent, Zoomable);
//# sourceMappingURL=data-filter-base-component.js.map
