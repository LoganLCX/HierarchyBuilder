import { isArray, isValid, last } from "@visactor/vutils";

import { array, isNil } from "../../util";

import { isContinuous } from "@visactor/vscale";

export const lockStatisticsFilter = (statisticsData, op) => {
    const {getNewDomain: getNewDomain, isContinuous: isContinuous, field: field, originalFields: originalFields} = op, datumField = field(), newDomain = getNewDomain();
    if (isNil(newDomain) || isNil(datumField)) return statisticsData;
    const fields = originalFields(), realField = isArray(datumField) ? datumField[0] : datumField;
    return statisticsData[realField] && fields && fields[realField] && fields[realField].lockStatisticsByDomain && !isContinuous() && (statisticsData[realField].values = newDomain), 
    statisticsData;
};

export const dataFilterWithNewDomain = (data, op) => {
    const {getNewDomain: getNewDomain, isContinuous: isContinuous, field: field} = op, datumField = field(), newDomain = getNewDomain();
    if (isNil(newDomain) || isNil(datumField)) return data;
    if (0 === newDomain.length) return [];
    const domainMap = {};
    newDomain.forEach((d => {
        domainMap[d] || (domainMap[d] = 1);
    }));
    let filter = null;
    return filter = isContinuous() ? d => {
        let flag = !1;
        return array(datumField).every((field => {
            d[field] >= newDomain[0] && d[field] <= last(newDomain) && (flag = !0);
        })), flag;
    } : d => {
        let flag = !1;
        return array(datumField).every((field => {
            (domainMap[d[field] + ""] || domainMap[d[field]]) && (flag = !0);
        })), flag;
    }, data.filter(filter);
};

export const dataFilterComputeDomain = (data, op) => {
    const {stateFields: stateFields, valueFields: valueFields, dataCollection: dataCollection, isCategoryState: isCategoryState, seriesCollection: seriesCollection} = op.input, {stateField: stateField, valueField: valueField} = op.output, resultObj = {}, resultKeys = [], resultData = [], stateValues = [];
    let hasLockDomain = !1, isAllLinearValue = !1;
    dataCollection.forEach(((dv, i) => {
        var _a;
        if (isNil(stateFields[i])) return;
        const series = seriesCollection[i];
        if (series) {
            const statistics = series.getRawDataStatisticsByField(stateFields[i]);
            isValid(null == statistics ? void 0 : statistics.max) && isValid(null == statistics ? void 0 : statistics.min) && (isAllLinearValue = !0);
        }
        const stateFieldInfo = null === (_a = dv.getFields()) || void 0 === _a ? void 0 : _a[stateFields[i]];
        stateFieldInfo && stateFieldInfo.lockStatisticsByDomain && (hasLockDomain = !0, 
        stateFieldInfo.domain.forEach((d => {
            isNil(resultObj[d]) && (stateValues.push(d), resultObj[d] = 0, resultKeys.push(d));
        }))), dv.latestData.forEach((d => {
            array(stateFields[i]).forEach((state => {
                isNil(d[state]) || (isNil(resultObj[d[state]]) && (stateValues.push(d[state]), resultObj[d[state]] = 0, 
                resultKeys.push(d[state])), isNil(valueFields[i]) || (resultObj[d[state]] += isNaN(parseFloat(d[valueFields[i]])) ? 1 : parseFloat(d[valueFields[i]])));
            }));
        }));
    }));
    return (hasLockDomain ? stateValues : !1 === isCategoryState || isAllLinearValue ? stateValues.sort(((a, b) => a - b)) : resultKeys).forEach((state => {
        const res = {
            [stateField]: state
        };
        valueField && (res[valueField] = resultObj[state]), resultData.push(res);
    })), resultData;
};

export const statePointToData = (state, scale, reverse) => {
    const domain = scale.domain();
    if (isContinuous(scale.type)) return reverse ? domain[0] + (last(domain) - domain[0]) * (1 - state) : domain[0] + (last(domain) - domain[0]) * state;
    let range = scale.range();
    reverse && (range = range.slice().reverse());
    const posInRange = range[0] + (last(range) - range[0]) * state;
    return scale.invert(posInRange);
};

export const dataToStatePoint = (data, scale, isHorizontal) => {
    const pos = scale.scale(data);
    let range = scale.range();
    return !isHorizontal && isContinuous(scale.type) && (range = range.slice().reverse()), 
    Math.max(0, Math.min(1, (pos - range[0]) / (last(range) - range[0])));
};

export const isReverse = (axisComponent, isHorizontal) => {
    const axis = axisComponent;
    if (!axis) return !1;
    const axisScale = axis.getScale();
    return axisScale.range()[0] > axisScale.range()[1] && (!axis.getInverse() || isHorizontal);
};

export const getAxisBandSize = axisSpec => {
    const bandSize = null == axisSpec ? void 0 : axisSpec.bandSize, maxBandSize = null == axisSpec ? void 0 : axisSpec.maxBandSize, minBandSize = null == axisSpec ? void 0 : axisSpec.minBandSize;
    if (bandSize || minBandSize || maxBandSize) return {
        bandSize: bandSize,
        maxBandSize: maxBandSize,
        minBandSize: minBandSize
    };
};

export const modeCheck = (statePoint, mode, spec) => "start" === statePoint ? "percent" === mode && isValid(spec.start) || "value" === mode && isValid(spec.startValue) : "percent" === mode && isValid(spec.end) || "value" === mode && isValid(spec.endValue);

export const parseDomainFromState = (startValue, endValue, scale) => {
    if (isContinuous(scale.type)) return [ Math.min(endValue, startValue), Math.max(endValue, startValue) ];
    const allDomain = scale.domain(), startIndex = allDomain.indexOf(startValue), endIndex = allDomain.indexOf(endValue);
    return allDomain.slice(Math.min(startIndex, endIndex), Math.max(startIndex, endIndex) + 1);
};

export const parseDomainFromStateAndValue = (start, startValue, end, endValue, scale) => {
    if (isContinuous(scale.type)) {
        const domain = scale.domain(), min = domain[0], total = last(domain) - min, resultStart = isValid(start) ? min + total * start : +startValue, resultEnd = isValid(end) ? min + total * end : +endValue;
        return [ Math.min(resultEnd, resultStart), Math.max(resultEnd, resultStart) ];
    }
    const allDomain = scale.domain(), range = scale.range(), rangeSize = range[range.length - 1] - range[0], startIndex = isValid(start) ? allDomain.indexOf(scale.invert(rangeSize * start + range[0])) : allDomain.indexOf(startValue), endIndex = isValid(end) ? allDomain.indexOf(scale.invert(rangeSize * end + range[0])) : allDomain.indexOf(endValue);
    return allDomain.slice(Math.min(startIndex, endIndex), Math.max(startIndex, endIndex) + 1);
};
//# sourceMappingURL=util.js.map
