"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.parseDomainFromStateAndValue = exports.parseDomainFromState = exports.modeCheck = exports.getAxisBandSize = exports.isReverse = exports.dataToStatePoint = exports.statePointToData = exports.dataFilterComputeDomain = exports.dataFilterWithNewDomain = exports.lockStatisticsFilter = void 0;

const vutils_1 = require("@visactor/vutils"), util_1 = require("../../util"), vscale_1 = require("@visactor/vscale"), lockStatisticsFilter = (statisticsData, op) => {
    const {getNewDomain: getNewDomain, isContinuous: isContinuous, field: field, originalFields: originalFields} = op, datumField = field(), newDomain = getNewDomain();
    if ((0, util_1.isNil)(newDomain) || (0, util_1.isNil)(datumField)) return statisticsData;
    const fields = originalFields(), realField = (0, vutils_1.isArray)(datumField) ? datumField[0] : datumField;
    return statisticsData[realField] && fields && fields[realField] && fields[realField].lockStatisticsByDomain && !isContinuous() && (statisticsData[realField].values = newDomain), 
    statisticsData;
};

exports.lockStatisticsFilter = lockStatisticsFilter;

const dataFilterWithNewDomain = (data, op) => {
    const {getNewDomain: getNewDomain, isContinuous: isContinuous, field: field} = op, datumField = field(), newDomain = getNewDomain();
    if ((0, util_1.isNil)(newDomain) || (0, util_1.isNil)(datumField)) return data;
    if (0 === newDomain.length) return [];
    const domainMap = {};
    newDomain.forEach((d => {
        domainMap[d] || (domainMap[d] = 1);
    }));
    let filter = null;
    return filter = isContinuous() ? d => {
        let flag = !1;
        return (0, util_1.array)(datumField).every((field => {
            d[field] >= newDomain[0] && d[field] <= (0, vutils_1.last)(newDomain) && (flag = !0);
        })), flag;
    } : d => {
        let flag = !1;
        return (0, util_1.array)(datumField).every((field => {
            (domainMap[d[field] + ""] || domainMap[d[field]]) && (flag = !0);
        })), flag;
    }, data.filter(filter);
};

exports.dataFilterWithNewDomain = dataFilterWithNewDomain;

const dataFilterComputeDomain = (data, op) => {
    const {stateFields: stateFields, valueFields: valueFields, dataCollection: dataCollection, isCategoryState: isCategoryState, seriesCollection: seriesCollection} = op.input, {stateField: stateField, valueField: valueField} = op.output, resultObj = {}, resultKeys = [], resultData = [], stateValues = [];
    let hasLockDomain = !1, isAllLinearValue = !1;
    dataCollection.forEach(((dv, i) => {
        var _a;
        if ((0, util_1.isNil)(stateFields[i])) return;
        const series = seriesCollection[i];
        if (series) {
            const statistics = series.getRawDataStatisticsByField(stateFields[i]);
            (0, vutils_1.isValid)(null == statistics ? void 0 : statistics.max) && (0, vutils_1.isValid)(null == statistics ? void 0 : statistics.min) && (isAllLinearValue = !0);
        }
        const stateFieldInfo = null === (_a = dv.getFields()) || void 0 === _a ? void 0 : _a[stateFields[i]];
        stateFieldInfo && stateFieldInfo.lockStatisticsByDomain && (hasLockDomain = !0, 
        stateFieldInfo.domain.forEach((d => {
            (0, util_1.isNil)(resultObj[d]) && (stateValues.push(d), resultObj[d] = 0, resultKeys.push(d));
        }))), dv.latestData.forEach((d => {
            (0, util_1.array)(stateFields[i]).forEach((state => {
                (0, util_1.isNil)(d[state]) || ((0, util_1.isNil)(resultObj[d[state]]) && (stateValues.push(d[state]), 
                resultObj[d[state]] = 0, resultKeys.push(d[state])), (0, util_1.isNil)(valueFields[i]) || (resultObj[d[state]] += isNaN(parseFloat(d[valueFields[i]])) ? 1 : parseFloat(d[valueFields[i]])));
            }));
        }));
    }));
    return (hasLockDomain ? stateValues : !1 === isCategoryState || isAllLinearValue ? stateValues.sort(((a, b) => a - b)) : resultKeys).forEach((state => {
        const res = {
            [stateField]: state
        };
        valueField && (res[valueField] = resultObj[state]), resultData.push(res);
    })), resultData;
};

exports.dataFilterComputeDomain = dataFilterComputeDomain;

const statePointToData = (state, scale, reverse) => {
    const domain = scale.domain();
    if ((0, vscale_1.isContinuous)(scale.type)) return reverse ? domain[0] + ((0, vutils_1.last)(domain) - domain[0]) * (1 - state) : domain[0] + ((0, 
    vutils_1.last)(domain) - domain[0]) * state;
    let range = scale.range();
    reverse && (range = range.slice().reverse());
    const posInRange = range[0] + ((0, vutils_1.last)(range) - range[0]) * state;
    return scale.invert(posInRange);
};

exports.statePointToData = statePointToData;

const dataToStatePoint = (data, scale, isHorizontal) => {
    const pos = scale.scale(data);
    let range = scale.range();
    return !isHorizontal && (0, vscale_1.isContinuous)(scale.type) && (range = range.slice().reverse()), 
    Math.max(0, Math.min(1, (pos - range[0]) / ((0, vutils_1.last)(range) - range[0])));
};

exports.dataToStatePoint = dataToStatePoint;

const isReverse = (axisComponent, isHorizontal) => {
    const axis = axisComponent;
    if (!axis) return !1;
    const axisScale = axis.getScale();
    return axisScale.range()[0] > axisScale.range()[1] && (!axis.getInverse() || isHorizontal);
};

exports.isReverse = isReverse;

const getAxisBandSize = axisSpec => {
    const bandSize = null == axisSpec ? void 0 : axisSpec.bandSize, maxBandSize = null == axisSpec ? void 0 : axisSpec.maxBandSize, minBandSize = null == axisSpec ? void 0 : axisSpec.minBandSize;
    if (bandSize || minBandSize || maxBandSize) return {
        bandSize: bandSize,
        maxBandSize: maxBandSize,
        minBandSize: minBandSize
    };
};

exports.getAxisBandSize = getAxisBandSize;

const modeCheck = (statePoint, mode, spec) => "start" === statePoint ? "percent" === mode && (0, 
vutils_1.isValid)(spec.start) || "value" === mode && (0, vutils_1.isValid)(spec.startValue) : "percent" === mode && (0, 
vutils_1.isValid)(spec.end) || "value" === mode && (0, vutils_1.isValid)(spec.endValue);

exports.modeCheck = modeCheck;

const parseDomainFromState = (startValue, endValue, scale) => {
    if ((0, vscale_1.isContinuous)(scale.type)) return [ Math.min(endValue, startValue), Math.max(endValue, startValue) ];
    const allDomain = scale.domain(), startIndex = allDomain.indexOf(startValue), endIndex = allDomain.indexOf(endValue);
    return allDomain.slice(Math.min(startIndex, endIndex), Math.max(startIndex, endIndex) + 1);
};

exports.parseDomainFromState = parseDomainFromState;

const parseDomainFromStateAndValue = (start, startValue, end, endValue, scale) => {
    if ((0, vscale_1.isContinuous)(scale.type)) {
        const domain = scale.domain(), min = domain[0], total = (0, vutils_1.last)(domain) - min, resultStart = (0, 
        vutils_1.isValid)(start) ? min + total * start : +startValue, resultEnd = (0, vutils_1.isValid)(end) ? min + total * end : +endValue;
        return [ Math.min(resultEnd, resultStart), Math.max(resultEnd, resultStart) ];
    }
    const allDomain = scale.domain(), range = scale.range(), rangeSize = range[range.length - 1] - range[0], startIndex = (0, 
    vutils_1.isValid)(start) ? allDomain.indexOf(scale.invert(rangeSize * start + range[0])) : allDomain.indexOf(startValue), endIndex = (0, 
    vutils_1.isValid)(end) ? allDomain.indexOf(scale.invert(rangeSize * end + range[0])) : allDomain.indexOf(endValue);
    return allDomain.slice(Math.min(startIndex, endIndex), Math.max(startIndex, endIndex) + 1);
};

exports.parseDomainFromStateAndValue = parseDomainFromStateAndValue;
//# sourceMappingURL=util.js.map
