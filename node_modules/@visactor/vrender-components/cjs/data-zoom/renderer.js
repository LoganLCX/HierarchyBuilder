"use strict";

var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
    if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
    }
    return t;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DataZoomRenderer = void 0;

const vrender_core_1 = require("@visactor/vrender-core"), vutils_1 = require("@visactor/vutils"), tag_1 = require("../tag"), config_1 = require("./config"), utils_1 = require("./utils");

class DataZoomRenderer {
    get startHandlerMask() {
        return this._startHandlerMask;
    }
    get middleHandlerSymbol() {
        return this._middleHandlerSymbol;
    }
    get middleHandlerRect() {
        return this._middleHandlerRect;
    }
    get endHandlerMask() {
        return this._endHandlerMask;
    }
    get selectedBackground() {
        return this._selectedBackground;
    }
    get dragMask() {
        return this._dragMask;
    }
    get startText() {
        return this._startText;
    }
    get endText() {
        return this._endText;
    }
    get startValue() {
        return this._startValue;
    }
    get endValue() {
        return this._endValue;
    }
    set showText(showText) {
        this._showText = showText;
    }
    get background() {
        return this._background;
    }
    set previewData(previewData) {
        this._previewData = previewData;
    }
    get previewGroup() {
        return this._previewGroup;
    }
    get selectedPreviewGroup() {
        return this._selectedPreviewGroup;
    }
    set previewPointsX(previewPointsX) {
        this._previewPointsX = previewPointsX;
    }
    set previewPointsY(previewPointsY) {
        this._previewPointsY = previewPointsY;
    }
    set previewPointsX1(previewPointsX1) {
        this._previewPointsX1 = previewPointsX1;
    }
    set previewPointsY1(previewPointsY1) {
        this._previewPointsY1 = previewPointsY1;
    }
    set statePointToData(statePointToData) {
        this._statePointToData = statePointToData;
    }
    _initAttrs(props) {
        this.attribute = props.attribute, this._isHorizontal = "top" === this.attribute.orient || "bottom" === this.attribute.orient;
        const {previewData: previewData, previewPointsX: previewPointsX, previewPointsY: previewPointsY, previewPointsX1: previewPointsX1, previewPointsY1: previewPointsY1} = this.attribute;
        previewData && (this._previewData = previewData), (0, vutils_1.isFunction)(previewPointsX) && (this._previewPointsX = previewPointsX), 
        (0, vutils_1.isFunction)(previewPointsY) && (this._previewPointsY = previewPointsY), 
        (0, vutils_1.isFunction)(previewPointsX1) && (this._previewPointsX1 = previewPointsX1), 
        (0, vutils_1.isFunction)(previewPointsY1) && (this._previewPointsY1 = previewPointsY1), 
        this._getState = props.getState, this._getLayoutAttrFromConfig = props.getLayoutAttrFromConfig, 
        this._getContainer = props.getContainer;
    }
    constructor(props) {
        this._previewData = [], this._statePointToData = state => state;
        const {showDetail: showDetail} = props.attribute;
        this._showText = "auto" !== showDetail && showDetail, this._initAttrs(props);
    }
    setAttributes(props) {
        this._initAttrs(props);
    }
    renderDataZoom(onlyStateChange = !1) {
        var _a, _b, _c, _d, _e, _f;
        const {backgroundChartStyle: backgroundChartStyle = {}, selectedBackgroundChartStyle: selectedBackgroundChartStyle = {}, brushSelect: brushSelect} = this.attribute;
        this._renderBackground(), (null === (_a = backgroundChartStyle.line) || void 0 === _a ? void 0 : _a.visible) && !onlyStateChange && this._setPreviewAttributes("line", this._getContainer()), 
        (null === (_b = backgroundChartStyle.area) || void 0 === _b ? void 0 : _b.visible) && !onlyStateChange && this._setPreviewAttributes("area", this._getContainer()), 
        brushSelect && this.renderDragMask(), this._renderSelectedBackground(), (null === (_c = selectedBackgroundChartStyle.line) || void 0 === _c ? void 0 : _c.visible) && this._setSelectedPreviewClipAttributes("line", this._getContainer()), 
        (null === (_d = selectedBackgroundChartStyle.line) || void 0 === _d ? void 0 : _d.visible) && !onlyStateChange && this._setSelectedPreviewAttributes("line"), 
        (null === (_e = selectedBackgroundChartStyle.line) || void 0 === _e ? void 0 : _e.visible) && this._setSelectedPreviewClipAttributes("area", this._getContainer()), 
        (null === (_f = selectedBackgroundChartStyle.area) || void 0 === _f ? void 0 : _f.visible) && !onlyStateChange && this._setSelectedPreviewAttributes("area"), 
        this._renderHandler(), this._showText && this.renderText();
    }
    renderDragMask() {
        const {dragMaskStyle: dragMaskStyle} = this.attribute, {position: position, width: width, height: height} = this._getLayoutAttrFromConfig(), {start: start, end: end} = this._getState();
        return this._isHorizontal ? this._dragMask = this._getContainer().createOrUpdateChild("dragMask", Object.assign({
            x: position.x + start * width,
            y: position.y,
            width: (end - start) * width,
            height: height
        }, dragMaskStyle), "rect") : this._dragMask = this._getContainer().createOrUpdateChild("dragMask", Object.assign({
            x: position.x,
            y: position.y + start * height,
            width: width,
            height: (end - start) * height
        }, dragMaskStyle), "rect"), {
            start: start,
            end: end
        };
    }
    _renderBackground() {
        var _a;
        const {backgroundStyle: backgroundStyle, brushSelect: brushSelect, zoomLock: zoomLock} = this.attribute, {position: position, width: width, height: height} = this._getLayoutAttrFromConfig(), group = this._getContainer();
        this._background = group.createOrUpdateChild("background", Object.assign(Object.assign({
            x: position.x,
            y: position.y,
            width: width,
            height: height,
            cursor: brushSelect ? "crosshair" : "auto"
        }, backgroundStyle), {
            pickable: !zoomLock && (null === (_a = backgroundStyle.pickable) || void 0 === _a || _a)
        }), "rect");
    }
    _renderHandler() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2;
        const {orient: orient, middleHandlerStyle: middleHandlerStyle = {}, startHandlerStyle: startHandlerStyle = {}, endHandlerStyle: endHandlerStyle = {}, zoomLock: zoomLock} = this.attribute, {start: start, end: end} = this._getState(), {position: position, width: width, height: height} = this._getLayoutAttrFromConfig(), startHandlerMinSize = null !== (_a = startHandlerStyle.triggerMinSize) && void 0 !== _a ? _a : 40, endHandlerMinSize = null !== (_b = endHandlerStyle.triggerMinSize) && void 0 !== _b ? _b : 40, group = this._getContainer();
        if (this._isHorizontal) {
            if (middleHandlerStyle.visible) {
                const middleHandlerBackgroundSize = (null === (_c = middleHandlerStyle.background) || void 0 === _c ? void 0 : _c.size) || 10;
                this._middleHandlerRect = group.createOrUpdateChild("middleHandlerRect", Object.assign(Object.assign({
                    x: position.x + start * width,
                    y: position.y - middleHandlerBackgroundSize,
                    width: (end - start) * width,
                    height: middleHandlerBackgroundSize
                }, null === (_d = middleHandlerStyle.background) || void 0 === _d ? void 0 : _d.style), {
                    pickable: !zoomLock && (null === (_g = null === (_f = null === (_e = middleHandlerStyle.background) || void 0 === _e ? void 0 : _e.style) || void 0 === _f ? void 0 : _f.pickable) || void 0 === _g || _g)
                }), "rect"), this._middleHandlerSymbol = group.createOrUpdateChild("middleHandlerSymbol", Object.assign(Object.assign({
                    x: position.x + (start + end) / 2 * width,
                    y: position.y - middleHandlerBackgroundSize / 2,
                    strokeBoundsBuffer: 0,
                    angle: 0,
                    symbolType: null !== (_j = null === (_h = middleHandlerStyle.icon) || void 0 === _h ? void 0 : _h.symbolType) && void 0 !== _j ? _j : "square"
                }, middleHandlerStyle.icon), {
                    pickable: !zoomLock && (null === (_k = middleHandlerStyle.icon.pickable) || void 0 === _k || _k)
                }), "symbol");
            }
            this._startHandler = group.createOrUpdateChild("startHandler", Object.assign(Object.assign(Object.assign({
                x: position.x + start * width,
                y: position.y + height / 2,
                size: height,
                symbolType: null !== (_l = startHandlerStyle.symbolType) && void 0 !== _l ? _l : "square"
            }, config_1.DEFAULT_HANDLER_ATTR_MAP.horizontal), startHandlerStyle), {
                pickable: !zoomLock && (null === (_m = startHandlerStyle.pickable) || void 0 === _m || _m)
            }), "symbol"), this._endHandler = group.createOrUpdateChild("endHandler", Object.assign(Object.assign(Object.assign({
                x: position.x + end * width,
                y: position.y + height / 2,
                size: height,
                symbolType: null !== (_o = endHandlerStyle.symbolType) && void 0 !== _o ? _o : "square"
            }, config_1.DEFAULT_HANDLER_ATTR_MAP.horizontal), endHandlerStyle), {
                pickable: !zoomLock && (null === (_p = endHandlerStyle.pickable) || void 0 === _p || _p)
            }), "symbol");
            const startHandlerWidth = Math.max(this._startHandler.AABBBounds.width(), startHandlerMinSize), startHandlerHeight = Math.max(this._startHandler.AABBBounds.height(), startHandlerMinSize), endHandlerWidth = Math.max(this._endHandler.AABBBounds.width(), endHandlerMinSize), endHandlerHeight = Math.max(this._endHandler.AABBBounds.height(), endHandlerMinSize);
            this._startHandlerMask = group.createOrUpdateChild("startHandlerMask", Object.assign(Object.assign({
                x: position.x + start * width - startHandlerWidth / 2,
                y: position.y + height / 2 - startHandlerHeight / 2,
                width: startHandlerWidth,
                height: startHandlerHeight,
                fill: "white",
                fillOpacity: 0,
                zIndex: 999
            }, config_1.DEFAULT_HANDLER_ATTR_MAP.horizontal), {
                pickable: !zoomLock
            }), "rect"), this._endHandlerMask = group.createOrUpdateChild("endHandlerMask", Object.assign(Object.assign({
                x: position.x + end * width - endHandlerWidth / 2,
                y: position.y + height / 2 - endHandlerHeight / 2,
                width: endHandlerWidth,
                height: endHandlerHeight,
                fill: "white",
                fillOpacity: 0,
                zIndex: 999
            }, config_1.DEFAULT_HANDLER_ATTR_MAP.horizontal), {
                pickable: !zoomLock
            }), "rect");
        } else {
            if (middleHandlerStyle.visible) {
                const middleHandlerBackgroundSize = (null === (_q = middleHandlerStyle.background) || void 0 === _q ? void 0 : _q.size) || 10;
                this._middleHandlerRect = group.createOrUpdateChild("middleHandlerRect", Object.assign(Object.assign({
                    x: "left" === orient ? position.x - middleHandlerBackgroundSize : position.x + width,
                    y: position.y + start * height,
                    width: middleHandlerBackgroundSize,
                    height: (end - start) * height
                }, null === (_r = middleHandlerStyle.background) || void 0 === _r ? void 0 : _r.style), {
                    pickable: !zoomLock && (null === (_u = null === (_t = null === (_s = middleHandlerStyle.background) || void 0 === _s ? void 0 : _s.style) || void 0 === _t ? void 0 : _t.pickable) || void 0 === _u || _u)
                }), "rect"), this._middleHandlerSymbol = group.createOrUpdateChild("middleHandlerSymbol", Object.assign(Object.assign({
                    x: "left" === orient ? position.x - middleHandlerBackgroundSize / 2 : position.x + width + middleHandlerBackgroundSize / 2,
                    y: position.y + (start + end) / 2 * height,
                    angle: Math.PI / 180 * 90,
                    symbolType: null !== (_w = null === (_v = middleHandlerStyle.icon) || void 0 === _v ? void 0 : _v.symbolType) && void 0 !== _w ? _w : "square",
                    strokeBoundsBuffer: 0
                }, middleHandlerStyle.icon), {
                    pickable: !zoomLock && (null === (_y = null === (_x = middleHandlerStyle.icon) || void 0 === _x ? void 0 : _x.pickable) || void 0 === _y || _y)
                }), "symbol");
            }
            this._startHandler = group.createOrUpdateChild("startHandler", Object.assign(Object.assign(Object.assign({
                x: position.x + width / 2,
                y: position.y + start * height,
                size: width,
                symbolType: null !== (_z = startHandlerStyle.symbolType) && void 0 !== _z ? _z : "square"
            }, config_1.DEFAULT_HANDLER_ATTR_MAP.vertical), startHandlerStyle), {
                pickable: !zoomLock && (null === (_0 = startHandlerStyle.pickable) || void 0 === _0 || _0)
            }), "symbol"), this._endHandler = group.createOrUpdateChild("endHandler", Object.assign(Object.assign(Object.assign({
                x: position.x + width / 2,
                y: position.y + end * height,
                size: width,
                symbolType: null !== (_1 = endHandlerStyle.symbolType) && void 0 !== _1 ? _1 : "square"
            }, config_1.DEFAULT_HANDLER_ATTR_MAP.vertical), endHandlerStyle), {
                pickable: !zoomLock && (null === (_2 = endHandlerStyle.pickable) || void 0 === _2 || _2)
            }), "symbol");
            const startHandlerWidth = Math.max(this._startHandler.AABBBounds.width(), startHandlerMinSize), startHandlerHeight = Math.max(this._startHandler.AABBBounds.height(), startHandlerMinSize), endHandlerWidth = Math.max(this._endHandler.AABBBounds.width(), endHandlerMinSize), endHandlerHeight = Math.max(this._endHandler.AABBBounds.height(), endHandlerMinSize);
            this._startHandlerMask = group.createOrUpdateChild("startHandlerMask", Object.assign(Object.assign({
                x: position.x + width / 2 + startHandlerWidth / 2,
                y: position.y + start * height - startHandlerHeight / 2,
                width: endHandlerHeight,
                height: endHandlerWidth,
                fill: "white",
                fillOpacity: 0,
                zIndex: 999
            }, config_1.DEFAULT_HANDLER_ATTR_MAP.vertical), {
                pickable: !zoomLock
            }), "rect"), this._endHandlerMask = group.createOrUpdateChild("endHandlerMask", Object.assign(Object.assign({
                x: position.x + width / 2 + endHandlerWidth / 2,
                y: position.y + end * height - endHandlerHeight / 2,
                width: endHandlerHeight,
                height: endHandlerWidth,
                fill: "white",
                fillOpacity: 0,
                zIndex: 999
            }, config_1.DEFAULT_HANDLER_ATTR_MAP.vertical), {
                pickable: !zoomLock
            }), "rect");
        }
    }
    _renderSelectedBackground() {
        var _a, _b;
        const {selectedBackgroundStyle: selectedBackgroundStyle = {}, selectedBackgroundChartStyle: selectedBackgroundChartStyle = {}, brushSelect: brushSelect, zoomLock: zoomLock} = this.attribute, {start: start, end: end} = this._getState(), {position: position, width: width, height: height} = this._getLayoutAttrFromConfig(), group = this._getContainer();
        this._isHorizontal ? this._selectedBackground = group.createOrUpdateChild("selectedBackground", Object.assign(Object.assign({
            x: position.x + start * width,
            y: position.y,
            width: (end - start) * width,
            height: height,
            cursor: brushSelect ? "crosshair" : "move"
        }, selectedBackgroundStyle), {
            pickable: !zoomLock && (null === (_a = selectedBackgroundChartStyle.pickable) || void 0 === _a || _a)
        }), "rect") : this._selectedBackground = group.createOrUpdateChild("selectedBackground", Object.assign(Object.assign({
            x: position.x,
            y: position.y + start * height,
            width: width,
            height: (end - start) * height,
            cursor: brushSelect ? "crosshair" : "move"
        }, selectedBackgroundStyle), {
            pickable: !zoomLock && (null === (_b = selectedBackgroundStyle.pickable) || void 0 === _b || _b)
        }), "rect");
    }
    _setPreviewAttributes(type, group) {
        this._previewGroup || (this._previewGroup = group.createOrUpdateChild("previewGroup", {
            pickable: !1
        }, "group")), "line" === type ? this._previewLine = this._previewGroup.createOrUpdateChild("previewLine", {}, "line") : this._previewArea = this._previewGroup.createOrUpdateChild("previewArea", {
            curveType: "basis"
        }, "area");
        const {backgroundChartStyle: backgroundChartStyle = {}} = this.attribute;
        "line" === type && this._previewLine.setAttributes(Object.assign({
            points: this._getPreviewLinePoints(),
            curveType: "basis",
            pickable: !1
        }, backgroundChartStyle.line)), "area" === type && this._previewArea.setAttributes(Object.assign({
            points: this._getPreviewAreaPoints(),
            curveType: "basis",
            pickable: !1
        }, backgroundChartStyle.area));
    }
    _setSelectedPreviewClipAttributes(type, group) {
        this._selectedPreviewGroupClip || (this._selectedPreviewGroupClip = group.createOrUpdateChild("selectedPreviewGroupClip", {
            pickable: !1
        }, "group"), this._selectedPreviewGroup = this._selectedPreviewGroupClip.createOrUpdateChild("selectedPreviewGroup", {}, "group"));
        const {start: start, end: end} = this._getState(), {position: position, width: width, height: height} = this._getLayoutAttrFromConfig();
        this._selectedPreviewGroupClip.setAttributes({
            x: this._isHorizontal ? position.x + start * width : position.x,
            y: this._isHorizontal ? position.y : position.y + start * height,
            width: this._isHorizontal ? (end - start) * width : width,
            height: this._isHorizontal ? height : (end - start) * height,
            clip: !0,
            pickable: !1
        }), this._selectedPreviewGroup.setAttributes({
            x: -(this._isHorizontal ? position.x + start * width : position.x),
            y: -(this._isHorizontal ? position.y : position.y + start * height),
            width: this._isHorizontal ? (end - start) * width : width,
            height: this._isHorizontal ? height : (end - start) * height,
            pickable: !1
        });
    }
    _setSelectedPreviewAttributes(type) {
        const {selectedBackgroundChartStyle: selectedBackgroundChartStyle = {}} = this.attribute;
        "line" === type ? this._selectedPreviewLine = this._selectedPreviewGroup.createOrUpdateChild("selectedPreviewLine", {}, "line") : this._selectedPreviewArea = this._selectedPreviewGroup.createOrUpdateChild("selectedPreviewArea", {
            curveType: "basis"
        }, "area"), "line" === type && this._selectedPreviewLine.setAttributes(Object.assign({
            points: this._getPreviewLinePoints(),
            curveType: "basis",
            pickable: !1
        }, selectedBackgroundChartStyle.line)), "area" === type && this._selectedPreviewArea.setAttributes(Object.assign({
            points: this._getPreviewAreaPoints(),
            curveType: "basis",
            pickable: !1
        }, selectedBackgroundChartStyle.area));
    }
    _computeBasePoints(points) {
        const {orient: orient} = this.attribute, key = "bottom" === orient || "top" === orient ? "x" : "y";
        let lastPointSide = Math.sign(points[points.length - 1][key] - points[0][key]);
        0 === lastPointSide && (lastPointSide = 1);
        const {position: position, width: width, height: height} = this._getLayoutAttrFromConfig();
        let basePointStart, basePointEnd;
        return this._isHorizontal ? (basePointStart = [ {
            x: position.x,
            y: position.y + height
        } ], basePointEnd = [ {
            x: position.x + width,
            y: position.y + height
        } ]) : "left" === orient ? (basePointStart = [ {
            x: position.x + width,
            y: position.y
        } ], basePointEnd = [ {
            x: position.x + width,
            y: position.y + height
        } ]) : (basePointStart = [ {
            x: position.x,
            y: position.y + height
        } ], basePointEnd = [ {
            x: position.x,
            y: position.y
        } ]), Math.sign(basePointEnd[0][key] - basePointStart[0][key]) !== lastPointSide ? {
            basePointStart: basePointEnd,
            basePointEnd: basePointStart
        } : {
            basePointStart: basePointStart,
            basePointEnd: basePointEnd
        };
    }
    _simplifyPoints(points) {
        var _a;
        if (points.length > 1e4) {
            const tolerance = null !== (_a = this.attribute.tolerance) && void 0 !== _a ? _a : this._previewData.length / 1e4;
            return (0, vrender_core_1.flatten_simplify)(points, tolerance, !1);
        }
        return points;
    }
    _getPreviewLinePoints() {
        let previewPoints = this._previewData.map((d => ({
            x: this._previewPointsX && this._previewPointsX(d),
            y: this._previewPointsY && this._previewPointsY(d)
        })));
        if (0 === previewPoints.length) return previewPoints;
        previewPoints = this._simplifyPoints(previewPoints);
        const {basePointStart: basePointStart, basePointEnd: basePointEnd} = this._computeBasePoints(previewPoints);
        return basePointStart.concat(previewPoints).concat(basePointEnd);
    }
    _getPreviewAreaPoints() {
        let previewPoints = this._previewData.map((d => ({
            x: this._previewPointsX && this._previewPointsX(d),
            y: this._previewPointsY && this._previewPointsY(d),
            x1: this._previewPointsX1 && this._previewPointsX1(d),
            y1: this._previewPointsY1 && this._previewPointsY1(d)
        })));
        if (0 === previewPoints.length) return previewPoints;
        previewPoints = this._simplifyPoints(previewPoints);
        const {basePointStart: basePointStart, basePointEnd: basePointEnd} = this._computeBasePoints(previewPoints);
        return basePointStart.concat(previewPoints).concat(basePointEnd);
    }
    renderText() {
        let startTextBounds = null, endTextBounds = null;
        if (this._setTextAttr(startTextBounds, endTextBounds), this._showText) {
            startTextBounds = this._startText.AABBBounds, endTextBounds = this._endText.AABBBounds, 
            this._setTextAttr(startTextBounds, endTextBounds), startTextBounds = this._startText.AABBBounds, 
            endTextBounds = this._endText.AABBBounds;
            const {x1: x1, x2: x2, y1: y1, y2: y2} = startTextBounds, {dx: startTextDx = 0, dy: startTextDy = 0} = this.attribute.startTextStyle;
            if ((new vutils_1.Bounds).set(x1, y1, x2, y2).intersects(endTextBounds)) {
                const direction = "bottom" === this.attribute.orient || "right" === this.attribute.orient ? -1 : 1;
                this._isHorizontal ? this._startText.setAttribute("dy", startTextDy + direction * Math.abs(endTextBounds.y1 - endTextBounds.y2)) : this._startText.setAttribute("dx", startTextDx + direction * Math.abs(endTextBounds.x1 - endTextBounds.x2));
            } else this._isHorizontal ? this._startText.setAttribute("dy", startTextDy) : this._startText.setAttribute("dx", startTextDx);
        }
    }
    _setTextAttr(startTextBounds, endTextBounds) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const {startTextStyle: startTextStyle, endTextStyle: endTextStyle} = this.attribute, {formatMethod: startTextFormat} = startTextStyle, restStartTextStyle = __rest(startTextStyle, [ "formatMethod" ]), {formatMethod: endTextFormat} = endTextStyle, restEndTextStyle = __rest(endTextStyle, [ "formatMethod" ]), {start: start, end: end} = this._getState();
        this._startValue = this._statePointToData(start), this._endValue = this._statePointToData(end);
        const {position: position, width: width, height: height} = this._getLayoutAttrFromConfig(), startTextValue = startTextFormat ? startTextFormat(this._startValue) : this._startValue, endTextValue = endTextFormat ? endTextFormat(this._endValue) : this._endValue, componentBoundsLike = {
            x1: position.x,
            y1: position.y,
            x2: position.x + width,
            y2: position.y + height
        };
        let startTextPosition, endTextPosition, startTextAlignStyle, endTextAlignStyle;
        this._isHorizontal ? (startTextPosition = {
            x: position.x + start * width,
            y: position.y + height / 2
        }, endTextPosition = {
            x: position.x + end * width,
            y: position.y + height / 2
        }, startTextAlignStyle = {
            textAlign: (0, utils_1.isTextOverflow)(componentBoundsLike, startTextBounds, "start", this._isHorizontal) ? "left" : "right",
            textBaseline: null !== (_b = null === (_a = null == restStartTextStyle ? void 0 : restStartTextStyle.textStyle) || void 0 === _a ? void 0 : _a.textBaseline) && void 0 !== _b ? _b : "middle"
        }, endTextAlignStyle = {
            textAlign: (0, utils_1.isTextOverflow)(componentBoundsLike, endTextBounds, "end", this._isHorizontal) ? "right" : "left",
            textBaseline: null !== (_d = null === (_c = null == restEndTextStyle ? void 0 : restEndTextStyle.textStyle) || void 0 === _c ? void 0 : _c.textBaseline) && void 0 !== _d ? _d : "middle"
        }) : (startTextPosition = {
            x: position.x + width / 2,
            y: position.y + start * height
        }, endTextPosition = {
            x: position.x + width / 2,
            y: position.y + end * height
        }, startTextAlignStyle = {
            textAlign: null !== (_f = null === (_e = null == restStartTextStyle ? void 0 : restStartTextStyle.textStyle) || void 0 === _e ? void 0 : _e.textAlign) && void 0 !== _f ? _f : "center",
            textBaseline: (0, utils_1.isTextOverflow)(componentBoundsLike, startTextBounds, "start", this._isHorizontal) ? "top" : "bottom"
        }, endTextAlignStyle = {
            textAlign: null !== (_h = null === (_g = null == restEndTextStyle ? void 0 : restEndTextStyle.textStyle) || void 0 === _g ? void 0 : _g.textAlign) && void 0 !== _h ? _h : "center",
            textBaseline: (0, utils_1.isTextOverflow)(componentBoundsLike, endTextBounds, "end", this._isHorizontal) ? "bottom" : "top"
        }), this._startText = this._maybeAddLabel(this._getContainer(), (0, vutils_1.merge)({}, restStartTextStyle, {
            text: startTextValue,
            x: startTextPosition.x,
            y: startTextPosition.y,
            visible: this._showText,
            pickable: !1,
            childrenPickable: !1,
            textStyle: startTextAlignStyle
        }), "data-zoom-start-text"), this._endText = this._maybeAddLabel(this._getContainer(), (0, 
        vutils_1.merge)({}, restEndTextStyle, {
            text: endTextValue,
            x: endTextPosition.x,
            y: endTextPosition.y,
            visible: this._showText,
            pickable: !1,
            childrenPickable: !1,
            textStyle: endTextAlignStyle
        }), "data-zoom-end-text");
    }
    _maybeAddLabel(container, attributes, name) {
        let labelShape = container.find((node => node.name === name), !0);
        return labelShape ? labelShape.setAttributes(attributes) : (labelShape = new tag_1.Tag(attributes), 
        labelShape.name = name, container.add(labelShape)), labelShape;
    }
}

exports.DataZoomRenderer = DataZoomRenderer;
//# sourceMappingURL=renderer.js.map