(function(root, factory) {
    if ('object' == typeof exports && 'object' == typeof module) module.exports = factory();
    else if ('function' == typeof define && define.amd) define([], factory);
    else if ('object' == typeof exports) exports["VSeed"] = factory();
    else root["VSeed"] = factory();
})(globalThis, ()=>(()=>{
        "use strict";
        var __webpack_require__ = {};
        (()=>{
            __webpack_require__.d = (exports1, definition)=>{
                for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
                    enumerable: true,
                    get: definition[key]
                });
            };
        })();
        (()=>{
            __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
        })();
        (()=>{
            __webpack_require__.r = (exports1)=>{
                if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
                    value: 'Module'
                });
                Object.defineProperty(exports1, '__esModule', {
                    value: true
                });
            };
        })();
        var __webpack_exports__ = {};
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, {
            donutAdvancedPipeline: ()=>donutAdvancedPipeline,
            scatterAdvancedPipeline: ()=>scatterAdvancedPipeline,
            zLineConfig: ()=>zLineConfig,
            zSelectors: ()=>zSelectors,
            FoldXMeasureValue: ()=>FoldXMeasureValue,
            pivotTableAdvancedPipeline: ()=>pivotTableAdvancedPipeline,
            zAnnotationAreaConfig: ()=>zAnnotationAreaConfig,
            selectByPartial: ()=>selectByPartial,
            zCustomTheme: ()=>zCustomTheme,
            intl: ()=>intl,
            roseParallelSpecPipeline: ()=>roseParallelSpecPipeline,
            UpperWhisker: ()=>UpperWhisker,
            zRoseParallel: ()=>zRoseParallel,
            boxplotAdvancedPipeline: ()=>boxplotAdvancedPipeline,
            registerRadar: ()=>registerRadar,
            isRadar: ()=>isRadar,
            isVTable: ()=>isVTable,
            findAllMeasures: ()=>findAllMeasures,
            zFunnelConfig: ()=>zFunnelConfig,
            zUnfoldInfo: ()=>zUnfoldInfo,
            registerColumnPercent: ()=>registerColumnPercent,
            zPivotTableConfig: ()=>zPivotTableConfig,
            registerRose: ()=>registerRose,
            zDimensions: ()=>zDimensions,
            zPieConfig: ()=>zPieConfig,
            zScatterConfig: ()=>zScatterConfig,
            zYLinearAxis: ()=>zYLinearAxis,
            zLabel: ()=>zLabel,
            registerAreaPercent: ()=>registerAreaPercent,
            zAnnotationArea: ()=>zAnnotationArea,
            zDimension: ()=>zDimension,
            FoldPrimaryMeasureValue: ()=>FoldPrimaryMeasureValue,
            donutSpecPipeline: ()=>donutSpecPipeline,
            zSortLegend: ()=>zSortLegend,
            selectorDatum: ()=>selectorDatum,
            registerTable: ()=>registerTable,
            zCrosshairRect: ()=>zCrosshairRect,
            boxplotSpecPipeline: ()=>boxplotSpecPipeline,
            zAnnotationVerticalLineConfig: ()=>zAnnotationVerticalLineConfig,
            zCustomThemeConfig: ()=>zCustomThemeConfig,
            zMeasureEncoding: ()=>zMeasureEncoding,
            MedianMeasureId: ()=>MedianMeasureId,
            BinPercentageMeasureId: ()=>BinPercentageMeasureId,
            AngleEncoding: ()=>AngleEncoding,
            zCrosshairLine: ()=>zCrosshairLine,
            zEcdfRegressionLine: ()=>zEcdfRegressionLine,
            zLegend: ()=>zLegend,
            zMeasure: ()=>zMeasure,
            zBoxMaxWidth: ()=>zBoxMaxWidth,
            zMeasureGroup: ()=>zMeasureGroup,
            zOutlierStyle: ()=>zOutlierStyle,
            zBarStyle: ()=>zBarStyle,
            lineSpecPipeline: ()=>lineSpecPipeline,
            replaceNullToUndefined: ()=>replaceNullToUndefined,
            zBarParallel: ()=>zBarParallel,
            zBarPercent: ()=>zBarPercent,
            LINEAR_AXIS_INNER_OFFSET_TOP: ()=>12,
            zBarPercentConfig: ()=>zBarPercentConfig,
            zDualAxis: ()=>zDualAxis,
            DetailEncoding: ()=>DetailEncoding,
            dualAxisAdvancedPipeline: ()=>dualAxisAdvancedPipeline,
            FoldSecondaryMeasureValue: ()=>FoldSecondaryMeasureValue,
            zXLinearAxis: ()=>zXLinearAxis,
            zRose: ()=>zRose,
            selectByDmension: ()=>selectByDmension,
            isDimensionGroup: ()=>isDimensionGroup,
            BinEndMeasureId: ()=>BinEndMeasureId,
            zHeatmapConfig: ()=>zHeatmapConfig,
            DATUM_HIDE_KEY: ()=>DATUM_HIDE_KEY,
            isAreaPercent: ()=>isAreaPercent,
            zAdvancedVSeed: ()=>zAdvancedVSeed,
            FoldXMeasureId: ()=>FoldXMeasureId,
            Q3MeasureValue: ()=>"__Q3__",
            zColor: ()=>zColor,
            zFoldInfo: ()=>zFoldInfo,
            isPivotTable: ()=>isPivotTable,
            zHistogram: ()=>zHistogram,
            registerArea: ()=>registerArea,
            AXIS_LABEL_SPACE: ()=>8,
            zRoseConfig: ()=>zRoseConfig,
            areaPercentSpecPipeline: ()=>areaPercentSpecPipeline,
            darkTheme: ()=>darkTheme,
            FoldYMeasureId: ()=>FoldYMeasureId,
            selector: ()=>selector_selector,
            zAnnotationHorizontalLine: ()=>zAnnotationHorizontalLine,
            zDualChartType: ()=>zDualChartType,
            ORIGINAL_DATA: ()=>ORIGINAL_DATA,
            columnAdvancedPipeline: ()=>columnAdvancedPipeline,
            FoldMeasureId: ()=>FoldMeasureId,
            MeasureName: ()=>MeasureName,
            lightTheme: ()=>lightTheme,
            zSort: ()=>zSort,
            hasMultipleMeasureInSingleView: ()=>hasMultipleMeasureInSingleView,
            columnParallelSpecPipeline: ()=>columnParallelSpecPipeline,
            roseSpecPipeline: ()=>roseSpecPipeline,
            columnSpecPipeline: ()=>columnSpecPipeline,
            pivotTableSpecPipeline: ()=>pivotTableSpecPipeline,
            BinCountMeasureId: ()=>BinCountMeasureId,
            zYBandAxis: ()=>zYBandAxis,
            registerRoseParallel: ()=>registerRoseParallel,
            zLocale: ()=>zLocale,
            zHeatmap: ()=>zHeatmap,
            isColumnPercent: ()=>isColumnPercent,
            selectByMeasure: ()=>selectByMeasure,
            autoNumFormatter: ()=>autoNumFormatter,
            zConfig: ()=>zConfig,
            zLinearRegressionLine: ()=>zLinearRegressionLine,
            createNumFormatter: ()=>createNumFormatter,
            DEFAULT_PARENT_ID: ()=>DEFAULT_PARENT_ID,
            isPivotChart: ()=>isPivotChart,
            zPolynomialRegressionLine: ()=>zPolynomialRegressionLine,
            zTableConfig: ()=>zTableConfig,
            findFirstMeasure: ()=>findFirstMeasure,
            isValueSelector: ()=>isValueSelector,
            zFunnel: ()=>zFunnel,
            zChartType: ()=>zChartType,
            registerColumnParallel: ()=>registerColumnParallel,
            isDimensionSelector: ()=>isDimensionSelector,
            BAND_AXIS_INNER_OFFSET_IN_PIVOT: ()=>2,
            isBarPercent: ()=>isBarPercent,
            zBar: ()=>zBar,
            zColorLegend: ()=>zColorLegend,
            zColumnConfig: ()=>zColumnConfig,
            zPie: ()=>zPie,
            isTable: ()=>isTable,
            zDonut: ()=>zDonut,
            registerPie: ()=>registerPie,
            ColorIdEncoding: ()=>ColorIdEncoding,
            zColumnPercentConfig: ()=>zColumnPercentConfig,
            roseParallelAdvancedPipeline: ()=>roseParallelAdvancedPipeline,
            zWhiskersConfig: ()=>zWhiskersConfig,
            zBackgroundColor: ()=>zBackgroundColor,
            EncodingEnum: ()=>EncodingEnum,
            zScatterMeasures: ()=>zScatterMeasures,
            foldMeasures: ()=>foldMeasures,
            DUAL_AXIS_LABEL_Z_INDEX: ()=>1002,
            zAnnotationPoint: ()=>zAnnotationPoint,
            zPivotTable: ()=>zPivotTable,
            OutliersMeasureId: ()=>OutliersMeasureId,
            barParallelSpecPipeline: ()=>barParallelSpecPipeline,
            scatterSpecPipeline: ()=>scatterSpecPipeline,
            Separator: ()=>"-",
            barSpecPipeline: ()=>barSpecPipeline,
            measureDepth: ()=>measureDepth,
            registerBar: ()=>registerBar,
            updateSpec: ()=>updateSpec,
            registerHistogram: ()=>registerHistogram,
            Q1MeasureValue: ()=>"__Q1__",
            lineAdvancedPipeline: ()=>lineAdvancedPipeline,
            zRadarConfig: ()=>zRadarConfig,
            zRoseParallelConfig: ()=>zRoseParallelConfig,
            isMeasureSelector: ()=>isMeasureSelector,
            areaPercentAdvancedPipeline: ()=>areaPercentAdvancedPipeline,
            zAreaStyle: ()=>zAreaStyle,
            zKdeRegressionLine: ()=>zKdeRegressionLine,
            zTooltip: ()=>zTooltip,
            zAreaPercentConfig: ()=>zAreaPercentConfig,
            zPivotChartGridConfig: ()=>zPivotChartGridConfig,
            zMarkStyle: ()=>zMarkStyle,
            zPointStyle: ()=>zPointStyle,
            areaAdvancedPipeline: ()=>areaAdvancedPipeline,
            zBoxPlotStyle: ()=>zBoxPlotStyle,
            DUAL_AXIS_CHART_NON_COLUMN_Z_INDEX: ()=>1001,
            zBarMaxWidth: ()=>zBarMaxWidth,
            zColumnParallelConfig: ()=>zColumnParallelConfig,
            BinStartMeasureId: ()=>BinStartMeasureId,
            MeasureEncodingEnum: ()=>MeasureEncodingEnum,
            ColorEncoding: ()=>ColorEncoding,
            zLowessRegressionLine: ()=>zLowessRegressionLine,
            heatmapAdvancedPipeline: ()=>heatmapAdvancedPipeline,
            tableSpecPipeline: ()=>tableSpecPipeline,
            zEncoding: ()=>zEncoding,
            zAreaConfig: ()=>zAreaConfig,
            registerAll: ()=>registerAll,
            dataReshapeByEncoding: ()=>dataReshapeByEncoding,
            dualAxisSpecPipeline: ()=>dualAxisSpecPipeline,
            unfoldDimensions: ()=>unfoldDimensions,
            zArea: ()=>zArea,
            histogramAdvancedPipeline: ()=>histogramAdvancedPipeline,
            registerDarkTheme: ()=>registerDarkTheme,
            ChartTypeEnum: ()=>ChartTypeEnum,
            zDualMeasures: ()=>zDualMeasures,
            FoldMeasureValue: ()=>FoldMeasureValue,
            isVChart: ()=>isVChart,
            zTheme: ()=>zTheme,
            autoFormatter: ()=>autoFormatter,
            zDatum: ()=>zDatum,
            radarSpecPipeline: ()=>radarSpecPipeline,
            zDimensionTree: ()=>zDimensionTree,
            checkVSeed: ()=>checkVSeed,
            zDimensionEncoding: ()=>zDimensionEncoding,
            zBodyCellStyle: ()=>zBodyCellStyle,
            barAdvancedPipeline: ()=>barAdvancedPipeline,
            DUAL_AXIS_CHART_COLUMN_Z_INDEX: ()=>1000,
            isCombination: ()=>isCombination,
            areaSpecPipeline: ()=>areaSpecPipeline,
            zAnnotationPointConfig: ()=>zAnnotationPointConfig,
            registerPivotTable: ()=>registerPivotTable,
            execPipeline: ()=>execPipeline,
            XEncoding: ()=>XEncoding,
            zBoxPlot: ()=>zBoxPlot,
            zLineStyle: ()=>zLineStyle,
            zRegressionLine: ()=>zRegressionLine,
            findMeasureById: ()=>findMeasureById,
            tableAdvancedPipeline: ()=>tableAdvancedPipeline,
            zDimensionGroup: ()=>zDimensionGroup,
            Builder: ()=>Builder,
            zScatterMeasure: ()=>zScatterMeasure,
            selectByValue: ()=>selectByValue,
            MeasureId: ()=>MeasureId,
            registerBarParallel: ()=>registerBarParallel,
            zAnnotationVerticalLine: ()=>zAnnotationVerticalLine,
            zMeasureTree: ()=>zMeasureTree,
            registerDonut: ()=>registerDonut,
            findTreeNodesBy: ()=>findTreeNodesBy,
            zRadar: ()=>zRadar,
            registerBoxPlot: ()=>registerBoxPlot,
            zAnnotation: ()=>zAnnotation,
            zTable: ()=>zTable,
            pieAdvancedPipeline: ()=>pieAdvancedPipeline,
            ANNOTATION_Z_INDEX: ()=>1000,
            zColumnPercent: ()=>zColumnPercent,
            zXBandAxis: ()=>zXBandAxis,
            createFormatter: ()=>createFormatter,
            columnPercentSpecPipeline: ()=>columnPercentSpecPipeline,
            zSelector: ()=>zSelector,
            registerHeatmap: ()=>registerHeatmap,
            zMeasures: ()=>zMeasures,
            zLine: ()=>zLine,
            FoldMeasureName: ()=>FoldMeasureName,
            pieSpecPipeline: ()=>pieSpecPipeline,
            zBarGapInGroup: ()=>zBarGapInGroup,
            barPercentSpecPipeline: ()=>barPercentSpecPipeline,
            zColumnParallel: ()=>zColumnParallel,
            zDatasetReshapeInfo: ()=>zDatasetReshapeInfo,
            zAnalysis: ()=>zAnalysis,
            heatmapSpecPipeline: ()=>heatmapSpecPipeline,
            isPivot: ()=>chatType_isPivot,
            registerColumn: ()=>registerColumn,
            updateAdvanced: ()=>updateAdvanced,
            zDimensionLinkage: ()=>zDimensionLinkage,
            preorderTraverse: ()=>preorderTraverse,
            deleteMeasureTreeByCallback: ()=>deleteMeasureTreeByCallback,
            registerLightTheme: ()=>registerLightTheme,
            isMeasure: ()=>isMeasure,
            FoldYMeasureValue: ()=>FoldYMeasureValue,
            LowerWhisker: ()=>LowerWhisker,
            isMeasureGroup: ()=>isMeasureGroup,
            registerBarPercent: ()=>registerBarPercent,
            funnelSpecPipeline: ()=>funnelSpecPipeline,
            zColumn: ()=>zColumn,
            radarAdvancedPipeline: ()=>radarAdvancedPipeline,
            zBarParallelConfig: ()=>zBarParallelConfig,
            zAnnotationConfig: ()=>zAnnotationConfig,
            registerCustomTheme: ()=>registerCustomTheme,
            zVSeed: ()=>zVSeed,
            registerLine: ()=>registerLine,
            zDualMeasure: ()=>zDualMeasure,
            zLinearColor: ()=>zLinearColor,
            zFunnelTransform: ()=>zFunnelTransform,
            barParallelAdvancedPipeline: ()=>barParallelAdvancedPipeline,
            registerDualAxis: ()=>registerDualAxis,
            zAnnotationHorizontalLineConfig: ()=>zAnnotationHorizontalLineConfig,
            registerFunnel: ()=>registerFunnel,
            histogramSpecPipeline: ()=>histogramSpecPipeline,
            roseAdvancedPipeline: ()=>roseAdvancedPipeline,
            zNumFormat: ()=>zNumFormat,
            zBarConfig: ()=>zBarConfig,
            registerScatter: ()=>registerScatter,
            zAreaPercent: ()=>zAreaPercent,
            isDimension: ()=>isDimension,
            isBarLikeChart: ()=>isBarLikeChart,
            columnParallelAdvancedPipeline: ()=>columnParallelAdvancedPipeline,
            deleteDimensionTreeByCallback: ()=>deleteDimensionTreeByCallback,
            zPieLabel: ()=>zPieLabel,
            zStackCornerRadius: ()=>zStackCornerRadius,
            zDualAxisConfig: ()=>zDualAxisConfig,
            columnPercentAdvancedPipeline: ()=>columnPercentAdvancedPipeline,
            barPercentAdvancedPipeline: ()=>barPercentAdvancedPipeline,
            DimensionEncodingEnum: ()=>DimensionEncodingEnum,
            zDonutConfig: ()=>zDonutConfig,
            funnelAdvancedPipeline: ()=>funnelAdvancedPipeline,
            zDataset: ()=>zDataset,
            zLogisticRegressionLine: ()=>zLogisticRegressionLine,
            createFormatterByMeasure: ()=>createFormatterByMeasure,
            zBoxGapInGroup: ()=>zBoxGapInGroup,
            isPartialDatumSelector: ()=>isPartialDatumSelector,
            isMeasures: ()=>isMeasures,
            YEncoding: ()=>YEncoding,
            zScatter: ()=>zScatter
        });
        const execPipeline = (pipeline, context, initialValue = {})=>{
            const result = pipeline.reduce((prev, cur)=>cur(prev, context), initialValue);
            return result;
        };
        function chunk_JK3VNB42_n(e) {
            return null == e;
        }
        const translateMap = {
            指标名称: {
                'en-US': 'MeasureName',
                'zh-CN': '指标名称'
            },
            指标Id: {
                'en-US': 'MeasureId',
                'zh-CN': '指标Id'
            },
            指标值: {
                'en-US': 'MeasureValue',
                'zh-CN': '指标值'
            },
            异常点: {
                'en-US': 'Outlier',
                'zh-CN': '异常点'
            },
            上边界: {
                'en-US': 'Upper Whisker',
                'zh-CN': '上边界'
            },
            上四分位数: {
                'en-US': 'Q3',
                'zh-CN': '75分位数'
            },
            中位数: {
                'en-US': 'Q2',
                'zh-CN': '中位数'
            },
            下四分位数: {
                'en-US': 'Q1',
                'zh-CN': '25分位数'
            },
            下边界: {
                'en-US': 'Lower Whisker',
                'zh-CN': '下边界'
            }
        };
        class i18n_Intl {
            static instance;
            translateMap = translateMap;
            locale = 'zh-CN';
            canTranslate = (value)=>!!this.translateMap[value];
            i18n = (segments, ...values)=>{
                const text = segments.map((segment, index)=>segment + (values[index] || '')).join('');
                const translatedText = this.translateMap?.[text]?.[this.locale];
                if (chunk_JK3VNB42_n(translatedText)) {
                    console.warn(`i18n ${this.locale} no translate: ${text}`);
                    return text;
                }
                return translatedText;
            };
            setLocale = (locale)=>{
                this.locale = locale;
            };
            getLocale = ()=>this.locale;
            static getInstance() {
                if (!i18n_Intl.instance) i18n_Intl.instance = new i18n_Intl();
                return i18n_Intl.instance;
            }
        }
        const intl = i18n_Intl.getInstance();
        const buildAdvanced = (builder)=>{
            const start = 'undefined' != typeof performance ? performance.now() : Date.now();
            const { chartType } = builder.vseed;
            if (!chartType) throw new Error('chartType is nil in buildAdvanced');
            const pipeline = Builder.getAdvancedPipeline(chartType);
            if (!pipeline) throw new Error(`please invoke registerAll or register ${chartType} before build, no advanced pipeline for chartType ${chartType}`);
            const context = {
                vseed: builder.vseed,
                customTheme: Builder.getThemeMap()
            };
            if (builder.locale) intl.setLocale(builder.locale);
            try {
                const advancedVSeed = execPipeline(pipeline, context);
                builder.advancedVSeed = advancedVSeed;
                return advancedVSeed;
            } catch (e) {
                console.error(e);
                throw new Error(`buildAdvanced error: ${e.message}.\ndetails info in console`);
            } finally{
                const end = 'undefined' != typeof performance ? performance.now() : Date.now();
                builder.performance['buildAdvanced'] = `${(end - start).toFixed(4)}ms`;
            }
        };
        const buildSpec = (builder, advancedVSeed)=>{
            const start = 'undefined' != typeof performance ? performance.now() : Date.now();
            const { chartType } = builder.vseed;
            const pipeline = Builder.getSpecPipeline(chartType);
            if (!pipeline) throw new Error(`please invoke registerAll or register ${chartType} before build, no spec pipeline for chartType ${chartType}`);
            const context = {
                vseed: builder.vseed,
                advancedVSeed
            };
            if (builder.locale) intl.setLocale(builder.locale);
            try {
                const spec = execPipeline(pipeline, context);
                builder.spec = spec;
                return spec;
            } catch (e) {
                console.error(e);
                throw new Error(`buildSpec error: ${e.message}.\ndetails info in console`);
            } finally{
                const end = 'undefined' != typeof performance ? performance.now() : Date.now();
                builder.performance['buildSpec'] = `${(end - start).toFixed(4)}ms`;
            }
        };
        const build = (builder)=>{
            const advancedVSeed = builder.buildAdvanced();
            if (!advancedVSeed) throw new Error('advancedVSeed is null');
            const spec = builder.buildSpec(advancedVSeed);
            return spec;
        };
        var chunk_ANXBDSUI_s = {
            done: !1,
            hasNext: !1
        };
        function C(t, ...o) {
            let n = t, u = o.map((e)=>"lazy" in e ? chunk_3GOCSNFN_y(e) : void 0), p = 0;
            for(; p < o.length;){
                if (void 0 === u[p] || !chunk_3GOCSNFN_B(n)) {
                    let i = o[p];
                    n = i(n), p += 1;
                    continue;
                }
                let r = [];
                for(let i = p; i < o.length; i++){
                    let l = u[i];
                    if (void 0 === l || (r.push(l), l.isSingle)) break;
                }
                let a = [];
                for (let i of n)if (chunk_3GOCSNFN_f(i, a, r)) break;
                let { isSingle: s } = r.at(-1);
                n = s ? a[0] : a, p += r.length;
            }
            return n;
        }
        function chunk_3GOCSNFN_f(t, o, n) {
            if (0 === n.length) return o.push(t), !1;
            let u = t, p = chunk_ANXBDSUI_s, e = !1;
            for (let [r, a] of n.entries()){
                let { index: s, items: i } = a;
                if (i.push(u), p = a(u, s, i), a.index += 1, p.hasNext) {
                    if (p.hasMany ?? !1) {
                        for (let l of p.next)if (chunk_3GOCSNFN_f(l, o, n.slice(r + 1))) return !0;
                        return e;
                    }
                    u = p.next;
                }
                if (!p.hasNext) break;
                p.done && (e = !0);
            }
            return p.hasNext && o.push(u), e;
        }
        function chunk_3GOCSNFN_y(t) {
            let { lazy: o, lazyArgs: n } = t, u = o(...n);
            return Object.assign(u, {
                isSingle: o.single ?? !1,
                index: 0,
                items: []
            });
        }
        function chunk_3GOCSNFN_B(t) {
            return "string" == typeof t || "object" == typeof t && null !== t && Symbol.iterator in t;
        }
        function chunk_LFJW7BOT_y(t, i) {
            let a = i.length - t.length;
            if (1 === a) {
                let [n, ...r] = i;
                return C(n, {
                    lazy: t,
                    lazyArgs: r
                });
            }
            if (0 === a) {
                let n = {
                    lazy: t,
                    lazyArgs: i
                };
                return Object.assign((e)=>C(e, n), n);
            }
            throw new Error("Wrong number of arguments");
        }
        function chunk_QJLMYOTX_i(...e) {
            return chunk_LFJW7BOT_y(chunk_QJLMYOTX_a, e);
        }
        function chunk_QJLMYOTX_a() {
            let e = new Set;
            return (t)=>e.has(t) ? chunk_ANXBDSUI_s : (e.add(t), {
                    done: !1,
                    hasNext: !0,
                    next: t
                });
        }
        const preorderTraverse = (tree, callback, childrenKey = 'children')=>{
            if (!tree || 0 === tree.length) return;
            const stack = [
                ...tree
            ].reverse();
            while(stack.length > 0){
                const node = stack.pop();
                const stop = callback(node);
                if (true === stop) return;
                const children = node[childrenKey];
                if (Array.isArray(children) && children.length > 0) for(let i = children.length - 1; i >= 0; i--){
                    const child = children[i];
                    stack.push(child);
                }
            }
        };
        const findTreeNodesBy = (nodes = [], callback, childrenKey = 'children')=>{
            if (!nodes) return [];
            const result = [];
            preorderTraverse(nodes, (node)=>{
                if (!(childrenKey in node)) {
                    if (callback(node)) result.push(node);
                }
                return false;
            });
            return result;
        };
        const measureDepth = (measures = [])=>{
            if (!measures) return 0;
            let depth = 1;
            preorderTraverse(measures, (node)=>{
                if ('children' in node) depth = Math.max(depth, 1 + measureDepth(node.children));
                return false;
            });
            return depth;
        };
        const isMeasureTreeWithChildren = (measures)=>{
            if (!measures) return false;
            return measures.some((measure)=>'children' in measure);
        };
        const isMeasureTreeWithParentId = (measures)=>{
            if (!measures) return false;
            return measures.some((measure)=>'parentId' in measure);
        };
        const normalizeMeasureTree = (measures)=>{
            const createEmptyMeasureGroup = ()=>({
                    id: 'group',
                    alias: '',
                    children: []
                });
            let currentGroup = createEmptyMeasureGroup();
            const measureGroups = [];
            for (const measure of measures)if ('children' in measure) {
                if (currentGroup.children?.length) {
                    currentGroup.id = [
                        currentGroup.id,
                        ...currentGroup.children.map((item)=>item.id)
                    ].join('-');
                    currentGroup.alias = currentGroup.children.map((item)=>item.alias).join('-');
                    measureGroups.push(currentGroup);
                    currentGroup = createEmptyMeasureGroup();
                }
                measureGroups.push(measure);
            } else currentGroup.children?.push(measure);
            if (currentGroup.children?.length) {
                currentGroup.id = [
                    currentGroup.id,
                    ...currentGroup.children.map((item)=>item.id)
                ].join('-');
                currentGroup.alias = currentGroup.children.map((item)=>item.alias).join('-');
                measureGroups.push(currentGroup);
                currentGroup = createEmptyMeasureGroup();
            }
            return measureGroups;
        };
        const DEFAULT_PARENT_ID = '__DefaultParentId__';
        const ChartTypeEnum = {
            Table: 'table',
            PivotTable: 'pivotTable',
            Line: 'line',
            Column: 'column',
            ColumnPercent: 'columnPercent',
            ColumnParallel: 'columnParallel',
            Bar: 'bar',
            BarPercent: 'barPercent',
            BarParallel: 'barParallel',
            Area: 'area',
            AreaPercent: 'areaPercent',
            DualAxis: 'dualAxis',
            Scatter: 'scatter',
            Rose: 'rose',
            RoseParallel: 'roseParallel',
            Pie: 'pie',
            Donut: 'donut',
            Radar: 'radar',
            Funnel: 'funnel',
            Heatmap: 'heatmap',
            Boxplot: 'boxPlot',
            Histogram: 'histogram'
        };
        const DATUM_HIDE_KEY = '__VSEED_HideItem__';
        const isTable = (vseed)=>vseed.chartType === ChartTypeEnum.Table;
        const isPivotTable = (vseed)=>vseed.chartType === ChartTypeEnum.PivotTable;
        const isRadar = (vseed)=>vseed.chartType === ChartTypeEnum.Radar;
        const isAreaPercent = (vseed)=>vseed.chartType === ChartTypeEnum.AreaPercent;
        const isColumnPercent = (vseed)=>vseed.chartType === ChartTypeEnum.ColumnPercent;
        const isBarPercent = (vseed)=>vseed.chartType === ChartTypeEnum.BarPercent;
        const isBarLikeChart = (vseed)=>vseed.chartType === ChartTypeEnum.Bar || vseed.chartType === ChartTypeEnum.BarPercent || vseed.chartType === ChartTypeEnum.BarParallel;
        const isVTable = (vseed)=>[
                'table',
                'pivotTable'
            ].includes(vseed.chartType);
        const isVChart = (vseed)=>!isVTable(vseed);
        const isPivotChart = (vseed)=>{
            if (isVTable(vseed)) return false;
            if (chatType_isPivot(vseed)) return true;
            return isCombination(vseed);
        };
        const chatType_isPivot = (vseed)=>{
            const { dimensions = [] } = vseed;
            return dimensions && dimensions.some((dimension)=>'row' === dimension.encoding || 'column' === dimension.encoding);
        };
        const isCombination = (vseed)=>{
            if (isMeasureTreeWithParentId(vseed.measures)) {
                const parentIds = vseed.measures?.map((measure)=>measure.parentId || DEFAULT_PARENT_ID);
                return parentIds && chunk_QJLMYOTX_i(parentIds).length > 1;
            }
            if ('dualAxis' === vseed.chartType || 'scatter' === vseed.chartType) {
                if ('scatter' === vseed.chartType) {
                    if (isMeasureTreeWithChildren(vseed.measures)) {
                        const depth = measureDepth(vseed.measures);
                        return 3 === depth;
                    }
                    if (vseed.scatterMeasures && vseed.scatterMeasures.length > 1) return true;
                    return false;
                }
                if ('dualAxis' === vseed.chartType) {
                    if (isMeasureTreeWithChildren(vseed.measures)) {
                        const depth = measureDepth(vseed.measures);
                        return 3 === depth;
                    }
                    if (vseed.dualMeasures && vseed.dualMeasures.length > 1) return true;
                }
                return false;
            }
            const { measures = [] } = vseed;
            const hasMeasureGroup = measures && measures.some((measure)=>measure && measure.children);
            return hasMeasureGroup;
        };
        const getColorItems = (builder)=>{
            const advancedVSeed = builder.advancedVSeed;
            if (!advancedVSeed || isTable(builder.vseed) || isPivotTable(builder.vseed)) return [];
            const { datasetReshapeInfo } = advancedVSeed;
            const colorItems = chunk_QJLMYOTX_i(datasetReshapeInfo.flatMap((d)=>d.unfoldInfo.colorItems));
            const colorIdMap = datasetReshapeInfo.reduce((prev, cur)=>({
                    ...prev,
                    ...cur.unfoldInfo.colorIdMap
                }), {});
            return colorItems.map((d)=>({
                    id: d,
                    alias: colorIdMap[d]?.alias
                }));
        };
        const getColorIdMap = (builder)=>{
            const advancedVSeed = builder.advancedVSeed;
            if (!advancedVSeed || isTable(builder.vseed) || isPivotTable(builder.vseed)) return {};
            const { datasetReshapeInfo } = advancedVSeed;
            const colorIdMap = datasetReshapeInfo.reduce((prev, cur)=>({
                    ...prev,
                    ...cur.unfoldInfo.colorIdMap
                }), {});
            return colorIdMap;
        };
        class Builder {
            _vseed;
            _advancedVSeed = null;
            _spec = null;
            _performance = {};
            _locale;
            constructor(vseed){
                this._vseed = vseed;
                this._locale = vseed.locale || intl.getLocale();
            }
            get locale() {
                return this._locale;
            }
            build = ()=>build(this);
            buildSpec = (advanced)=>buildSpec(this, advanced);
            buildAdvanced = ()=>buildAdvanced(this);
            getColorItems = ()=>getColorItems(this);
            getColorIdMap = ()=>getColorIdMap(this);
            get vseed() {
                return this._vseed;
            }
            set vseed(value) {
                this._vseed = value;
            }
            get advancedVSeed() {
                return this._advancedVSeed;
            }
            set advancedVSeed(value) {
                this._advancedVSeed = value;
            }
            get spec() {
                return this._spec;
            }
            set spec(value) {
                this._spec = value;
            }
            get performance() {
                return this._performance;
            }
            set performance(value) {
                this._performance = value;
            }
            static getAdvancedPipeline = (chartType)=>{
                const customPipe = Builder._customAdvancedPipe[chartType];
                const pipeline = Builder._advancedPipelineMap[chartType];
                if (customPipe) pipeline.push(customPipe);
                return pipeline;
            };
            static getSpecPipeline = (chartType)=>{
                const customPipe = Builder._customSpecPipe[chartType];
                const pipeline = Builder._specPipelineMap[chartType];
                if (customPipe) pipeline.push(customPipe);
                return pipeline;
            };
            static getTheme = (themeKey)=>Builder._themeMap[themeKey || 'light'];
            static getThemeMap = ()=>Builder._themeMap;
            static from = (vseed)=>new Builder(vseed);
            static _advancedPipelineMap = {};
            static _specPipelineMap = {};
            static _customAdvancedPipe = {};
            static _customSpecPipe = {};
            static _themeMap = {};
        }
        function chunk_VCYTMP4D_n(e) {
            return void 0 === e ? !0 : "string" == typeof e || Array.isArray(e) ? 0 === e.length : 0 === Object.keys(e).length;
        }
        const checkVSeed = (vseed)=>{
            const { chartType, dataset, dimensions, measures } = vseed;
            if (!chartType) throw new Error('chartType is required');
            if (!dataset || chunk_VCYTMP4D_n(dataset)) throw new Error('dataset is required, and must be an array');
            if (dimensions && !Array.isArray(dimensions)) throw new Error('dimensions must be an array');
            if (measures && !Array.isArray(measures)) throw new Error('measures must be an array');
        };
        const initAdvancedVSeed = (advancedVSeed, context)=>{
            const { vseed } = context;
            const { chartType, locale } = vseed;
            checkVSeed(vseed);
            return {
                ...advancedVSeed,
                chartType,
                locale: locale || 'zh-CN'
            };
        };
        function chunk_D6FCK2GA_u(o, n, a) {
            let t = (r)=>o(r, ...n);
            return void 0 === a ? t : Object.assign(t, {
                lazy: a,
                lazyArgs: n
            });
        }
        function chunk_WIMGWYZL_u(r, n, o) {
            let a = r.length - n.length;
            if (0 === a) return r(...n);
            if (1 === a) return chunk_D6FCK2GA_u(r, n, o);
            throw new Error("Wrong number of arguments");
        }
        function chunk_BCBB46UE_d(...n) {
            return chunk_WIMGWYZL_u(chunk_BCBB46UE_u, n);
        }
        function chunk_BCBB46UE_u(n, o = [], t = []) {
            if ("function" == typeof n) return n;
            if ("object" != typeof n || null === n) return structuredClone(n);
            let r = Object.getPrototypeOf(n);
            if (!Array.isArray(n) && null !== r && r !== Object.prototype) return structuredClone(n);
            let e = o.indexOf(n);
            return -1 !== e ? t[e] : (o.push(n), Array.isArray(n) ? chunk_BCBB46UE_p(n, o, t) : chunk_BCBB46UE_i(n, o, t));
        }
        function chunk_BCBB46UE_i(n, o, t) {
            let r = {};
            t.push(r);
            for (let [e, c] of Object.entries(n))r[e] = chunk_BCBB46UE_u(c, o, t);
            return r;
        }
        function chunk_BCBB46UE_p(n, o, t) {
            let r = [];
            t.push(r);
            for (let [e, c] of n.entries())r[e] = chunk_BCBB46UE_u(c, o, t);
            return r;
        }
        const isMeasure = (measure)=>!('children' in measure);
        const isMeasureGroup = (measure)=>'children' in measure;
        const isMeasures = (measures)=>measures.every(isMeasure);
        const defaultMeasures_defaultMeasures = (advancedVSeed, context)=>{
            const { vseed } = context;
            const { measures, dataset } = vseed;
            if (measures && measures.length > 0) {
                const clonedMeasures = chunk_BCBB46UE_d(measures);
                preorderTraverse(clonedMeasures, (node)=>{
                    if (isMeasure(node)) node.alias = node.alias || node.id;
                    return false;
                });
                return {
                    ...advancedVSeed,
                    measures: clonedMeasures
                };
            }
            const top100dataset = dataset.slice(0, 100);
            const sample = top100dataset.reduce((prev, cur)=>({
                    ...prev,
                    ...cur
                }), {});
            const defaultMeasures = Object.keys(sample).filter((key)=>top100dataset.some((item)=>'number' == typeof item[key]) && ![
                    '',
                    null,
                    void 0
                ].includes(key)).map((measure)=>({
                    id: measure,
                    alias: measure
                }));
            return {
                ...advancedVSeed,
                measures: defaultMeasures
            };
        };
        const isDimension = (dimension)=>!('children' in dimension);
        const isDimensionGroup = (dimension)=>'children' in dimension;
        const findMeasureById = (measures = [], id)=>{
            if (!measures) return;
            let result;
            preorderTraverse(measures, (node)=>{
                if (!('children' in node)) {
                    if (node.id === id) {
                        result = node;
                        return true;
                    }
                }
                return false;
            });
            return result;
        };
        const findFirstMeasure = (measures = [])=>{
            if (!measures) return;
            let result;
            preorderTraverse(measures, (node)=>{
                if (!('children' in node)) {
                    result = node;
                    return true;
                }
                return false;
            });
            return result;
        };
        const findAllMeasures = (measures = [])=>{
            if (!measures) return [];
            const result = [];
            preorderTraverse(measures, (node)=>{
                if (!('children' in node)) result.push(node);
                return false;
            });
            return result;
        };
        const hasMultipleMeasureInSingleView = (measures = [])=>{
            if (measures.every((m)=>!('children' in m))) return measures.length > 1;
            let found = false;
            preorderTraverse(measures, (node)=>{
                if (node.children && node.children.length > 1) {
                    found = true;
                    return true;
                }
                return false;
            });
            return found;
        };
        const defaultDimensions = (advancedVSeed, context)=>{
            const result = {
                ...advancedVSeed
            };
            const { vseed } = context;
            const { dimensions, dataset } = vseed;
            if (dimensions && dimensions.length > 0) {
                const clonedDimensions = chunk_BCBB46UE_d(dimensions);
                preorderTraverse(clonedDimensions, (node)=>{
                    if (isDimension(node)) node.alias = node.alias || node.id;
                    return false;
                });
                return {
                    ...advancedVSeed,
                    dimensions: clonedDimensions
                };
            }
            const measures = findAllMeasures(advancedVSeed.measures);
            const top100dataset = dataset.slice(0, 100);
            const sample = top100dataset.reduce((prev, cur)=>({
                    ...prev,
                    ...cur
                }), {});
            const newDimensions = Object.keys(sample).filter((key)=>top100dataset.some((item)=>'string' == typeof item[key]) && ![
                    '',
                    null,
                    void 0
                ].includes(key) && !measures.some((measure)=>measure.id === key)).map((dim)=>({
                    id: dim,
                    alias: dim
                }));
            return {
                ...result,
                dimensions: newDimensions
            };
        };
        function chunk_2T7K3PFL_i(...e) {
            return chunk_WIMGWYZL_u(chunk_2T7K3PFL_o, e);
        }
        function chunk_2T7K3PFL_o(e, s) {
            let r = {};
            for (let n of s)n in e && (r[n] = e[n]);
            return r;
        }
        function chunk_BZNENX2T_r(o) {
            if ("object" != typeof o || null === o) return !1;
            let e = Object.getPrototypeOf(o);
            return null === e || e === Object.prototype;
        }
        function chunk_3ZJAREUD_i(...e) {
            return chunk_WIMGWYZL_u(chunk_3ZJAREUD_o, e);
        }
        function chunk_3ZJAREUD_o(e, r) {
            let a = {};
            for (let [n, u] of Object.entries(e)){
                let l = r(u, n, e);
                a[n] = l;
            }
            return a;
        }
        const replaceNullToUndefined = (obj)=>{
            if (null === obj) return;
            if (Array.isArray(obj)) return obj.map(replaceNullToUndefined);
            if (chunk_BZNENX2T_r(obj)) return C(obj, chunk_3ZJAREUD_i((value)=>replaceNullToUndefined(value)));
            return obj;
        };
        const cellStyle_cellStyle = (advancedVSeed, context)=>{
            const { vseed } = context;
            const pickedCellStyle = chunk_2T7K3PFL_i(vseed, [
                'bodyCellStyle'
            ]);
            const style = replaceNullToUndefined(pickedCellStyle);
            return {
                ...advancedVSeed,
                cellStyle: style
            };
        };
        const records_records = (advancedVSeed, context)=>{
            const { vseed } = context;
            const { dataset } = vseed;
            return {
                ...advancedVSeed,
                dataset
            };
        };
        const tableConfig_tableConfig = (advancedVSeed, context)=>{
            const { vseed } = context;
            const { chartType } = vseed;
            const result = {
                ...advancedVSeed
            };
            const config = chunk_2T7K3PFL_i(vseed, [
                'backgroundColor',
                'bodyFontSize',
                'bodyFontColor',
                'bodyBackgroundColor',
                'headerFontSize',
                'headerFontColor',
                'headerBackgroundColor',
                'hoverHeaderBackgroundColor',
                'hoverHeaderInlineBackgroundColor',
                'selectedBorderColor',
                'selectedBackgroundColor'
            ]);
            result.config = {
                ...result.config || {},
                [chartType]: {
                    ...config
                }
            };
            return result;
        };
        function D(...e) {
            return chunk_WIMGWYZL_u(chunk_PDQFB3TV_s, e);
        }
        function chunk_PDQFB3TV_s(e, t) {
            let r = {
                ...e,
                ...t
            };
            for(let n in t){
                if (!(n in e)) continue;
                let { [n]: i } = e;
                if (!chunk_BZNENX2T_r(i)) continue;
                let { [n]: c } = t;
                chunk_BZNENX2T_r(c) && (r[n] = chunk_PDQFB3TV_s(i, c));
            }
            return r;
        }
        function chunk_SFZGYJFI_t(r) {
            return "string" == typeof r;
        }
        function chunk_6GTAPB47_e(r) {
            return "number" == typeof r && !Number.isNaN(r);
        }
        function chunk_NMC53JVB_o(e) {
            return "object" == typeof e && null !== e;
        }
        function chunk_5S4PYKVY_t(...e) {
            return chunk_WIMGWYZL_u(chunk_5S4PYKVY_u, e);
        }
        var chunk_5S4PYKVY_u = (e, o)=>({
                ...e,
                ...o
            });
        const theme_theme = (advancedVSeed, context)=>{
            const { customTheme, vseed } = context;
            const { theme = 'light', chartType } = vseed;
            const result = {
                ...advancedVSeed
            };
            if (!customTheme || !customTheme[theme]) return result;
            const chartConfigTheme = customTheme?.[theme].config?.[chartType];
            if (chartConfigTheme) {
                const chartConfig = result.config?.[chartType] || {};
                const mergedConfig = D(chartConfigTheme, chunk_BCBB46UE_d(chartConfig));
                for(const _k in mergedConfig){
                    const key = _k;
                    if (Array.isArray(mergedConfig[key])) mergedConfig[key] = mergeArray(mergedConfig[key], chartConfigTheme[key]);
                }
                result.config = {
                    [chartType]: mergedConfig
                };
            }
            const chartCustomTheme = customTheme?.[theme]?.config?.[chartType];
            result.customTheme = {
                config: {
                    [chartType]: chartCustomTheme
                }
            };
            return result;
        };
        const mergeArray = (arr, themeItem)=>{
            if (chunk_JK3VNB42_n(themeItem) || chunk_SFZGYJFI_t(themeItem) || chunk_6GTAPB47_e(themeItem)) return arr;
            if (!Array.isArray(arr)) return arr;
            if (arr.some((d)=>!chunk_NMC53JVB_o(d))) return arr;
            return arr.map((item)=>chunk_5S4PYKVY_t(themeItem, item));
        };
        const tableAdvancedPipeline = [
            initAdvancedVSeed,
            defaultMeasures_defaultMeasures,
            defaultDimensions,
            cellStyle_cellStyle,
            records_records,
            tableConfig_tableConfig,
            theme_theme
        ];
        const initTable = (spec, context)=>{
            const { advancedVSeed } = context;
            const { dataset } = advancedVSeed;
            const { config } = advancedVSeed;
            const { backgroundColor = 'transparent' } = config.table || {};
            return {
                ...spec,
                records: dataset,
                widthMode: 'standard',
                defaultHeaderColWidth: 'auto',
                heightMode: 'autoHeight',
                autoWrapText: true,
                columnResizeMode: 'all',
                showHeader: true,
                tooltip: {
                    isShowOverflowTextTooltip: true
                },
                animationAppear: {
                    duration: 300,
                    delay: 250,
                    type: 'one-by-one',
                    direction: 'row'
                },
                hover: {
                    highlightMode: 'row'
                },
                theme: {
                    cellInnerBorder: false,
                    underlayBackgroundColor: backgroundColor
                }
            };
        };
        const dimensionTreeToColumns = (spec, context)=>{
            const { advancedVSeed } = context;
            const dimensions = advancedVSeed.dimensions;
            const result = {
                ...spec
            };
            const eachNode = (node)=>{
                if (isMeasure(node)) return {
                    width: 'auto'
                };
                return {};
            };
            const columns = treeTreeToColumns(dimensions, eachNode);
            return {
                ...result,
                columns: [
                    ...result.columns || [],
                    ...columns
                ]
            };
        };
        const treeTreeToColumns = (tree, callback)=>{
            const result = tree.map((item)=>{
                if ('children' in item && Array.isArray(item.children)) {
                    const groupNode = item;
                    const field = groupNode.id;
                    const title = groupNode.alias ?? groupNode.id;
                    const props = callback?.(groupNode) || {};
                    return {
                        field,
                        title,
                        columns: treeTreeToColumns(item.children, callback),
                        ...props
                    };
                }
                {
                    const field = item.id;
                    const title = item.alias ?? item.id;
                    const props = callback?.(item) || {};
                    return {
                        field,
                        title,
                        ...props
                    };
                }
            });
            return result || [];
        };
        const createNumFormatter = (format, locale = intl.getLocale())=>{
            const { type = 'number', ratio = 1, thousandSeparator = true, prefix = '', suffix = '', symbol = '', fractionDigits = 2, significantDigits, roundingMode = 'halfExpand', roundingPriority = 'auto' } = format || {};
            const numFormatterOptions = {
                style: 'decimal',
                notation: 'scientific' === type ? 'scientific' : 'standard',
                roundingMode,
                roundingPriority
            };
            if (chunk_6GTAPB47_e(fractionDigits)) {
                if (fractionDigits >= 0) {
                    numFormatterOptions.minimumFractionDigits = fractionDigits;
                    numFormatterOptions.maximumFractionDigits = fractionDigits;
                }
            }
            if (chunk_6GTAPB47_e(significantDigits) && significantDigits > 0) {
                if (significantDigits > 0) {
                    numFormatterOptions.minimumSignificantDigits = significantDigits;
                    numFormatterOptions.maximumSignificantDigits = significantDigits;
                }
            }
            const numFormatter = new Intl.NumberFormat(locale, {
                ...numFormatterOptions,
                useGrouping: thousandSeparator
            });
            return (value)=>{
                let num = Number(value);
                let typeSymbol = '';
                if (Number.isNaN(num)) return String(value);
                if ('percent' === type) {
                    num *= 100;
                    typeSymbol = '%';
                } else if ('permille' === type) {
                    num *= 1000;
                    typeSymbol = '‰';
                } else if ('number' === type) num /= ratio || 1;
                let numStr = numFormatter.format(num);
                if (thousandSeparator) {
                    const parts = numStr.split('.');
                    parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ',');
                    numStr = parts.join('.');
                }
                const validSymbol = symbol ?? '';
                return `${prefix}${numStr}${typeSymbol}${validSymbol}${suffix}`;
            };
        };
        const autoNumFormatter = (value, locale = intl.getLocale())=>{
            if (null == value) return String(value);
            const num = Number(value);
            if (Number.isNaN(num)) return String(value);
            const numFormatterOptions = {
                style: 'decimal',
                notation: 'compact',
                useGrouping: true
            };
            numFormatterOptions.minimumFractionDigits = 0;
            numFormatterOptions.maximumFractionDigits = 2;
            const numFormatter = new Intl.NumberFormat(locale, {
                ...numFormatterOptions
            });
            return numFormatter.format(Number(value));
        };
        const createFormatter = (format, locale)=>createNumFormatter(format, locale);
        const autoFormatter = (value, locale = intl.getLocale())=>autoNumFormatter(value, locale);
        const createFormatterByMeasure = (measure)=>{
            if (!measure) return (v)=>String(v);
            const { numFormat, format, autoFormat } = measure;
            const formatterFormat = numFormat || format || {};
            if (true === autoFormat) return autoFormatter;
            if (chunk_JK3VNB42_n(autoFormat) && chunk_VCYTMP4D_n(formatterFormat)) return autoFormatter;
            if (!chunk_VCYTMP4D_n(formatterFormat)) return createFormatter(formatterFormat);
            return (v)=>String(v);
        };
        const measureTreeToColumns = (spec, context)=>{
            const { advancedVSeed } = context;
            const measures = advancedVSeed.measures;
            const result = {
                ...spec
            };
            const eachNode = (node)=>{
                if (isMeasure(node)) return {
                    width: 'auto',
                    fieldFormat: fieldFormat(node)
                };
                return {};
            };
            const columns = measuresToColumns_treeTreeToColumns(measures, eachNode);
            return {
                ...result,
                columns: [
                    ...result.columns || [],
                    ...columns
                ]
            };
        };
        const fieldFormat = (node)=>{
            const formatter = createFormatterByMeasure(node);
            return (datum)=>{
                const { id } = node;
                const value = datum[id];
                return formatter(value);
            };
        };
        const measuresToColumns_treeTreeToColumns = (tree, callback)=>{
            const result = tree.map((item)=>{
                if ('children' in item && Array.isArray(item.children)) {
                    const groupNode = item;
                    const field = groupNode.id;
                    const title = groupNode.alias ?? groupNode.id;
                    const props = callback?.(groupNode) || {};
                    return {
                        field,
                        title,
                        columns: measuresToColumns_treeTreeToColumns(item.children, callback),
                        ...props
                    };
                }
                {
                    const field = item.id;
                    const title = item.alias ?? item.id;
                    const props = callback?.(item) || {};
                    return {
                        field,
                        title,
                        ...props
                    };
                }
            });
            return result || [];
        };
        const bodyStyle = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed } = context;
            const { chartType, config } = advancedVSeed;
            const themeConfig = config?.[chartType];
            if (!result.theme || !themeConfig) return result;
            const borderColor = themeConfig.borderColor || 'rgb(224, 224, 224)';
            const backgroundColor = themeConfig.bodyBackgroundColor || '#fff';
            const fontColor = themeConfig.bodyFontColor || '#1B1F23';
            const fontSize = themeConfig.bodyFontSize || 12;
            const hoverCellBgColor = themeConfig.hoverBodyBackgroundColor || '#bedaff';
            const hoverInlineColor = themeConfig.hoverBodyInlineBackgroundColor || '#bedaff';
            if (!result.theme) result.theme = {};
            result.theme.bodyStyle = {
                borderColor: borderColor,
                borderLineWidth: 1,
                padding: [
                    8,
                    12,
                    8,
                    12
                ],
                textAlign: 'right',
                hover: {
                    cellBgColor: hoverCellBgColor,
                    inlineRowBgColor: hoverInlineColor,
                    inlineColumnBgColor: hoverInlineColor
                },
                color: fontColor,
                fontSize: fontSize,
                fontStyle: 'normal',
                fontWeight: 'normal',
                fontVariant: 'normal',
                bgColor: backgroundColor,
                lineHeight: 1.5 * fontSize
            };
            return result;
        };
        const headerStyle = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed } = context;
            const { config, chartType } = advancedVSeed;
            const themConfig = config?.[chartType];
            if (!result.theme || !themConfig) return result;
            const borderColor = themConfig.borderColor || 'rgb(224, 224, 224)';
            const backgroundColor = themConfig.headerBackgroundColor || '#EEF1F5';
            const fontColor = themConfig.headerFontColor || '#1B1F23';
            const fontSize = themConfig.headerFontSize || 12;
            const hoverCellBgColor = themConfig.hoverHeaderBackgroundColor || '#bedaff';
            const hoverInlineColor = themConfig.hoverHeaderInlineBackgroundColor || '#bedaff';
            result.theme.headerStyle = {
                borderColor: borderColor,
                borderLineWidth: 1,
                padding: [
                    8,
                    12,
                    8,
                    12
                ],
                textAlign: 'center',
                hover: {
                    cellBgColor: hoverCellBgColor,
                    inlineRowBgColor: hoverInlineColor,
                    inlineColumnBgColor: hoverInlineColor
                },
                frameStyle: {
                    borderColor: borderColor,
                    borderLineWidth: [
                        0,
                        0,
                        1,
                        0
                    ]
                },
                fontSize: fontSize,
                fontVariant: 'normal',
                fontStyle: 'normal',
                fontWeight: 'bold',
                color: fontColor,
                bgColor: backgroundColor,
                lineHeight: 1.5 * fontSize
            };
            return result;
        };
        const frameStyle = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed } = context;
            const { config, chartType } = advancedVSeed;
            const themConfig = config?.[chartType];
            if (!result.theme || !themConfig) return result;
            const borderColor = themConfig.borderColor || 'rgb(224, 224, 224)';
            result.theme.frameStyle = {
                borderColor,
                borderLineWidth: 1,
                cornerRadius: 4
            };
            return result;
        };
        const selectionStyle = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed } = context;
            const { config, chartType } = advancedVSeed;
            const themConfig = config?.[chartType];
            if (!result.theme || !themConfig) return result;
            const borderColor = themConfig.selectedBorderColor || 'rgb(224, 224, 224)';
            const backgroundColor = themConfig.selectedBackgroundColor || 'rgb(224, 224, 224, 0.5)';
            result.theme.selectionStyle = {
                cellBorderColor: borderColor,
                cellBorderLineWidth: 2,
                cellBgColor: backgroundColor
            };
            return result;
        };
        const isType = (value, type)=>Object.prototype.toString.call(value) === `[object ${type}]`;
        const common_isType = isType;
        const isArray_isArray = (value)=>Array.isArray ? Array.isArray(value) : common_isType(value, "Array");
        const common_isArray = isArray_isArray;
        const isValid = (value)=>null != value;
        const common_isValid = isValid;
        function array_array(arr) {
            return common_isValid(arr) ? common_isArray(arr) ? arr : [
                arr
            ] : [];
        }
        function chunk_AIG3BDKO_i(...e) {
            return chunk_WIMGWYZL_u(chunk_AIG3BDKO_n, e);
        }
        var chunk_AIG3BDKO_n = (e, r)=>e.length >= r;
        function chunk_KI5X74E2_y(...t) {
            return chunk_WIMGWYZL_u(chunk_KI5X74E2_f, t);
        }
        function chunk_KI5X74E2_f(t, e) {
            if (!chunk_AIG3BDKO_i(e, 1)) return {
                ...t
            };
            if (!chunk_AIG3BDKO_i(e, 2)) {
                let { [e[0]]: r, ...m } = t;
                return m;
            }
            let o = {
                ...t
            };
            for (let r of e)delete o[r];
            return o;
        }
        function nearlyEqual(a, b, epsilon = 1e-8) {
            if (Number.isNaN(a) || Number.isNaN(b)) return false;
            if (a === b) return true;
            const diff = Math.abs(a - b);
            return diff <= epsilon;
        }
        const selector_selector = (vchartDatum, selector, selectorMode = 'And')=>{
            if (!selector) return true;
            const vchartKeys = Object.keys(vchartDatum).filter((k)=>k.toLocaleLowerCase().startsWith('__vchart'));
            const datum = chunk_KI5X74E2_y(vchartDatum, vchartKeys);
            const selectors = Array.isArray(selector) ? selector : [
                selector
            ];
            return selectors['And' === selectorMode ? 'every' : 'some']((selector)=>{
                if (isValueSelector(selector)) return selectByValue(selector, datum);
                if (isMeasureSelector(selector)) return selectByMeasure(selector, datum);
                if (isDimensionSelector(selector)) return selectByDmension(selector, datum);
                if (isPartialDatumSelector(selector)) return selectByPartial(selector, datum);
                return false;
            });
        };
        const selectorDatum = (datum, selector)=>{
            if (!selector) return [];
            const selectors = Array.isArray(selector) ? selector : [
                selector
            ];
            let finalResult = [];
            for (const selector of selectors){
                const results = [];
                if (isValueSelector(selector)) Object.entries(datum).forEach(([key, value])=>{
                    if (value === selector) results.push({
                        [key]: value
                    });
                });
                else if (isMeasureSelector(selector) && selectByMeasure(selector, datum)) results.push({
                    [selector.field]: datum[selector.field]
                });
                else if (isDimensionSelector(selector) && selectByDmension(selector, datum)) results.push({
                    [selector.field]: datum[selector.field]
                });
                else if (isPartialDatumSelector(selector) && selectByPartial(selector, datum)) results.push(selector);
                if (results.length) finalResult = finalResult.length ? finalResult.flatMap((prev)=>results.map((r)=>({
                            ...prev,
                            ...r
                        }))) : results;
                else {
                    finalResult = [];
                    break;
                }
            }
            return finalResult;
        };
        const isValueSelector = (selector)=>'string' == typeof selector || 'number' == typeof selector;
        const isPartialDatumSelector = (selector)=>'object' == typeof selector && null !== selector;
        const isMeasureSelector = (selector)=>'object' == typeof selector && null !== selector && 'field' in selector && ('operator' in selector || 'op' in selector) && 'value' in selector && ([
                '=',
                '==',
                '!=',
                '>',
                '<',
                '>=',
                '<=',
                'between'
            ].includes(selector.operator) || [
                '=',
                '==',
                '!=',
                '>',
                '<',
                '>=',
                '<=',
                'between'
            ].includes(selector.op));
        const isDimensionSelector = (selector)=>'object' == typeof selector && null !== selector && 'field' in selector && ('operator' in selector || 'op' in selector) && 'value' in selector && ([
                'in',
                'not in'
            ].includes(selector.operator) || [
                'in',
                'not in'
            ].includes(selector.op));
        const selectByMeasure = (selector, datum)=>{
            const op = selector.operator || selector.op;
            const selectorValueArr = Array.isArray(selector.value) ? selector.value : [
                selector.value
            ];
            switch(op){
                case '=':
                    if (String(datum[selector.field]) === String(selectorValueArr[0]) || nearlyEqual(Number(datum[selector.field]), Number(selectorValueArr[0]))) return true;
                    break;
                case '==':
                    if (datum[selector.field] === selectorValueArr[0]) return true;
                    break;
                case '!=':
                    if (datum[selector.field] !== selectorValueArr[0]) return true;
                    break;
                case '>':
                    if (datum[selector.field] > selectorValueArr[0] && !nearlyEqual(Number(datum[selector.field]), Number(selectorValueArr[0]))) return true;
                    break;
                case '<':
                    if (datum[selector.field] < selectorValueArr[0] && !nearlyEqual(Number(datum[selector.field]), Number(selectorValueArr[0]))) return true;
                    break;
                case '>=':
                    if (datum[selector.field] >= selectorValueArr[0] || nearlyEqual(Number(datum[selector.field]), Number(selectorValueArr[0]))) return true;
                    break;
                case '<=':
                    if (datum[selector.field] <= selectorValueArr[0] || nearlyEqual(Number(datum[selector.field]), Number(selectorValueArr[0]))) return true;
                    break;
                case 'between':
                    if (Array.isArray(selector.value) && (datum[selector.field] >= selectorValueArr[0] || nearlyEqual(Number(datum[selector.field]), Number(selectorValueArr[0]))) && (datum[selector.field] <= selectorValueArr[1] || nearlyEqual(Number(datum[selector.field]), Number(selectorValueArr[1])))) return true;
                    break;
            }
            return false;
        };
        const selectByDmension = (selector, datum)=>{
            const op = selector.operator || selector.op;
            const selectorValueArr = Array.isArray(selector.value) ? selector.value : [
                selector.value
            ];
            switch(op){
                case 'in':
                    if (selectorValueArr.includes(datum[selector.field])) return true;
                    break;
                case 'not in':
                    if (!selectorValueArr.includes(datum[selector.field])) return true;
                    break;
            }
            return false;
        };
        const selectByPartial = (selector, datum)=>Object.keys(selector).every((key)=>datum[key] === selector[key]);
        const selectByValue = (selector, datum)=>Object.values(datum).some((v)=>v === selector);
        const tableStyleMap = {
            backgroundColor: 'bgColor',
            textColor: 'color',
            textFontSize: 'fontSize',
            borderColor: 'borderColor',
            borderLineWidth: 'borderLineWidth'
        };
        const pickBodyCellStyle = (bodyCellStyle)=>Object.keys(tableStyleMap).reduce((acc, key)=>{
                if (key in bodyCellStyle) acc[tableStyleMap[key]] = bodyCellStyle[key];
                return acc;
            }, {});
        const tableBodyCell = (spec, context)=>{
            const { advancedVSeed } = context;
            const { cellStyle } = advancedVSeed;
            const bodyCellStyle = cellStyle?.bodyCellStyle;
            if (!bodyCellStyle) return spec;
            const bodyCellStyleList = array_array(bodyCellStyle);
            const columns = spec.columns || [];
            const setStyleOfColumn = (col)=>{
                const field = col.field;
                const matchedStyles = bodyCellStyleList.filter((style)=>{
                    if (chunk_JK3VNB42_n(style.selector)) return true;
                    const selectors = array_array(style.selector);
                    return selectors.some((selector)=>chunk_BZNENX2T_r(selector) ? chunk_JK3VNB42_n(selector.field) || selector.field === field : chunk_6GTAPB47_e(selector) || chunk_SFZGYJFI_t(selector));
                });
                if (!matchedStyles.length) return false;
                col.style = (datum)=>{
                    const originalDatum = {
                        [field]: datum.dataValue
                    };
                    const mergedStyle = matchedStyles.reduce((result, style)=>{
                        if (selector_selector(originalDatum, style.selector)) return {
                            ...result,
                            ...pickBodyCellStyle(style)
                        };
                        return result;
                    }, {});
                    return mergedStyle;
                };
                return false;
            };
            preorderTraverse(columns, setStyleOfColumn, 'columns');
            return spec;
        };
        const tableSpecPipeline = [
            initTable,
            dimensionTreeToColumns,
            measureTreeToColumns,
            bodyStyle,
            headerStyle,
            frameStyle,
            selectionStyle,
            tableBodyCell
        ];
        const registerTable = ()=>{
            Builder._advancedPipelineMap.table = tableAdvancedPipeline;
            Builder._specPipelineMap.table = tableSpecPipeline;
        };
        const ORIGINAL_DATA = '__OriginalData__';
        const FoldMeasureName = '__MeaName__';
        const FoldMeasureId = '__MeaId__';
        const FoldMeasureValue = '__MeaValue__';
        const MeasureId = FoldMeasureId;
        const MeasureName = FoldMeasureName;
        const FoldPrimaryMeasureValue = '__MeaPrimaryValue__';
        const FoldSecondaryMeasureValue = '__MeaSecondaryValue__';
        const FoldXMeasureValue = '__MeaXValue__';
        const FoldYMeasureValue = '__MeaYValue__';
        const FoldXMeasureId = '__MeaXId__';
        const FoldYMeasureId = '__MeaYId__';
        const XEncoding = '__Dim_X__';
        const YEncoding = '__Dim_Y__';
        const AngleEncoding = '__Dim_Angle__';
        const DetailEncoding = '__Dim_Detail__';
        const ColorEncoding = '__Dim_Color__';
        const ColorIdEncoding = '__Dim_ColorId__';
        const LowerWhisker = '__Lower_Whisker__';
        const UpperWhisker = '__Upper_Whisker__';
        const OutliersMeasureId = '__Outliers__';
        const MedianMeasureId = '__Meadian__';
        const BinStartMeasureId = '__BinStart__';
        const BinEndMeasureId = '__BinEnd__';
        const BinCountMeasureId = '__BinCount__';
        const BinPercentageMeasureId = '__BinPercentage__';
        const defaultMeasureId = (advancedVSeed)=>{
            const result = {
                ...advancedVSeed
            };
            const measures = findAllMeasures(advancedVSeed.measures);
            if (measures.length > 1 && !result.dimensions?.some((dim)=>dim.id === MeasureName)) result.dimensions?.push({
                id: MeasureId,
                alias: intl.i18n`指标名称`,
                encoding: 'row'
            });
            return result;
        };
        const encodingForPivotTable = (advancedVSeed)=>{
            const { measures: vseedMeasures = [], dimensions = [] } = advancedVSeed;
            const measures = findAllMeasures(vseedMeasures);
            const hasDimensionEncoding = dimensions.some((item)=>item.encoding);
            const hasMeasureEncoding = measures.some((item)=>item.encoding);
            const encoding = {};
            if (hasDimensionEncoding) generateDimensionEncoding(dimensions, encoding);
            else generateDefaultDimensionEncoding(dimensions, encoding);
            if (hasMeasureEncoding) generateMeasureEncoding(measures, encoding);
            else generateDefaultMeasureEncoding(measures, encoding);
            return {
                ...advancedVSeed,
                encoding
            };
        };
        const generateDefaultDimensionEncoding = (dimensions, encoding)=>{
            const uniqueDimIds = chunk_QJLMYOTX_i(dimensions.map((d)=>d.id));
            encoding.tooltip = uniqueDimIds;
            encoding.row = [];
            encoding.column = [];
            uniqueDimIds.forEach((item, index)=>{
                if (index % 2 === 0) encoding.column.push(item);
                else encoding.row.push(item);
            });
        };
        const generateDimensionEncoding = (dimensions, encoding)=>{
            const uniqueDimIds = chunk_QJLMYOTX_i(dimensions.map((d)=>d.id));
            encoding.tooltip = uniqueDimIds;
            encoding.row = [];
            encoding.column = [];
            dimensions.forEach((dim, index)=>{
                const id = dim.id;
                if ('row' === dim.encoding) encoding.row.push(id);
                else if ('column' === dim.encoding) encoding.column.push(id);
                else if (index % 2 === 0) encoding.column.push(id);
                else encoding.row.push(id);
            });
        };
        const generateDefaultMeasureEncoding = (measures, encoding)=>{
            encoding.tooltip = chunk_QJLMYOTX_i(measures.map((item)=>item.id));
            encoding.detail = chunk_QJLMYOTX_i(measures.filter((item)=>'detail' === item.encoding || !item.encoding).map((item)=>item.id));
        };
        const generateMeasureEncoding = (measures, encoding)=>{
            encoding.tooltip = measures.map((item)=>item.id);
            encoding.detail = chunk_QJLMYOTX_i(measures.filter((item)=>'detail' === item.encoding || !item.encoding).map((item)=>item.id));
        };
        const foldMeasures = (dataset, measures, options)=>{
            const { measureId, measureName, measureValue, colorMeasureId, allowEmptyFold = true, omitIds = [] } = options || {};
            const foldInfo = {
                measureId,
                measureName,
                measureValue,
                statistics: {
                    max: -1 / 0,
                    min: 1 / 0,
                    sum: 0,
                    count: 0,
                    colorMin: 1 / 0,
                    colorMax: -1 / 0
                },
                foldMap: {}
            };
            if (!allowEmptyFold && 0 === measures.length) return {
                dataset,
                foldInfo
            };
            const result = new Array(dataset.length * measures.length);
            let index = 0;
            const ids = measures.map((d)=>d.id);
            for(let i = 0; i < dataset.length; i++)for(let j = 0; j < measures.length; j++){
                const datum = chunk_KI5X74E2_y({
                    ...dataset[i]
                }, [
                    ...ids,
                    ...omitIds
                ]);
                datum[ORIGINAL_DATA] = dataset[i];
                const measure = measures[j];
                const { id, alias } = measure;
                datum[id] = dataset[i][id];
                datum[measureId] = id;
                datum[measureName] = alias || id;
                datum[measureValue] = dataset[i][id];
                if (colorMeasureId) {
                    const value = datum[ORIGINAL_DATA][colorMeasureId];
                    datum[ColorEncoding] = value;
                    datum[ColorIdEncoding] = colorMeasureId;
                    const valueNumber = Number(value);
                    foldInfo.statistics.colorMin = Math.min(foldInfo.statistics.colorMin, valueNumber);
                    foldInfo.statistics.colorMax = Math.max(foldInfo.statistics.colorMax, valueNumber);
                }
                const valueNumber = Number(datum[id]);
                foldInfo.statistics.min = Math.min(foldInfo.statistics.min, valueNumber);
                foldInfo.statistics.max = Math.max(foldInfo.statistics.max, valueNumber);
                foldInfo.statistics.sum += valueNumber;
                foldInfo.statistics.count++;
                foldInfo.foldMap[id] = alias;
                result[index++] = datum;
            }
            return {
                dataset: result,
                foldInfo
            };
        };
        const reshapePivotTable = (advancedVSeed, context)=>{
            const result = {
                ...advancedVSeed
            };
            const { vseed } = context;
            const { dataset, chartType } = vseed;
            const { dimensions, measures } = advancedVSeed;
            const { dataset: newDatasets, foldInfo } = foldMeasures(dataset, findAllMeasures(measures), {
                measureId: FoldMeasureId,
                measureName: FoldMeasureName,
                measureValue: FoldMeasureValue,
                allowEmptyFold: false
            });
            const datasetReshapeInfo = [
                {
                    id: String(chartType),
                    index: 0,
                    foldInfo
                }
            ];
            return {
                ...result,
                dataset: newDatasets,
                datasetReshapeInfo: datasetReshapeInfo,
                dimensions,
                measures
            };
        };
        const pivotTableConfig = (advancedVSeed, context)=>{
            const { vseed } = context;
            const { chartType } = vseed;
            const result = {
                ...advancedVSeed
            };
            const config = chunk_2T7K3PFL_i(vseed, [
                'backgroundColor',
                'bodyFontSize',
                'bodyFontColor',
                'bodyBackgroundColor',
                'headerFontSize',
                'headerFontColor',
                'headerBackgroundColor',
                'hoverHeaderBackgroundColor',
                'hoverHeaderInlineBackgroundColor',
                'selectedBorderColor',
                'selectedBackgroundColor'
            ]);
            result.config = {
                ...result.config || {},
                [chartType]: {
                    ...config
                }
            };
            return result;
        };
        const pivotTableAdvancedPipeline = [
            initAdvancedVSeed,
            defaultMeasures_defaultMeasures,
            defaultDimensions,
            defaultMeasureId,
            cellStyle_cellStyle,
            encodingForPivotTable,
            reshapePivotTable,
            pivotTableConfig,
            theme_theme
        ];
        const initPivotTable = (spec, context)=>{
            const { advancedVSeed } = context;
            const { dataset } = advancedVSeed;
            const { config } = advancedVSeed;
            const { backgroundColor = 'transparent' } = config.pivotTable || {};
            return {
                ...spec,
                records: dataset,
                widthMode: 'standard',
                defaultHeaderColWidth: 'auto',
                heightMode: 'autoHeight',
                autoWrapText: true,
                columnResizeMode: 'all',
                columnResizeType: 'column',
                showColumnHeader: true,
                showRowHeader: true,
                select: {
                    highlightMode: 'cell',
                    headerSelectMode: 'inline'
                },
                hover: {
                    highlightMode: 'cross'
                },
                tooltip: {
                    isShowOverflowTextTooltip: true
                },
                corner: {
                    titleOnDimension: 'all'
                },
                widthAdaptiveMode: 'all',
                animationAppear: {
                    duration: 300,
                    delay: 250,
                    type: 'one-by-one',
                    direction: 'row'
                },
                theme: {
                    cellInnerBorder: false,
                    underlayBackgroundColor: backgroundColor
                }
            };
        };
        const pivotColumns = (spec, context)=>{
            const { advancedVSeed } = context;
            const { encoding } = advancedVSeed;
            const dimensions = advancedVSeed.dimensions;
            const columns = dimensions.filter((item)=>encoding.column?.includes(item.id));
            return {
                ...spec,
                columns: columns.map((item)=>({
                        dimensionKey: item.id,
                        title: item.alias || item.id,
                        width: 'auto'
                    }))
            };
        };
        const pivotRows = (spec, context)=>{
            const { advancedVSeed } = context;
            const dimensions = advancedVSeed.dimensions;
            const { encoding, measures } = advancedVSeed;
            const rows = dimensions.filter((item)=>encoding.row?.includes(item.id));
            const allMeasures = findAllMeasures(measures);
            return {
                ...spec,
                rows: rows.map((item)=>{
                    const res = {
                        dimensionKey: item.id,
                        title: item.alias || item.id,
                        width: 'auto'
                    };
                    if (item.id === MeasureId) res.headerFormat = (measureId)=>{
                        const measure = allMeasures.find((m)=>m.id === measureId);
                        return measure?.alias ?? measureId;
                    };
                    return res;
                })
            };
        };
        const titleOnDimension = (spec)=>{
            const { rows = [], columns = [] } = spec;
            return {
                ...spec,
                corner: {
                    titleOnDimension: rows.length <= 1 && columns.length >= 1 ? 'column' : 'row'
                }
            };
        };
        const pivotIndicators = (spec, context)=>{
            const { advancedVSeed } = context;
            const { measures, datasetReshapeInfo } = advancedVSeed;
            const { foldInfo } = datasetReshapeInfo[0];
            const hasRow = spec?.rows?.length > 0;
            const foldMapValues = Object.values(foldInfo.foldMap);
            return {
                ...spec,
                indicatorTitle: intl.i18n`指标名称`,
                indicatorsAsCol: hasRow,
                hideIndicatorName: hasRow,
                indicators: [
                    {
                        cellType: 'text',
                        indicatorKey: foldInfo.measureValue,
                        title: foldMapValues.length > 1 ? '' : foldMapValues[0],
                        width: 'auto',
                        format: pivotIndicators_fieldFormat(measures, foldInfo)
                    }
                ]
            };
        };
        const pivotIndicators_fieldFormat = (measures, foldInfo)=>(value, col, row, table)=>{
                if (!chunk_6GTAPB47_e(col) || !chunk_6GTAPB47_e(row) || !table) return value;
                const datum = table.getCellOriginRecord(col, row);
                if (!datum[0]) return value;
                const { measureId: foldMeasureId } = foldInfo;
                const measureId = datum[0][foldMeasureId];
                const measure = findMeasureById(measures, measureId);
                const formatter = createFormatterByMeasure(measure);
                return formatter(value);
            };
        const rowHeaderStyle = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed } = context;
            const { config, chartType } = advancedVSeed;
            const themConfig = config?.[chartType];
            if (!result.theme || !themConfig) return result;
            const borderColor = themConfig.borderColor || 'rgb(224, 224, 224)';
            const backgroundColor = themConfig.headerBackgroundColor || '#EEF1F5';
            const fontColor = themConfig.headerFontColor || '#1B1F23';
            const fontSize = themConfig.headerFontSize || 12;
            const hoverCellBgColor = themConfig.hoverHeaderBackgroundColor || '#bedaff';
            const hoverInlineColor = themConfig.hoverHeaderInlineBackgroundColor || '#bedaff';
            result.theme.rowHeaderStyle = {
                borderColor: borderColor,
                borderLineWidth: 1,
                padding: [
                    8,
                    12,
                    8,
                    12
                ],
                textAlign: 'left',
                hover: {
                    cellBgColor: hoverCellBgColor,
                    inlineRowBgColor: hoverInlineColor,
                    inlineColumnBgColor: hoverInlineColor
                },
                frameStyle: {
                    borderColor: borderColor,
                    borderLineWidth: [
                        0,
                        1,
                        0,
                        0
                    ]
                },
                fontSize: fontSize,
                fontVariant: 'normal',
                fontStyle: 'normal',
                fontWeight: 'bold',
                color: fontColor,
                bgColor: backgroundColor,
                lineHeight: 1.5 * fontSize
            };
            return result;
        };
        const cornerHeaderStyle = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed } = context;
            const { config, chartType } = advancedVSeed;
            const themConfig = config?.[chartType];
            if (!result.theme || !themConfig) return result;
            const borderColor = themConfig.borderColor || 'rgb(224, 224, 224)';
            const backgroundColor = themConfig.headerBackgroundColor || '#EEF1F5';
            const fontColor = themConfig.headerFontColor || '#1B1F23';
            const fontSize = themConfig.headerFontSize || 12;
            const hoverInlineColor = themConfig.hoverHeaderInlineBackgroundColor;
            const hoverCellColor = themConfig.hoverHeaderBackgroundColor;
            result.theme.cornerHeaderStyle = {
                borderColor: [
                    borderColor,
                    borderColor
                ],
                borderLineWidth: 1,
                padding: [
                    8,
                    12,
                    8,
                    12
                ],
                textAlign: 'left',
                hover: {
                    cellBgColor: hoverCellColor || void 0,
                    inlineRowBgColor: hoverInlineColor || void 0,
                    inlineColumnBgColor: hoverInlineColor || void 0
                },
                frameStyle: {
                    borderColor: borderColor,
                    borderLineWidth: [
                        0,
                        1,
                        1,
                        0
                    ]
                },
                fontSize: fontSize,
                fontVariant: 'normal',
                fontStyle: 'normal',
                fontWeight: 'bold',
                color: fontColor,
                bgColor: backgroundColor,
                lineHeight: 1.5 * fontSize
            };
            return result;
        };
        const pivotTableBodyCell = (spec, context)=>{
            const { advancedVSeed } = context;
            const { cellStyle } = advancedVSeed;
            const bodyCellStyle = cellStyle?.bodyCellStyle;
            if (!bodyCellStyle) return spec;
            const bodyCellStyleList = array_array(bodyCellStyle);
            const indicators = spec.indicators || [];
            const newIndicators = indicators.map((ind)=>{
                const newInd = chunk_SFZGYJFI_t(ind) ? {
                    indicatorKey: ind
                } : ind;
                const { indicatorKey } = newInd;
                newInd.style = (datum)=>{
                    const { dataValue, cellHeaderPaths } = datum;
                    const headerPaths = [
                        ...cellHeaderPaths.colHeaderPaths,
                        ...cellHeaderPaths.rowHeaderPaths
                    ];
                    const originalDatum = {
                        [indicatorKey]: dataValue
                    };
                    headerPaths.forEach((path)=>{
                        if (path.dimensionKey) originalDatum[path.dimensionKey] = path.value;
                    });
                    if (!chunk_JK3VNB42_n(originalDatum[MeasureId]) && !chunk_JK3VNB42_n(originalDatum[FoldMeasureValue])) originalDatum[originalDatum[MeasureId]] = originalDatum[FoldMeasureValue];
                    const mergedStyle = bodyCellStyleList.reduce((result, style)=>{
                        if (selector_selector(originalDatum, style.selector)) return {
                            ...result,
                            ...pickBodyCellStyle(style)
                        };
                        return result;
                    }, {});
                    return mergedStyle;
                };
                return newInd;
            });
            return {
                ...spec,
                indicators: newIndicators
            };
        };
        const dataConfig = (spec, context)=>{
            const { advancedVSeed } = context;
            const measures = findAllMeasures(advancedVSeed.measures);
            const aggregationRules = measures.map((measure)=>({
                    field: measure.id,
                    aggregationType: 'NONE',
                    indicatorKey: measure.id
                }));
            return {
                ...spec,
                dataConfig: {
                    aggregationRules
                }
            };
        };
        const pivotTableSpecPipeline = [
            initPivotTable,
            pivotColumns,
            pivotRows,
            titleOnDimension,
            pivotIndicators,
            bodyStyle,
            headerStyle,
            rowHeaderStyle,
            cornerHeaderStyle,
            frameStyle,
            selectionStyle,
            dataConfig,
            pivotTableBodyCell
        ];
        const registerPivotTable = ()=>{
            Builder._advancedPipelineMap.pivotTable = pivotTableAdvancedPipeline;
            Builder._specPipelineMap.pivotTable = pivotTableSpecPipeline;
        };
        const initAdvancedVSeed_initAdvancedVSeed = (advancedVSeed, context)=>{
            const { vseed } = context;
            const { chartType, locale } = vseed;
            checkVSeed(vseed);
            return {
                ...advancedVSeed,
                chartType,
                locale: locale || 'zh-CN'
            };
        };
        const default_defaultMeasures_defaultMeasures = (advancedVSeed, context)=>{
            const { vseed } = context;
            const { measures, dataset } = vseed;
            if (measures && measures.length > 0) {
                const clonedMeasures = chunk_BCBB46UE_d(measures);
                preorderTraverse(clonedMeasures, (node)=>{
                    node.alias = node.alias || node.id;
                    return false;
                });
                return {
                    ...advancedVSeed,
                    measures: clonedMeasures
                };
            }
            const top100dataset = dataset.slice(0, 100);
            const sample = top100dataset.reduce((prev, cur)=>({
                    ...prev,
                    ...cur
                }), {});
            const defaultMeasures = Object.keys(sample).filter((key)=>top100dataset.some((item)=>'number' == typeof item[key]) && ![
                    '',
                    null,
                    void 0
                ].includes(key)).map((measure)=>({
                    id: measure,
                    alias: measure
                }));
            return {
                ...advancedVSeed,
                measures: defaultMeasures
            };
        };
        const defaultDimensions_defaultDimensions = (advancedVSeed, context)=>{
            const result = {
                ...advancedVSeed
            };
            const { vseed } = context;
            const { dimensions, dataset } = vseed;
            if (dimensions && dimensions.length > 0) return {
                ...result,
                dimensions: chunk_BCBB46UE_d(dimensions.map((dim)=>({
                        ...dim,
                        alias: dim.alias || dim.id
                    })))
            };
            const measures = findAllMeasures(advancedVSeed.measures);
            const top100dataset = dataset.slice(0, 100);
            const sample = top100dataset.reduce((prev, cur)=>({
                    ...prev,
                    ...cur
                }), {});
            const newDimensions = Object.keys(sample).filter((key)=>top100dataset.some((item)=>'string' == typeof item[key]) && ![
                    '',
                    null,
                    void 0
                ].includes(key) && !measures.some((measure)=>measure.id === key)).map((dim)=>({
                    id: dim,
                    alias: dim
                }));
            return {
                ...result,
                dimensions: newDimensions
            };
        };
        const defaultMeasureId_defaultMeasureId = (advancedVSeed)=>{
            const result = {
                ...advancedVSeed
            };
            const MeaIdDim = {
                id: MeasureId,
                alias: intl.i18n`指标Id`
            };
            if (!result.dimensions?.some((dim)=>dim.id === MeasureId)) result.dimensions?.push(MeaIdDim);
            return result;
        };
        const encodingAdapter = (noEncodingPipeline, hasEncodingPipeline)=>(advancedVSeed, context)=>{
                const { dimensions = [], measures = [] } = advancedVSeed;
                const hasDimensionEncoding = dimensions.some((item)=>item.encoding);
                const hasMeasureEncoding = measures.some((item)=>item.encoding);
                const hasEncoding = hasDimensionEncoding || hasMeasureEncoding;
                if (hasEncoding) return execPipeline(hasEncodingPipeline, context, advancedVSeed);
                return execPipeline(noEncodingPipeline, context, advancedVSeed);
            };
        const addColorToEncoding = (dimensions, encoding, isMultiMeasure)=>{
            encoding.color = chunk_QJLMYOTX_i(dimensions.filter((item)=>'color' === item.encoding).map((item)=>item.id));
            const measureId = dimensions.find((item)=>item.id === MeasureId);
            if (isMultiMeasure && measureId && !measureId.encoding) encoding.color.push(MeasureId);
            if (0 === encoding.color.length) encoding.color = [
                MeasureId
            ];
        };
        const defaultEncodingForLine = (advancedVSeed)=>{
            const { measures: vseedMeasures = [], dimensions = [] } = advancedVSeed;
            const measures = findAllMeasures(vseedMeasures);
            const encoding = {};
            line_generateDefaultDimensionEncoding(dimensions, encoding);
            line_generateDefaultMeasureEncoding(measures, encoding);
            return {
                ...advancedVSeed,
                encoding
            };
        };
        const encodingForLine = (advancedVSeed)=>{
            const { measures: vseedMeasures = [], dimensions = [] } = advancedVSeed;
            const measures = findAllMeasures(vseedMeasures);
            const hasDimensionEncoding = dimensions.some((item)=>item.encoding);
            const hasMeasureEncoding = measures.some((item)=>item.encoding);
            const encoding = {};
            if (hasDimensionEncoding) line_generateDimensionEncoding(dimensions, encoding, measures.length > 1);
            else line_generateDefaultDimensionEncoding(dimensions, encoding);
            if (hasMeasureEncoding) line_generateMeasureEncoding(measures, encoding);
            else line_generateDefaultMeasureEncoding(measures, encoding);
            return {
                ...advancedVSeed,
                encoding
            };
        };
        const line_generateDefaultDimensionEncoding = (dimensions, encoding)=>{
            const uniqueDimIds = chunk_QJLMYOTX_i(dimensions.map((d)=>d.id));
            encoding.x = uniqueDimIds.slice(0, 1);
            encoding.color = uniqueDimIds.slice(1);
            encoding.tooltip = uniqueDimIds.filter((d)=>d !== MeasureId);
            encoding.detail = [];
            encoding.label = [];
            encoding.row = [];
            encoding.column = [];
        };
        const line_generateDimensionEncoding = (dimensions, encoding, isMultiMeasure)=>{
            encoding.x = chunk_QJLMYOTX_i(dimensions.filter((item)=>'xAxis' === item.encoding).map((item)=>item.id));
            if (0 === encoding.x.length) encoding.x = [
                dimensions[0].id
            ];
            addColorToEncoding(dimensions, encoding, isMultiMeasure);
            encoding.detail = chunk_QJLMYOTX_i(dimensions.filter((item)=>'detail' === item.encoding).map((item)=>item.id));
            if (0 === encoding.detail.length) encoding.detail = [
                MeasureId
            ];
            encoding.tooltip = chunk_QJLMYOTX_i(dimensions.map((item)=>item.id));
            encoding.tooltip = encoding.tooltip.filter((d)=>d !== MeasureId);
            encoding.label = chunk_QJLMYOTX_i(dimensions.filter((item)=>'label' === item.encoding).map((item)=>item.id));
            encoding.label = encoding.label.filter((d)=>d !== MeasureId);
        };
        const line_generateDefaultMeasureEncoding = (measures, encoding)=>{
            encoding.y = chunk_QJLMYOTX_i(measures.filter((item)=>'yAxis' === item.encoding || !item.encoding).map((item)=>item.id));
        };
        const line_generateMeasureEncoding = (measures, encoding)=>{
            encoding.y = chunk_QJLMYOTX_i(measures.filter((item)=>'yAxis' === item.encoding || !item.encoding).map((item)=>item.id));
            const color = chunk_QJLMYOTX_i(measures.filter((item)=>'color' === item.encoding).map((item)=>item.id));
            if (color.length > 0) encoding.color = color;
            const label = chunk_QJLMYOTX_i(measures.filter((item)=>'label' === item.encoding).map((item)=>item.id));
            encoding.label = chunk_QJLMYOTX_i([
                ...encoding.label || [],
                ...label
            ]);
            const tooltip = chunk_QJLMYOTX_i(measures.filter((item)=>'tooltip' === item.encoding).map((item)=>item.id));
            encoding.tooltip = chunk_QJLMYOTX_i([
                ...encoding.tooltip || [],
                ...label,
                ...tooltip
            ]);
        };
        const buildMeasures = (advancedVSeed)=>{
            if (isMeasureTreeWithChildren(advancedVSeed.measures)) {
                advancedVSeed.measures = normalizeMeasureTree(advancedVSeed.measures);
                return advancedVSeed;
            }
            if (isMeasureTreeWithParentId(advancedVSeed.measures)) {
                advancedVSeed.measures = generateMeasuresByParentId(advancedVSeed.measures);
                return advancedVSeed;
            }
            if (isPivotChart(advancedVSeed)) advancedVSeed.measures = basicMeasuresToMeasureTree(advancedVSeed.measures);
            return advancedVSeed;
        };
        const generateMeasuresByParentId = (measures)=>{
            const measureTree = [];
            measures.forEach((measure)=>{
                const parent = measureTree.find((item)=>item.id === measure.parentId);
                if (parent && 'children' in parent) {
                    parent.children = parent.children || [];
                    if (parent.children.length > 0) parent.alias += `-${measure.alias ?? measure.id}`;
                    parent.children.push(measure);
                } else if (common_isValid(measure.parentId)) measureTree.push({
                    id: measure.parentId,
                    alias: measure.alias ?? measure.id,
                    children: [
                        measure
                    ]
                });
                else measureTree.push({
                    id: DEFAULT_PARENT_ID,
                    alias: measure.alias ?? measure.id,
                    children: [
                        measure
                    ]
                });
            });
            return measureTree;
        };
        const basicMeasuresToMeasureTree = (measures)=>{
            const id = measures.map((item)=>item.id).join('-');
            const alias = measures.map((item)=>item.alias || item.id).join('-');
            return [
                {
                    id,
                    alias,
                    children: measures
                }
            ];
        };
        const deleteMeasureTreeByCallback = (measureTree, callback)=>{
            if (!measureTree) return;
            const stack = [
                ...measureTree
            ].reverse();
            const parents = new Map();
            measureTree.forEach((node)=>{
                parents.set(node, measureTree);
            });
            const nodesToProcess = [];
            const visited = new Set();
            while(stack.length > 0){
                const node = stack[stack.length - 1];
                if (isMeasureGroup(node) && node.children && !visited.has(node)) {
                    visited.add(node);
                    const children = node.children.slice().reverse();
                    for (const child of children){
                        parents.set(child, node.children);
                        stack.push(child);
                    }
                } else {
                    stack.pop();
                    nodesToProcess.push(node);
                }
            }
            const deleted = [];
            for (const node of nodesToProcess){
                const parentList = parents.get(node);
                if (parentList) {
                    const index = parentList.indexOf(node);
                    if (isMeasure(node)) {
                        if (callback?.(node, index, parentList)) {
                            parentList.splice(index, 1);
                            deleted.push(node);
                        }
                    }
                }
            }
            return deleted;
        };
        const pickMeasuresForReshape = (encodingKeys)=>(advancedVSeed)=>{
                const clonedMeasures = chunk_BCBB46UE_d(advancedVSeed.measures);
                const deleteBy = (measure)=>encodingKeys.includes(measure.encoding);
                deleteMeasureTreeByCallback(clonedMeasures, deleteBy);
                return {
                    ...advancedVSeed,
                    reshapeMeasures: clonedMeasures
                };
            };
        const deleteDimensionTreeByCallback = (dimensionTree, callback)=>{
            if (!dimensionTree) return dimensionTree;
            const stack = [
                ...dimensionTree
            ].reverse();
            const parents = new Map();
            dimensionTree.forEach((node)=>{
                parents.set(node, dimensionTree);
            });
            const nodesToProcess = [];
            const visited = new Set();
            while(stack.length > 0){
                const node = stack[stack.length - 1];
                if (isDimensionGroup(node) && node.children && !visited.has(node)) {
                    visited.add(node);
                    const children = node.children.slice().reverse();
                    for (const child of children){
                        parents.set(child, node.children);
                        stack.push(child);
                    }
                } else {
                    stack.pop();
                    nodesToProcess.push(node);
                }
            }
            for (const node of nodesToProcess){
                const parentList = parents.get(node);
                if (parentList) {
                    const index = parentList.indexOf(node);
                    if (isDimension(node)) {
                        if (callback?.(node, index, parentList)) parentList.splice(index, 1);
                    }
                }
            }
            return dimensionTree;
        };
        const pickDimensionsForReshape = (advancedVSeed)=>{
            const deleteBy = (dimension)=>'tooltip' === dimension.encoding || 'label' === dimension.encoding;
            const reshapeDimensions = chunk_BCBB46UE_d(advancedVSeed.dimensions);
            deleteDimensionTreeByCallback(reshapeDimensions, deleteBy);
            return {
                ...advancedVSeed,
                reshapeDimensions
            };
        };
        const pivotAdapter = (pipeline, pivotPipeline)=>(advancedVSeed, context)=>{
                const { vseed } = context;
                const usePivotChart = isPivotChart(vseed);
                if (usePivotChart) return execPipeline(pivotPipeline, context, advancedVSeed);
                return execPipeline(pipeline, context, advancedVSeed);
            };
        function T(...e) {
            return chunk_LFJW7BOT_y(chunk_7ZI6JRPB_y, e);
        }
        function chunk_7ZI6JRPB_y(e) {
            let u = e, n = new Set;
            return (t, i, d)=>{
                let r = u(t, i, d);
                return n.has(r) ? chunk_ANXBDSUI_s : (n.add(r), {
                    done: !1,
                    hasNext: !0,
                    next: t
                });
            };
        }
        const unfoldDimensions = (dataset, dimensions, encoding, options)=>{
            const { separator } = options;
            const unfoldInfo = {
                encodingAngle: AngleEncoding,
                encodingX: XEncoding,
                encodingY: YEncoding,
                encodingDetail: DetailEncoding,
                encodingColor: ColorEncoding,
                encodingColorId: ColorIdEncoding,
                colorItems: [],
                colorIdMap: {}
            };
            const { color, x, y, detail, angle } = encoding;
            const angleDimensions = angle ? dimensions.filter((dim)=>angle.includes(dim.id)) : [];
            const xDimensions = x ? dimensions.filter((dim)=>x.includes(dim.id)) : [];
            const yDimensions = y ? dimensions.filter((dim)=>y.includes(dim.id)) : [];
            const colorDimensions = color ? dimensions.filter((dim)=>color.includes(dim.id)) : [];
            const detailDimensions = detail ? dimensions.filter((dim)=>detail.includes(dim.id)) : [];
            const colorItems = new Set();
            const colorIdMap = {};
            for(let i = 0; i < dataset.length; i++){
                const datum = dataset[i];
                applyEncoding(AngleEncoding, angleDimensions, datum, separator);
                applyEncoding(XEncoding, xDimensions, datum, separator);
                applyEncoding(YEncoding, yDimensions, datum, separator);
                applyEncoding(ColorEncoding, colorDimensions, datum, separator);
                applyEncoding(DetailEncoding, detailDimensions, datum, separator);
                if (!colorDimensions.length || !datum[ColorEncoding]) continue;
                const colorId = String(datum[ColorEncoding] ?? '');
                datum[ColorIdEncoding] = colorId;
                colorIdMap[colorId] = {
                    id: colorId,
                    alias: getColorAliasItem(ColorEncoding, colorDimensions, datum, separator)
                };
                colorItems.add(colorId);
            }
            unfoldInfo.colorItems = Array.from(colorItems);
            unfoldInfo.colorIdMap = colorIdMap;
            return {
                dataset,
                unfoldInfo
            };
        };
        const applyEncoding = (encoding, dimensions, datum, separator)=>{
            if (encoding && dimensions.length) datum[encoding] = dimensions.map((dim)=>String(datum[dim.id])).join(separator);
        };
        const getColorAliasItem = (encoding, dimensions, datum, separator)=>{
            if (encoding && dimensions.length) return dimensions.map((dim)=>{
                if (dim.id === MeasureId) return String(datum[MeasureName]);
                return String(datum[dim.id]);
            }).join(separator);
            return '';
        };
        const dataReshapeByEncoding = (dataset, dimensions, measures, encoding, options)=>{
            const { foldMeasureId = FoldMeasureId, foldMeasureName = FoldMeasureName, foldMeasureValue = FoldMeasureValue, colorItemAsId = false, colorMeasureId, omitIds } = options || {};
            const { dataset: foldedDataset, foldInfo } = foldMeasures(dataset, measures, {
                measureId: foldMeasureId,
                measureName: foldMeasureName,
                measureValue: foldMeasureValue,
                colorMeasureId,
                omitIds
            });
            const { dataset: finalDataset, unfoldInfo } = unfoldDimensions(foldedDataset, dimensions, encoding, {
                foldMeasureId,
                separator: "-",
                colorItemAsId
            });
            return {
                dataset: finalDataset,
                foldInfo,
                unfoldInfo
            };
        };
        function colorAdapter(ordinalPipe, linearPipe) {
            return (spec, context)=>{
                const { advancedVSeed, vseed } = context;
                if (isLinearColor(advancedVSeed, vseed)) return linearPipe(spec, context);
                return ordinalPipe(spec, context);
            };
        }
        const isLinearColor = (advancedVSeed, vseed)=>{
            const { encoding } = advancedVSeed;
            const measures = vseed.measures || advancedVSeed.measures;
            const measureIdList = findAllMeasures(measures).map((measure)=>measure.id);
            const { color } = encoding;
            return color?.length === 1 && measureIdList.includes(color[0]);
        };
        const getColorMeasureId = (advancedVSeed, vseed)=>{
            if (isLinearColor(advancedVSeed, vseed)) {
                const { encoding } = advancedVSeed;
                const { color } = encoding;
                return color?.[0];
            }
        };
        const reshapeWithEncoding = (advancedVSeed, context)=>{
            const result = {
                ...advancedVSeed
            };
            const { vseed } = context;
            const { dataset, chartType } = vseed;
            const { encoding } = advancedVSeed;
            const colorMeasureId = getColorMeasureId(advancedVSeed, vseed);
            const { dataset: newDatasets, foldInfo, unfoldInfo } = dataReshapeByEncoding(dataset, T(advancedVSeed.reshapeDimensions ?? advancedVSeed.dimensions ?? [], (item)=>item.id), T(findAllMeasures(advancedVSeed.reshapeMeasures ?? advancedVSeed.measures), (item)=>item.id), encoding, {
                colorItemAsId: false,
                colorMeasureId
            });
            return {
                ...result,
                dataset: newDatasets,
                datasetReshapeInfo: [
                    {
                        id: String(chartType),
                        index: 0,
                        foldInfo,
                        unfoldInfo
                    }
                ]
            };
        };
        const pivotReshapeWithEncoding = (advancedVSeed, context)=>{
            const result = {
                ...advancedVSeed
            };
            const { vseed } = context;
            const { dataset } = vseed;
            const { encoding } = advancedVSeed;
            const measures = advancedVSeed.reshapeMeasures ?? advancedVSeed.measures ?? [];
            const dimensions = advancedVSeed.reshapeDimensions ?? advancedVSeed.dimensions ?? [];
            const allMeasures = findAllMeasures(measures);
            const measureGroups = [];
            if (measures) measures.forEach((measure)=>{
                if (measure.children && measure.children.length > 0) measureGroups.push(measure);
            });
            const datasets = [];
            const datasetReshapeInfo = [];
            measureGroups.forEach((measureGroup, index)=>{
                const measures = measureGroup.children;
                if (!measures) return;
                const groupId = measureGroup.id;
                const { dataset: newSubDataset, foldInfo, unfoldInfo } = dataReshapeByEncoding(dataset, T(dimensions, (item)=>item.id), T(measures, (item)=>item.id), encoding, {
                    colorItemAsId: false,
                    foldMeasureValue: `${FoldMeasureValue}${groupId}`,
                    colorMeasureId: getColorMeasureId(advancedVSeed, vseed),
                    omitIds: allMeasures.map((item)=>item.id)
                });
                const reshapeInfo = {
                    id: `${groupId}`,
                    index,
                    foldInfo,
                    unfoldInfo
                };
                datasets.push(newSubDataset);
                datasetReshapeInfo.push(reshapeInfo);
            });
            return {
                ...result,
                dataset: datasets,
                datasetReshapeInfo: datasetReshapeInfo
            };
        };
        function chunk_NFFV4IQT_m(...r) {
            return chunk_WIMGWYZL_u(chunk_NFFV4IQT_o, r);
        }
        function chunk_NFFV4IQT_o(r, t) {
            let e = [
                ...r
            ];
            return e.sort(t), e;
        }
        const calcOrder = (sortConfig, id, dataset)=>{
            if (sortConfig.customOrder) return sortConfig.customOrder;
            const order = sortConfig.order || 'asc';
            const orderBy = sortConfig.orderBy;
            const res = chunk_NFFV4IQT_m(dataset, (a, b)=>{
                const aValue = a[orderBy || id];
                const bValue = b[orderBy || id];
                if ('asc' === order) {
                    if (aValue < bValue) return -1;
                    if (aValue > bValue) return 1;
                    return 0;
                }
                if (aValue > bValue) return -1;
                if (aValue < bValue) return 1;
                return 0;
            });
            return chunk_QJLMYOTX_i(res.map((item)=>item[id]));
        };
        const sortXBandAxis = (advancedVSeed, context)=>{
            const result = {
                ...advancedVSeed
            };
            const { vseed } = context;
            const { sort: sortAxis } = vseed;
            const { datasetReshapeInfo, dataset } = advancedVSeed;
            const { unfoldInfo } = datasetReshapeInfo[0];
            const xField = unfoldInfo.encodingX;
            if (!sortAxis || !xField) return advancedVSeed;
            if (!result.analysis) result.analysis = {};
            if (!result.analysis.orderMapping) result.analysis.orderMapping = {};
            const axisOrderResult = calcOrder(sortAxis, xField, dataset.flat(2));
            result.analysis.orderMapping[xField] = axisOrderResult;
            return result;
        };
        const sortLegend_sortLegend = (advancedVSeed, context)=>{
            const result = {
                ...advancedVSeed
            };
            const { vseed } = context;
            const { sortLegend } = vseed;
            const { datasetReshapeInfo, dataset } = advancedVSeed;
            const colorId = datasetReshapeInfo?.[0]?.unfoldInfo?.encodingColorId;
            const colorIdMap = datasetReshapeInfo?.[0]?.unfoldInfo?.colorIdMap ?? {};
            const colorItems = datasetReshapeInfo?.[0]?.unfoldInfo?.colorItems;
            if (!sortLegend || !colorId || !colorIdMap || !colorItems) return advancedVSeed;
            if (!result.analysis) result.analysis = {};
            if (!result.analysis.orderMapping) result.analysis.orderMapping = {};
            if (sortLegend.customOrder) {
                const colorIds = Object.keys(colorIdMap);
                const orderRes = sortLegend.customOrder.map((itemNameOrId)=>colorIds.find((id)=>colorIdMap[id]?.alias === itemNameOrId || colorIdMap[id]?.id === itemNameOrId || id === itemNameOrId));
                result.analysis.orderMapping[colorId] = orderRes;
                return result;
            }
            const orderRes = calcOrder(sortLegend, colorId, dataset?.flat(2) || []);
            result.analysis.orderMapping[colorId] = orderRes;
            return result;
        };
        const line_lineConfig = (advancedVSeed, context)=>{
            const { vseed } = context;
            const { chartType } = vseed;
            const result = {
                ...advancedVSeed
            };
            const pickedConfig = chunk_2T7K3PFL_i(vseed, [
                'backgroundColor',
                'color',
                'label',
                'legend',
                'tooltip',
                'xAxis',
                'yAxis',
                'crosshairLine',
                'dimensionLinkage'
            ]);
            const config = replaceNullToUndefined(pickedConfig);
            result.config = {
                ...result.config || {},
                [chartType]: {
                    ...config
                }
            };
            return result;
        };
        const markStyle_markStyle = (advancedVSeed, context)=>{
            const { vseed } = context;
            const pickedMarkStyle = chunk_2T7K3PFL_i(vseed, [
                'barStyle',
                'pointStyle',
                'lineStyle',
                'areaStyle',
                'boxPlotStyle',
                'outlierStyle'
            ]);
            const markStyle = replaceNullToUndefined(pickedMarkStyle);
            return {
                ...advancedVSeed,
                markStyle
            };
        };
        const annotation_annotation = (advancedVSeed, context)=>{
            const { vseed } = context;
            const annotation = chunk_2T7K3PFL_i(vseed, [
                'annotationPoint',
                'annotationHorizontalLine',
                'annotationVerticalLine',
                'annotationArea'
            ]);
            return {
                ...advancedVSeed,
                annotation
            };
        };
        const lineAdvancedPipeline = [
            initAdvancedVSeed_initAdvancedVSeed,
            default_defaultMeasures_defaultMeasures,
            defaultDimensions_defaultDimensions,
            defaultMeasureId_defaultMeasureId,
            encodingAdapter([
                defaultEncodingForLine,
                buildMeasures
            ], [
                encodingForLine,
                buildMeasures,
                pickMeasuresForReshape([
                    'tooltip',
                    'label',
                    'color'
                ]),
                pickDimensionsForReshape
            ]),
            pivotAdapter([
                reshapeWithEncoding
            ], [
                pivotReshapeWithEncoding
            ]),
            sortXBandAxis,
            sortLegend_sortLegend,
            line_lineConfig,
            theme_theme,
            markStyle_markStyle,
            annotation_annotation
        ];
        const initLine = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed, vseed } = context;
            const { datasetReshapeInfo } = advancedVSeed;
            const { foldInfo, unfoldInfo } = datasetReshapeInfo[0];
            result.type = 'line';
            result.direction = 'vertical';
            result.xField = unfoldInfo.encodingX;
            result.yField = foldInfo.measureValue;
            result.seriesField = isLinearColor(advancedVSeed, vseed) ? unfoldInfo.encodingDetail : unfoldInfo.encodingColorId;
            result.padding = 0;
            result.region = [
                {
                    clip: true
                }
            ];
            result.animation = true;
            return result;
        };
        const color_color = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed } = context;
            const { datasetReshapeInfo, chartType } = advancedVSeed;
            const { unfoldInfo } = datasetReshapeInfo[0];
            const baseConfig = advancedVSeed.config[chartType];
            if (!baseConfig || !baseConfig.color) return result;
            const colorItems = unfoldInfo.colorItems;
            const colorIdMap = unfoldInfo.colorIdMap;
            const { color } = baseConfig;
            const { colorScheme, colorMapping } = color;
            result.color = {
                type: 'ordinal',
                domain: colorItems,
                range: colorScheme,
                specified: createSpecifiedForColorMapping(colorMapping, colorIdMap, colorItems)
            };
            return result;
        };
        const createSpecifiedForColorMapping = (colorMapping, colorIdMap, colorItems)=>{
            if (!colorMapping || !colorIdMap || !colorItems) return;
            const matchedList = [];
            const colors = Object.entries(colorMapping).sort((a, b)=>b[0].length - a[0].length);
            const accurateMap = colors.reduce((prev, cur)=>{
                const name = cur[0];
                const colorValue = cur[1];
                const accurateMatchedList = Object.entries(colorIdMap).filter(([colorKey, colorObj])=>colorKey === name || colorObj.alias === name || colorObj.id === name);
                accurateMatchedList.forEach((item)=>{
                    prev[item[0]] = colorValue;
                    matchedList.push(name);
                });
                return prev;
            }, {});
            const fuzzyMap = colors.reduce((prev, cur)=>{
                const name = cur[0];
                const colorValue = cur[1];
                if (matchedList.includes(name)) return prev;
                const fuzzyMatchedList = Object.entries(colorIdMap).filter(([colorKey, colorObj])=>colorKey.includes(name) || colorObj.alias.includes(name) || colorObj.id.includes(name));
                fuzzyMatchedList.forEach((item)=>{
                    if (prev[item[0]]) return;
                    prev[item[0]] = colorValue;
                });
                return prev;
            }, {});
            return {
                ...fuzzyMap,
                ...accurateMap
            };
        };
        const linearColor = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed } = context;
            const { datasetReshapeInfo, chartType } = advancedVSeed;
            const { unfoldInfo, id } = datasetReshapeInfo[0];
            const baseConfig = advancedVSeed.config[chartType];
            if (!baseConfig || !baseConfig.color) return result;
            const { color } = baseConfig;
            const { colorScheme, linearColorScheme } = color;
            result.color = {
                type: 'linear',
                range: linearColorScheme || colorScheme || [],
                domain: [
                    {
                        dataId: id,
                        fields: [
                            unfoldInfo.encodingColor
                        ]
                    }
                ]
            };
            return result;
        };
        const background_backgroundColor = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed } = context;
            const { chartType } = advancedVSeed;
            const baseConfig = advancedVSeed.config[chartType];
            const { backgroundColor } = baseConfig;
            return {
                ...result,
                background: backgroundColor
            };
        };
        const datasetXY = (spec, context)=>{
            const { advancedVSeed, vseed } = context;
            const { analysis, datasetReshapeInfo } = advancedVSeed;
            const { unfoldInfo } = datasetReshapeInfo[0];
            const orderMapping = analysis?.orderMapping || {};
            const angle = unfoldInfo.encodingAngle;
            const x = unfoldInfo.encodingX;
            const colorId = unfoldInfo.encodingColorId;
            const id = datasetReshapeInfo[0].id;
            const fields = {};
            if (angle) fields[angle] = {
                sortIndex: 0
            };
            if (x) {
                const order = orderMapping[x];
                if (order) fields[x] = {
                    sortIndex: 0,
                    domain: order,
                    lockStatisticsByDomain: true
                };
                else fields[x] = {
                    sortIndex: 0
                };
            }
            if (colorId) {
                const order = orderMapping[colorId];
                if (order) fields[colorId] = {
                    sortIndex: 0,
                    domain: order,
                    lockStatisticsByDomain: true
                };
                else fields[colorId] = {
                    sortIndex: 0
                };
            }
            return {
                ...spec,
                data: {
                    id,
                    values: isPivotChart(vseed) ? void 0 : advancedVSeed.dataset,
                    fields: fields
                }
            };
        };
        const progressive = (spec)=>{
            const result = {
                ...spec
            };
            result.large = false;
            result.largeThreshold = 1 / 0;
            result.progressiveStep = 400;
            result.progressiveThreshold = 1 / 0;
            return result;
        };
        const defaultTitleText = (measures, dimensions, idList = [])=>{
            const allMeasures = findAllMeasures(measures);
            return idList.map((id)=>{
                const alias = [
                    ...allMeasures,
                    ...dimensions
                ].find((f)=>f.id === id)?.alias || '';
                return alias;
            }).join(' & ');
        };
        const xBand = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed, vseed } = context;
            const { chartType } = vseed;
            const { measures, dimensions, encoding, datasetReshapeInfo, pivotAllDatasetReshapeInfo } = advancedVSeed;
            const config = advancedVSeed.config?.[chartType]?.xAxis ?? {};
            if (!result.axes) result.axes = [];
            const { visible = true, label, tick, title, grid, line, labelAutoHide, labelAutoHideGap, labelAutoLimit, labelAutoLimitLength = 80, labelAutoRotate, labelAutoRotateAngleRange } = config;
            const sampling = !(labelAutoHide || labelAutoRotate || labelAutoLimit);
            const onlyMeasureId = 0 === (encoding.x || []).filter((v)=>v !== MeasureId).length;
            const bandAxis = {
                visible,
                type: 'band',
                orient: 'bottom',
                maxHeight: labelAutoLimitLength + 60,
                sampling,
                hover: true,
                label: {
                    visible: label?.visible,
                    flush: true,
                    space: 8,
                    style: {
                        maxLineWidth: labelAutoLimitLength,
                        fill: label?.labelColor,
                        angle: label?.labelAngle,
                        fontSize: label?.labelFontSize,
                        fontWeight: label?.labelFontWeight
                    },
                    minGap: labelAutoHideGap,
                    autoHide: labelAutoHide,
                    autoHideMethod: 'greedy',
                    autoHideSeparation: labelAutoHideGap,
                    autoLimit: labelAutoLimit,
                    autoRotate: labelAutoRotate,
                    autoRotateAngle: labelAutoRotateAngleRange,
                    lastVisible: true
                },
                title: {
                    visible: title?.visible,
                    text: title?.titleText || defaultTitleText(measures, dimensions, encoding.x),
                    style: {
                        fill: title?.titleColor,
                        fontSize: title?.titleFontSize,
                        fontWeight: title?.titleFontWeight
                    }
                },
                tick: {
                    visible: tick?.visible,
                    tickSize: tick?.tickSize,
                    inside: tick?.tickInside,
                    style: {
                        stroke: tick?.tickColor
                    }
                },
                grid: {
                    visible: grid?.visible,
                    style: {
                        lineWidth: grid?.gridWidth,
                        stroke: grid?.gridColor,
                        lineDash: grid?.gridLineDash
                    }
                },
                domainLine: {
                    visible: line?.visible,
                    style: {
                        lineWidth: line?.lineWidth,
                        stroke: line?.lineColor
                    }
                },
                paddingInner: [
                    0.15,
                    0.1
                ],
                paddingOuter: [
                    0.075,
                    0.1
                ]
            };
            if (onlyMeasureId && bandAxis.label) {
                const allDatasetReshapeInfo = pivotAllDatasetReshapeInfo || datasetReshapeInfo;
                const colorIdMap = allDatasetReshapeInfo.reduce((prev, cur)=>({
                        ...prev,
                        ...cur.unfoldInfo.colorIdMap
                    }), {});
                bandAxis.label.formatMethod = (text)=>common_isArray(text) ? text : colorIdMap[String(text)]?.alias ?? text;
            }
            result.axes = [
                ...result.axes,
                bandAxis
            ];
            return result;
        };
        const createLinearFormat = (value, autoFormat, numFormat, formatter)=>{
            if (chunk_JK3VNB42_n(autoFormat) && chunk_VCYTMP4D_n(numFormat)) return autoFormatter(value);
            if (true === autoFormat) return autoFormatter(value);
            if (!chunk_VCYTMP4D_n(numFormat)) return formatter(value);
            return String(value);
        };
        const createLinearPercentFormat = (value, autoFormat, numFormat, formatter, percentFormatter)=>{
            if (chunk_JK3VNB42_n(autoFormat) && chunk_VCYTMP4D_n(numFormat)) return percentFormatter(value);
            if (true === autoFormat) return percentFormatter(value);
            if (!chunk_VCYTMP4D_n(numFormat)) return formatter(value);
            return String(value);
        };
        const yLinear = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed, vseed } = context;
            const { chartType } = vseed;
            const { measures, dimensions, encoding } = advancedVSeed;
            const config = advancedVSeed.config?.[chartType]?.yAxis ?? {};
            if (!result.axes) result.axes = [];
            const isPivot = isPivotChart(vseed);
            const { visible = true, label, tick, title, grid, line, zero, nice, inverse, max, min, log, logBase = 10, autoFormat, numFormat = {} } = config;
            const formatter = createNumFormatter(numFormat);
            const percentFormatter = createNumFormatter({
                type: 'percent'
            });
            const linearAxis = {
                ...isPivot ? {
                    range: {
                        min,
                        max
                    }
                } : {
                    min,
                    max
                },
                visible,
                type: log ? 'log' : 'linear',
                base: logBase,
                orient: 'left',
                nice,
                zero: log ? false : zero,
                inverse,
                label: {
                    space: 8,
                    visible: label?.visible,
                    formatMethod: (value)=>{
                        if (isBarPercent(vseed) || isColumnPercent(vseed) || isAreaPercent(vseed)) return createLinearPercentFormat(value, autoFormat, numFormat, formatter, percentFormatter);
                        return createLinearFormat(value, autoFormat, numFormat, formatter);
                    },
                    style: {
                        fill: label?.labelColor,
                        angle: label?.labelAngle,
                        fontSize: label?.labelFontSize,
                        fontWeight: label?.labelFontWeight
                    }
                },
                title: {
                    visible: title?.visible,
                    text: title?.titleText || defaultTitleText(measures, dimensions, encoding.y),
                    style: {
                        fill: title?.titleColor,
                        fontSize: title?.titleFontSize,
                        fontWeight: title?.titleFontWeight
                    }
                },
                tick: {
                    visible: tick?.visible,
                    tickSize: tick?.tickSize,
                    inside: tick?.tickInside,
                    style: {
                        stroke: tick?.tickColor
                    }
                },
                grid: {
                    visible: grid?.visible,
                    style: {
                        lineWidth: grid?.gridWidth,
                        stroke: grid?.gridColor,
                        lineDash: grid?.gridLineDash
                    }
                },
                domainLine: {
                    visible: line?.visible,
                    style: {
                        lineWidth: line?.lineWidth,
                        stroke: line?.lineColor
                    }
                },
                innerOffset: {
                    top: 12
                }
            };
            result.axes = [
                ...result.axes,
                linearAxis
            ];
            return result;
        };
        const verticalCrosshairLine = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed, vseed } = context;
            const { chartType } = vseed;
            const config = advancedVSeed.config?.[chartType]?.crosshairLine;
            if (!config) return result;
            if (!result.crosshair) result.crosshair = {};
            const visible = config.visible || true;
            const lineColor = config.lineColor || void 0;
            const labelColor = config.labelColor || void 0;
            const labelVisible = config.labelVisible || void 0;
            const labelBackgroundColor = config.labelBackgroundColor || void 0;
            const crosshair = result.crosshair;
            crosshair.xField = {
                visible,
                line: {
                    type: 'line',
                    style: {
                        lineWidth: 1,
                        opacity: 1,
                        stroke: lineColor,
                        lineDash: config.lineDash ?? [
                            4,
                            2
                        ]
                    }
                },
                label: {
                    visible: labelVisible,
                    labelBackground: {
                        visible: labelVisible,
                        style: {
                            fill: labelBackgroundColor
                        }
                    },
                    style: {
                        fill: labelColor
                    }
                }
            };
            const xAxisConfig = result.axes?.find((v)=>'bottom' === v.orient);
            const xAxisFormatter = xAxisConfig?.label?.formatMethod;
            if (xAxisFormatter) crosshair.xField.label.formatMethod = (text)=>xAxisFormatter(text);
            return result;
        };
        const discreteLegend = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed } = context;
            const { datasetReshapeInfo, chartType } = advancedVSeed;
            const { unfoldInfo } = datasetReshapeInfo[0];
            const baseConfig = advancedVSeed.config[chartType];
            if (!baseConfig || !baseConfig.legend) return result;
            const { legend } = baseConfig;
            const { enable, position = 'bottom', labelFontColor, labelColor, labelFontSize = 12, pagerIconColor, pagerIconDisableColor, labelFontWeight, maxSize = 1, border, shapeType = 'rectRound' } = legend || {};
            const orient = [
                'bottom',
                'bottomLeft',
                'bottomRight',
                'bl',
                'br'
            ].includes(position) ? 'bottom' : [
                'top',
                'topLeft',
                'topRight',
                'tl',
                'tr'
            ].includes(position) ? 'top' : [
                'left',
                'leftTop',
                'leftBottom',
                'lt',
                'lb'
            ].includes(position) ? 'left' : 'right';
            const legendPosition = [
                'topLeft',
                'bottomLeft',
                'leftTop',
                'rightTop',
                'lt',
                'rt',
                'tl',
                'bl'
            ].includes(position) ? 'start' : [
                'topRight',
                'bottomRight',
                'leftBottom',
                'rightBottom',
                'lb',
                'rb',
                'rt',
                'br'
            ].includes(position) ? 'end' : 'middle';
            const labelTextColor = labelColor || labelFontColor;
            result.legends = {
                type: 'discrete',
                visible: enable,
                maxCol: Math.max(1, maxSize),
                maxRow: Math.max(1, maxSize),
                autoPage: true,
                orient,
                position: legendPosition,
                item: {
                    focus: true,
                    maxWidth: '30%',
                    focusIconStyle: {
                        size: labelFontSize + 2,
                        fill: labelTextColor,
                        fontWeight: labelFontWeight
                    },
                    shape: {
                        space: border ? 6 : 4,
                        style: (item)=>({
                                symbolType: shapeType,
                                size: border ? 8 : 10,
                                fillOpacity: 1,
                                opacity: 1,
                                stroke: false,
                                outerBorder: border ? {
                                    stroke: item.shape.fill,
                                    distance: 3,
                                    lineWidth: 1
                                } : null
                            }),
                        state: {
                            unSelected: {
                                opacity: 0.2,
                                fillOpacity: 1
                            }
                        }
                    },
                    label: {
                        formatMethod: (value)=>unfoldInfo.colorIdMap[String(value)]?.alias ?? value,
                        style: {
                            fontSize: labelFontSize,
                            fill: labelColor || labelFontColor,
                            fontWeight: labelFontWeight
                        },
                        state: {
                            unSelected: {
                                fill: labelColor || labelFontColor,
                                fillOpacity: 0.8
                            }
                        }
                    },
                    background: {
                        state: {
                            selectedHover: {
                                fill: labelColor || labelFontColor,
                                fillOpacity: 0.05
                            },
                            unSelectedHover: {
                                fill: null
                            }
                        }
                    }
                },
                pager: {
                    textStyle: {
                        fill: labelTextColor
                    },
                    handler: {
                        style: {
                            fill: pagerIconColor
                        },
                        state: {
                            disable: {
                                fill: pagerIconDisableColor
                            }
                        }
                    }
                },
                padding: 0
            };
            return result;
        };
        const colorLegend = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed } = context;
            const { datasetReshapeInfo, chartType, measures = [] } = advancedVSeed;
            const { unfoldInfo } = datasetReshapeInfo[0];
            const baseConfig = advancedVSeed.config[chartType];
            if (!baseConfig || !baseConfig.legend) return result;
            const { legend } = baseConfig;
            const { enable, position = 'bottom', labelFontColor, labelColor, labelFontSize = 12, labelFontWeight } = legend || {};
            const orient = [
                'bottom',
                'bottomLeft',
                'bottomRight',
                'bl',
                'br'
            ].includes(position) ? 'bottom' : [
                'top',
                'topLeft',
                'topRight',
                'tl',
                'tr'
            ].includes(position) ? 'top' : [
                'left',
                'leftTop',
                'leftBottom',
                'lt',
                'lb'
            ].includes(position) ? 'left' : 'right';
            const legendPosition = [
                'topLeft',
                'bottomLeft',
                'leftTop',
                'rightTop',
                'lt',
                'rt',
                'tl',
                'bl'
            ].includes(position) ? 'start' : [
                'topRight',
                'bottomRight',
                'leftBottom',
                'rightBottom',
                'lb',
                'rb',
                'rt',
                'br'
            ].includes(position) ? 'end' : 'middle';
            result.legends = {
                type: 'color',
                visible: enable,
                orient,
                position: legendPosition,
                padding: 0,
                field: unfoldInfo.encodingColor,
                maxWidth: '30%',
                handlerText: {
                    visible: true,
                    style: {
                        fill: labelColor || labelFontColor,
                        fontSize: labelFontSize,
                        fontWeight: labelFontWeight
                    }
                }
            };
            const colorMeasure = findTreeNodesBy(measures, (m)=>'color' === m.encoding)?.[0];
            if (colorMeasure) {
                const formatter = createFormatterByMeasure(colorMeasure);
                result.legends.handlerText.formatter = formatter;
            }
            return result;
        };
        const colorPointStyleFill = (stylePipe)=>(spec, context)=>{
                const result = stylePipe(spec, context);
                const { advancedVSeed, vseed } = context;
                const { datasetReshapeInfo } = advancedVSeed;
                const { unfoldInfo } = datasetReshapeInfo[0];
                if (isLinearColor(advancedVSeed, vseed)) {
                    if (result?.point?.style) result.point.style.fill = {
                        field: unfoldInfo.encodingColor,
                        scale: 'color'
                    };
                }
                return result;
            };
        const pointStyle_pointStyle = (spec, context)=>{
            const { advancedVSeed } = context;
            const { markStyle } = advancedVSeed;
            const { pointStyle } = markStyle;
            const result = {
                ...spec,
                point: {
                    style: {}
                }
            };
            if (chunk_JK3VNB42_n(pointStyle) || chunk_VCYTMP4D_n(pointStyle)) return result;
            const pointStyles = Array.isArray(pointStyle) ? pointStyle : [
                pointStyle
            ];
            const customMap = pointStyles.reduce((result, style, index)=>{
                const { pointBorderColor, pointBorderStyle, pointBorderWidth = 1, pointColor, pointColorOpacity, pointSize, pointVisible = true } = style;
                const lineDash = 'dashed' === pointBorderStyle ? [
                    5,
                    2
                ] : 'dotted' === pointBorderStyle ? [
                    2,
                    5
                ] : [
                    0,
                    0
                ];
                return {
                    ...result,
                    [`custom${index + 1}`]: {
                        level: index + 1,
                        filter: (datum)=>{
                            if (selector_selector(datum, style.selector)) return true;
                            return false;
                        },
                        style: {
                            visible: pointVisible,
                            size: pointSize,
                            fill: pointColor,
                            fillOpacity: pointColorOpacity,
                            innerBorder: {
                                stroke: pointBorderColor,
                                lineWidth: pointBorderWidth,
                                distance: (pointBorderWidth || 0) / 2,
                                lineDash: lineDash
                            }
                        }
                    }
                };
            }, {});
            return {
                ...result,
                point: {
                    ...result.point,
                    state: {
                        ...customMap
                    }
                }
            };
        };
        const pointStateDimensionHover = (spec)=>{
            const point = spec.point || {};
            const result = {
                ...spec,
                point: {
                    ...point,
                    state: {
                        ...point.state || {},
                        dimension_hover: {
                            scaleX: 1.4,
                            scaleY: 1.4,
                            outerBorder: {
                                lineWidth: 4,
                                strokeOpacity: 0.25,
                                distance: 2
                            }
                        }
                    }
                }
            };
            return result;
        };
        const pointStateHover = (spec, context)=>{
            const point = spec.point || {};
            const { advancedVSeed } = context;
            const { datasetReshapeInfo } = advancedVSeed;
            const { unfoldInfo } = datasetReshapeInfo[0];
            const result = {
                ...spec,
                point: {
                    ...point,
                    state: {
                        ...point.state || {},
                        hover: {
                            scaleX: 1.4,
                            scaleY: 1.4,
                            stroke: (datum, context)=>{
                                const field = unfoldInfo.encodingColorId;
                                const color = context.seriesColor(datum[field]);
                                return color;
                            },
                            fillOpacity: 0.6,
                            lineWidth: 1
                        }
                    }
                }
            };
            return result;
        };
        const colorLineStyleFill = (stylePipe)=>(spec, context)=>{
                const result = stylePipe(spec, context);
                const { advancedVSeed, vseed } = context;
                const { datasetReshapeInfo } = advancedVSeed;
                const { unfoldInfo } = datasetReshapeInfo[0];
                if (isLinearColor(advancedVSeed, vseed)) {
                    if (result?.line?.style) result.line.style.stroke = {
                        field: unfoldInfo.encodingColor,
                        scale: 'color'
                    };
                }
                return result;
            };
        const getCurveType = (vseed, lineSmooth = false)=>{
            if (!lineSmooth) return 'linear';
            return isRadar(vseed) ? 'catmullRomClosed' : 'monotone';
        };
        const getCurveTension = (vseed, lineSmooth = false)=>{
            if (!lineSmooth) return 0;
            return isRadar(vseed) ? 0.4 : 0;
        };
        const lineStyle_lineStyle = (spec, context)=>{
            const { advancedVSeed } = context;
            const { markStyle } = advancedVSeed;
            const { lineStyle } = markStyle;
            const result = {
                ...spec,
                line: {
                    style: {}
                }
            };
            if (chunk_JK3VNB42_n(lineStyle) || chunk_VCYTMP4D_n(lineStyle)) return result;
            const lineStyles = Array.isArray(lineStyle) ? lineStyle : [
                lineStyle
            ];
            const customMap = lineStyles.reduce((result, style, index)=>{
                const { lineColor, lineColorOpacity, lineSmooth, lineStyle, lineWidth = 2, lineVisible = true } = style;
                const dashSegment = 2 * lineWidth;
                const dashGap = lineWidth;
                const lineDash = 'dashed' === lineStyle ? [
                    dashSegment,
                    dashSegment
                ] : 'dotted' === lineStyle ? [
                    dashGap / 2,
                    2 * dashGap
                ] : [
                    0,
                    0
                ];
                const curveType = getCurveType(context.vseed, lineSmooth);
                const curveTension = getCurveTension(context.vseed, lineSmooth);
                return {
                    ...result,
                    [`custom${index + 1}`]: {
                        level: index + 1,
                        filter: (_, node)=>{
                            const lineData = node.renderNode.context.data;
                            for (const d of lineData)if (selector_selector(d, style.selector)) return true;
                            return false;
                        },
                        style: {
                            visible: lineVisible,
                            curveType: curveType,
                            curveTension: curveTension,
                            strokeOpacity: lineColorOpacity,
                            stroke: lineColor,
                            lineWidth: lineWidth,
                            lineDash: lineDash
                        }
                    }
                };
            }, {});
            return {
                ...result,
                line: {
                    ...result.line,
                    state: {
                        ...customMap
                    }
                }
            };
        };
        const label_label = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed, vseed } = context;
            const { datasetReshapeInfo } = advancedVSeed;
            const { chartType, encoding } = advancedVSeed;
            const baseConfig = advancedVSeed.config[chartType];
            const foldInfo = datasetReshapeInfo[0].foldInfo;
            const { label } = baseConfig;
            result.label = buildLabel(label, vseed.measures, vseed.dimensions, advancedVSeed.dimensions, advancedVSeed.measures, encoding, [
                foldInfo
            ]);
            return result;
        };
        const generateMeasureValue = (value, measure, labelAutoFormat, numFormat = {})=>{
            const format = chunk_5S4PYKVY_t(numFormat, measure.numFormat || measure.format);
            const mergedMeasure = {
                ...measure,
                numFormat: format,
                autoFormat: labelAutoFormat || measure.autoFormat
            };
            const formatter = createFormatterByMeasure(mergedMeasure);
            return formatter(value);
        };
        const generateMeasurePercent = (value, sum, formatter)=>{
            if (null == value) return String(value);
            const num = Number(value);
            if (Number.isNaN(num)) return String(value);
            const percentValue = num / sum;
            return formatter(percentValue);
        };
        const buildLabel = (label, vseedMeasures = [], vseedDimensions = [], advancedVSeedDimensions, advancedVSeedMeasures, encoding, foldInfoList)=>{
            const { enable, wrap, showValue, showValuePercent, showDimension, labelOverlap, labelColorSmartInvert, labelStroke, labelColor, labelFontSize, labelFontWeight, labelBackgroundColor, labelPosition, autoFormat, numFormat = {} } = label;
            const hasDimLabelEncoding = vseedDimensions.some((item)=>encoding.label?.includes(item.id));
            const labelDims = T(hasDimLabelEncoding ? vseedDimensions.filter((item)=>encoding.label?.includes(item.id)) : showDimension ? advancedVSeedDimensions.filter((d)=>d.id !== MeasureId) : [], (item)=>item.id);
            const labelMeas = T(vseedMeasures.filter((item)=>encoding.label?.includes(item.id)), (item)=>item.id);
            const percentFormat = chunk_5S4PYKVY_t(numFormat, {
                type: 'percent'
            });
            const percentFormatter = createFormatter(percentFormat);
            const result = {
                visible: enable,
                dataFilter: (data)=>data.filter((entry)=>entry.data?.[DATUM_HIDE_KEY] !== true && selector_selector(entry.data, label.selector, 'Or')),
                formatMethod: (_, datum)=>{
                    const result = [];
                    const dimLabels = labelDims.map((item)=>{
                        const id = item.id;
                        return datum[id];
                    });
                    const meaLabels = labelMeas.map((item)=>generateMeasureValue(datum[item.id], item, autoFormat, numFormat));
                    result.push(...dimLabels);
                    foldInfoList.forEach((foldInfo)=>{
                        const { measureId, measureValue, statistics } = foldInfo;
                        const measure = findMeasureById(advancedVSeedMeasures, datum[measureId]);
                        if (measure) {
                            const measureValueLabel = generateMeasureValue(datum[measureValue], measure, autoFormat, numFormat);
                            const measurePercentLabel = chunk_6GTAPB47_e(datum['__VCHART_ARC_RATIO']) ? generateMeasurePercent(datum['__VCHART_ARC_RATIO'], 1, percentFormatter) : generateMeasurePercent(datum[measureValue], statistics.sum, percentFormatter);
                            if (showValue) result.push(measureValueLabel);
                            if (showValuePercent) result.push(measurePercentLabel);
                        }
                    });
                    result.push(...meaLabels);
                    if (wrap) return result;
                    return result.join(' ');
                },
                position: labelPosition,
                style: {
                    stroke: labelStroke,
                    fill: labelColor,
                    fontSize: labelFontSize,
                    fontWeight: labelFontWeight,
                    background: labelBackgroundColor
                },
                smartInvert: labelColorSmartInvert
            };
            if (labelOverlap) result.overlap = {
                hideOnHit: true,
                clampForce: true
            };
            return result;
        };
        const getTooltipStyle = (tooltipConfig)=>({
                panel: {
                    padding: tooltipConfig.padding,
                    border: {
                        radius: tooltipConfig.borderRadius,
                        width: tooltipConfig.borderWidth,
                        color: tooltipConfig.borderColor
                    },
                    backgroundColor: tooltipConfig.backgroundColor
                },
                keyLabel: {
                    lineHeight: tooltipConfig.lineHeight,
                    fontSize: tooltipConfig.fontSize,
                    fontColor: tooltipConfig.keyColor
                },
                valueLabel: {
                    lineHeight: tooltipConfig.lineHeight,
                    fontSize: tooltipConfig.fontSize,
                    fontColor: tooltipConfig.valueColor,
                    fontWeight: 'medium'
                },
                titleLabel: {
                    fontSize: tooltipConfig.fontSize,
                    lineHeight: tooltipConfig.lineHeight,
                    fontColor: tooltipConfig.titleColor,
                    fontWeight: 'bold'
                }
            });
        const tooltip_tooltip = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed, vseed } = context;
            const { measures, datasetReshapeInfo, chartType, dimensions, encoding } = advancedVSeed;
            const baseConfig = advancedVSeed.config[chartType];
            const { tooltip = {
                enable: true
            } } = baseConfig;
            const { enable = true } = tooltip;
            const { foldInfo, unfoldInfo } = datasetReshapeInfo[0];
            result.tooltip = {
                style: getTooltipStyle(tooltip),
                visible: !!enable,
                mark: {
                    title: {
                        visible: false
                    },
                    content: createMarkContent(encoding.tooltip || [], dimensions, findAllMeasures(vseed.measures), foldInfo, unfoldInfo)
                },
                dimension: {
                    title: {
                        visible: true
                    },
                    content: createDimensionContent(dimensions, measures, foldInfo, unfoldInfo)
                }
            };
            return result;
        };
        const createDimensionContent = (dimensions, measures, foldInfo, unfoldInfo)=>{
            const { measureId, measureValue, foldMap } = foldInfo;
            const { encodingColor } = unfoldInfo;
            return [
                {
                    visible: true,
                    shapeType: 'rectRound',
                    hasShape: true,
                    key: dimensions.some((d)=>'color' === d.encoding) ? (v)=>{
                        const datum = v;
                        const key = datum && datum[encodingColor] || '';
                        return unfoldInfo.colorIdMap[key].alias ?? key;
                    } : (v)=>{
                        const datum = v;
                        const key = datum && datum[measureId] || '';
                        return foldMap[key] ?? key;
                    },
                    value: (v)=>{
                        const datum = v;
                        if (!datum) return '';
                        const value = datum[measureValue];
                        const id = datum[measureId];
                        const measure = findMeasureById(measures, id);
                        const formatter = createFormatterByMeasure(measure);
                        return formatter(value);
                    }
                }
            ];
        };
        const createMarkContent = (tooltip, dimensions, measures, foldInfo, unfoldInfo)=>{
            const dims = C(dimensions.filter((item)=>tooltip.includes(item.id)), T((item)=>item.id), T((item)=>item.alias));
            const meas = C(measures.filter((item)=>tooltip.includes(item.id)), T((item)=>item.id), T((item)=>item.alias));
            const dimContent = dims.map((item)=>({
                    visible: true,
                    hasShape: true,
                    shapeType: 'rectRound',
                    key: (v)=>{
                        const datum = v;
                        if (item.alias || item.id) return item.alias || item.id;
                        return datum && datum[item.id];
                    },
                    value: (v)=>{
                        const datum = v;
                        return datum && datum[item.id];
                    }
                }));
            const meaContent = meas.map((item)=>({
                    visible: true,
                    hasShape: true,
                    shapeType: 'rectRound',
                    key: item.alias || item.id,
                    value: (v)=>{
                        const datum = v;
                        if (!datum) return '';
                        const id = item.id;
                        if (!datum || !datum[ORIGINAL_DATA] || !datum[ORIGINAL_DATA]) return '';
                        const originalData = datum[ORIGINAL_DATA];
                        const value = originalData[id];
                        const measure = findMeasureById(measures, id);
                        const formatter = createFormatterByMeasure(measure);
                        return formatter(value);
                    }
                }));
            const defaultContent = {
                visible: true,
                hasShape: true,
                shapeType: 'rectRound',
                key: (v)=>{
                    const { measureName } = foldInfo;
                    const { encodingColor: colorName } = unfoldInfo;
                    const datum = v;
                    return datum && datum[measureName || colorName] || '';
                },
                value: (v)=>{
                    const { measureId, measureValue } = foldInfo;
                    const datum = v;
                    if (!datum) return '';
                    const value = datum[measureValue];
                    const id = datum[measureId];
                    const measure = findMeasureById(measures, id);
                    if (!measure) return String(value);
                    const formatter = createFormatterByMeasure(measure);
                    return formatter(value);
                }
            };
            return [
                ...dimContent,
                defaultContent,
                ...meaContent
            ];
        };
        const isSubset = (sub, obj, excludeMeasuresIds)=>Object.entries(sub).every(([key, value])=>{
                if (excludeMeasuresIds && excludeMeasuresIds.includes(key)) return false;
                if ('string' == typeof value) return obj[key] === value;
                if ('number' == typeof value) return obj[key] === value;
                return true;
            });
        const ANNOTATION_AREA_TEXT_STYLE_BY_POSITION = {
            top: {
                textAlign: 'center',
                textBaseline: 'top'
            },
            topRight: {
                textAlign: 'right',
                textBaseline: 'top'
            },
            topLeft: {
                textAlign: 'left',
                textBaseline: 'top'
            },
            bottom: {
                textAlign: 'center',
                textBaseline: 'bottom'
            },
            bottomLeft: {
                textAlign: 'left',
                textBaseline: 'bottom'
            },
            bottomRight: {
                textAlign: 'right',
                textBaseline: 'bottom'
            },
            left: {
                textAlign: 'left',
                textBaseline: 'middle'
            },
            right: {
                textAlign: 'right',
                textBaseline: 'middle'
            }
        };
        const generateAnnotationPointPipe = (options)=>{
            const findSelectedDatas = options.findSelectedDatas ?? ((dataset, s)=>dataset.filter((datum)=>selector_selector(datum, s)));
            const generateMarkPoint = options.generateMarkPoint ?? ((datum)=>[
                    {
                        coordinate: (data)=>data.find((item)=>isSubset(datum, item))
                    }
                ]);
            return (spec, context)=>{
                const { advancedVSeed, vseed } = context;
                const { annotation, config } = advancedVSeed;
                if (!annotation || !annotation.annotationPoint) return spec;
                const theme = config?.[vseed.chartType]?.annotation?.annotationPoint;
                const { annotationPoint } = annotation;
                const annotationPointList = Array.isArray(annotationPoint) ? annotationPoint : [
                    annotationPoint
                ];
                const isHorizontalBar = isBarLikeChart(advancedVSeed);
                const defaultStyle = isHorizontalBar ? {
                    textAlign: 'right',
                    textBaseline: 'middle'
                } : {
                    textAlign: 'center',
                    textBaseline: 'top'
                };
                const markPoint = annotationPointList.flatMap((annotationPoint)=>{
                    const { selector: selectorPoint, text = '', textColor = theme?.textColor ?? '#ffffff', textFontSize = theme?.textFontSize ?? 12, textFontWeight = theme?.textFontWeight ?? 400, textAlign = defaultStyle.textAlign, textBaseline = defaultStyle.textBaseline, textBackgroundBorderColor = theme?.textBackgroundBorderColor, textBackgroundBorderRadius = theme?.textBackgroundBorderRadius ?? 4, textBackgroundBorderWidth = theme?.textBackgroundBorderWidth ?? 1, textBackgroundColor = theme?.textBackgroundColor ?? '#212121', textBackgroundPadding = theme?.textBackgroundPadding ?? 2, textBackgroundVisible = theme?.textBackgroundVisible ?? true, offsetX = theme?.offsetX ?? 0, offsetY = theme?.offsetY ?? 0 } = annotationPoint;
                    const dataset = advancedVSeed.dataset.flat();
                    const selectedData = selectorPoint ? findSelectedDatas(dataset, selectorPoint, spec, context) : [];
                    const dx = -10 - (isHorizontalBar ? textFontSize : 0);
                    const dy = isHorizontalBar ? 0 : textFontSize;
                    const markPointStyle = {
                        zIndex: 1000,
                        regionRelative: true,
                        itemLine: {
                            visible: false
                        },
                        itemContent: {
                            offsetY,
                            offsetX,
                            confine: true,
                            text: {
                                text: text,
                                style: {
                                    opacity: 0.95,
                                    visible: true,
                                    textAlign: textAlign,
                                    textBaseline: textBaseline,
                                    fill: textColor,
                                    stroke: textBackgroundColor,
                                    lineWidth: 1,
                                    fontSize: textFontSize,
                                    fontWeight: textFontWeight,
                                    dx,
                                    dy
                                },
                                labelBackground: {
                                    visible: textBackgroundVisible,
                                    padding: textBackgroundPadding,
                                    style: {
                                        opacity: 0.95,
                                        cornerRadius: textBackgroundBorderRadius ?? 4,
                                        fill: textBackgroundColor,
                                        stroke: textBackgroundBorderColor,
                                        lineWidth: textBackgroundBorderWidth,
                                        dx,
                                        dy
                                    }
                                }
                            }
                        }
                    };
                    return selectedData.reduce((res, datum)=>{
                        const marks = generateMarkPoint(datum, spec, context);
                        if (marks && marks.length) marks.forEach((mark)=>{
                            res.push({
                                ...markPointStyle,
                                ...mark
                            });
                        });
                        return res;
                    }, []);
                });
                return {
                    ...spec,
                    markPoint
                };
            };
        };
        const annotationPoint_annotationPoint = generateAnnotationPointPipe({});
        function chunk_BO3LQZNF_o(r) {
            return Array.isArray(r);
        }
        const annotationVerticalLine_annotationVerticalLine = (spec, context)=>{
            const { advancedVSeed, vseed } = context;
            const { annotation, datasetReshapeInfo, config } = advancedVSeed;
            const { unfoldInfo, foldInfo } = datasetReshapeInfo[0];
            if (!annotation || !annotation.annotationVerticalLine) return spec;
            const theme = config?.[vseed.chartType]?.annotation?.annotationVerticalLine;
            const { annotationVerticalLine } = annotation;
            const annotationVerticalLineList = Array.isArray(annotationVerticalLine) ? annotationVerticalLine : [
                annotationVerticalLine
            ];
            const positionMap = {
                outsideStart: 'start',
                outsideEnd: 'end',
                outsideMiddle: 'middle',
                insideStart: 'insideStartTop',
                insideMiddle: 'insideMiddleTop',
                insideEnd: 'insideEndTop'
            };
            const markLine = annotationVerticalLineList.flatMap((annotationVerticalLine)=>{
                const { selector: selectorPoint, xValue, text = '', textPosition = 'insideEnd', textColor = theme?.textColor ?? '#ffffff', textFontSize = theme?.textFontSize ?? 12, textFontWeight = theme?.textFontWeight ?? 400, textAlign = 'center', textBaseline = 'top', lineColor = theme?.lineColor ?? '#212121', lineStyle = theme?.lineStyle ?? 'dashed', lineVisible = theme?.lineStyle ?? true, lineWidth = theme?.lineWidth ?? 1, textBackgroundVisible = theme?.textBackgroundVisible ?? true, textBackgroundColor = theme?.textBackgroundColor ?? '#212121', textBackgroundBorderColor = theme?.textBackgroundBorderColor ?? '#212121', textBackgroundBorderRadius = theme?.textBackgroundBorderRadius ?? 4, textBackgroundBorderWidth = theme?.textBackgroundBorderWidth ?? 1, textBackgroundPadding = theme?.textBackgroundPadding ?? 2 } = annotationVerticalLine;
                const dataset = advancedVSeed.dataset.flat();
                const generateOneMarkLine = (x)=>({
                        x,
                        autoRange: true,
                        zIndex: 1000,
                        line: {
                            style: {
                                visible: lineVisible,
                                stroke: lineColor,
                                lineStyle: lineStyle,
                                lineWidth: lineWidth,
                                lineDash: 'dashed' === lineStyle ? [
                                    5,
                                    2
                                ] : 'dotted' === lineStyle ? [
                                    2,
                                    5
                                ] : [
                                    0
                                ]
                            }
                        },
                        label: {
                            confine: true,
                            text: text,
                            position: positionMap[textPosition || 'insideEnd'],
                            style: {
                                opacity: 0.95,
                                dx: 5,
                                visible: true,
                                stroke: textBackgroundColor,
                                lineWidth: 1,
                                textAlign: textAlign,
                                textBaseline: textBaseline,
                                fill: textColor,
                                fontSize: textFontSize,
                                fontWeight: textFontWeight
                            },
                            labelBackground: {
                                visible: textBackgroundVisible,
                                padding: textBackgroundPadding,
                                style: {
                                    opacity: 0.95,
                                    dx: 5,
                                    cornerRadius: textBackgroundBorderRadius,
                                    fill: textBackgroundColor,
                                    fillOpacity: 1,
                                    stroke: textBackgroundBorderColor,
                                    lineWidth: textBackgroundBorderWidth
                                }
                            }
                        },
                        startSymbol: {
                            visible: theme?.startSymbolVisible ?? true,
                            symbolType: theme?.startSymbolType ?? 'triangleDown',
                            size: 5 + (lineWidth || 1),
                            style: {
                                dy: -3,
                                fill: lineColor
                            }
                        },
                        endSymbol: {
                            visible: theme?.endSymbolVisible ?? false,
                            symbolType: theme?.endSymbolType ?? 'arrow',
                            size: 10 + (lineWidth || 1),
                            style: {
                                dy: 4,
                                fill: lineColor
                            }
                        }
                    });
                if (!selectorPoint && chunk_BO3LQZNF_o(xValue) || chunk_SFZGYJFI_t(xValue) || chunk_6GTAPB47_e(xValue)) {
                    const xValueArr = Array.isArray(xValue) ? xValue : [
                        xValue
                    ];
                    return xValueArr.map(generateOneMarkLine);
                }
                const selectedData = selectorPoint ? dataset.filter((datum)=>selector_selector(datum, selectorPoint)) : [];
                return selectedData.map((datum)=>{
                    if (datum[unfoldInfo.encodingX]) return generateOneMarkLine(datum[unfoldInfo.encodingX]);
                    if (datum[foldInfo.measureValue]) return generateOneMarkLine(datum[foldInfo.measureValue]);
                    return {};
                });
            });
            const specMarkLine = spec.markLine || [];
            const newMarkLine = [
                ...specMarkLine,
                ...markLine || []
            ];
            return {
                ...spec,
                markLine: newMarkLine
            };
        };
        const annotationHorizontalLine_annotationHorizontalLine = (spec, context)=>{
            const { advancedVSeed, vseed } = context;
            const { annotation, datasetReshapeInfo, config } = advancedVSeed;
            const { foldInfo, unfoldInfo } = datasetReshapeInfo[0];
            if (!annotation || !annotation.annotationHorizontalLine) return spec;
            const theme = config?.[vseed.chartType]?.annotation?.annotationHorizontalLine;
            const { annotationHorizontalLine } = annotation;
            const annotationHorizontalLineList = Array.isArray(annotationHorizontalLine) ? annotationHorizontalLine : [
                annotationHorizontalLine
            ];
            const positionMap = {
                outsideStart: 'start',
                outsideEnd: 'end',
                outsideMiddle: 'middle',
                insideStart: 'insideStartTop',
                insideMiddle: 'insideMiddleTop',
                insideEnd: 'insideEndTop'
            };
            const markLine = annotationHorizontalLineList.flatMap((annotationHorizontalLine)=>{
                const { selector: selectorPoint, yValue, text = '', textPosition = 'insideEnd', textColor = theme?.textColor ?? '#ffffff', textFontSize = theme?.textFontSize ?? 12, textFontWeight = theme?.textFontWeight ?? 400, textAlign = 'right', textBaseline = 'bottom', lineColor = theme?.lineColor ?? '#212121', lineStyle = theme?.lineStyle ?? 'dashed', lineVisible = theme?.lineStyle ?? true, lineWidth = theme?.lineWidth ?? 1, textBackgroundVisible = theme?.textBackgroundVisible ?? true, textBackgroundColor = theme?.textBackgroundColor ?? '#212121', textBackgroundBorderColor = theme?.textBackgroundBorderColor ?? '#212121', textBackgroundBorderRadius = theme?.textBackgroundBorderRadius ?? 4, textBackgroundBorderWidth = theme?.textBackgroundBorderWidth ?? 1, textBackgroundPadding = theme?.textBackgroundPadding ?? 2 } = annotationHorizontalLine;
                const dataset = advancedVSeed.dataset.flat();
                const generateOneMarkLine = (y)=>({
                        y,
                        autoRange: true,
                        zIndex: 1000,
                        line: {
                            style: {
                                visible: lineVisible,
                                stroke: lineColor,
                                lineWidth: lineWidth,
                                lineDash: 'dashed' === lineStyle ? [
                                    5,
                                    2
                                ] : 'dotted' === lineStyle ? [
                                    2,
                                    5
                                ] : [
                                    0
                                ]
                            }
                        },
                        label: {
                            confine: true,
                            text: text,
                            position: positionMap[textPosition || 'insideEnd'],
                            style: {
                                opacity: 0.95,
                                visible: true,
                                dy: 4,
                                stroke: textBackgroundColor,
                                lineWidth: 1,
                                textAlign: textAlign,
                                textBaseline: textBaseline,
                                fill: textColor,
                                fontSize: textFontSize,
                                fontWeight: textFontWeight
                            },
                            labelBackground: {
                                visible: textBackgroundVisible,
                                padding: textBackgroundPadding,
                                style: {
                                    opacity: 0.95,
                                    dy: 4,
                                    cornerRadius: textBackgroundBorderRadius,
                                    fill: textBackgroundColor,
                                    stroke: textBackgroundBorderColor,
                                    lineWidth: textBackgroundBorderWidth,
                                    fillOpacity: 1
                                }
                            }
                        },
                        startSymbol: {
                            visible: theme?.startSymbolVisible ?? true,
                            symbolType: theme?.startSymbolType ?? 'triangleDown',
                            size: 5 + (lineWidth || 1),
                            style: {
                                dx: 3,
                                fill: lineColor
                            }
                        },
                        endSymbol: {
                            visible: theme?.endSymbolVisible ?? false,
                            symbolType: theme?.endSymbolType ?? 'arrow',
                            size: 10 + (lineWidth || 1),
                            style: {
                                dx: -4,
                                fill: lineColor
                            }
                        }
                    });
                if (!selectorPoint && chunk_BO3LQZNF_o(yValue) || chunk_SFZGYJFI_t(yValue) || chunk_6GTAPB47_e(yValue)) {
                    const yValueArr = Array.isArray(yValue) ? yValue : [
                        yValue
                    ];
                    return yValueArr.map(generateOneMarkLine);
                }
                const selectedData = selectorPoint ? dataset.filter((datum)=>selector_selector(datum, selectorPoint)) : [];
                return selectedData.map((datum)=>{
                    if (datum[unfoldInfo.encodingY]) return generateOneMarkLine(datum[unfoldInfo.encodingY]);
                    if (datum[foldInfo.measureValue]) return generateOneMarkLine(datum[foldInfo.measureValue]);
                    return {};
                });
            });
            const specMarkLine = spec.markLine || [];
            const newMarkLine = [
                ...specMarkLine,
                ...markLine || []
            ];
            return {
                ...spec,
                markLine: newMarkLine
            };
        };
        const annotationArea_annotationArea = (spec, context)=>{
            const { advancedVSeed, vseed } = context;
            const { annotation, config } = advancedVSeed;
            if (!annotation || !annotation.annotationArea) return spec;
            const theme = config?.[vseed.chartType]?.annotation?.annotationArea;
            const { annotationArea } = annotation;
            const annotationAreaList = Array.isArray(annotationArea) ? annotationArea : [
                annotationArea
            ];
            const positionMap = {
                top: 'insideTop',
                topRight: 'insideTopRight',
                topLeft: 'insideTopLeft',
                bottom: 'insideBottom',
                bottomLeft: 'insideBottomLeft',
                bottomRight: 'insideBottomRight',
                left: 'insideLeft',
                right: 'insideRight'
            };
            const defaultTextPosition = isBarLikeChart(advancedVSeed) ? 'right' : 'top';
            const markArea = annotationAreaList.flatMap((annotationArea)=>{
                const { selector: selectorPoint, text = '', textColor = theme?.textColor ?? '#ffffff', textFontSize = theme?.textFontSize ?? 12, textFontWeight = theme?.textFontWeight ?? 400, textBackgroundVisible = theme?.textBackgroundVisible ?? true, textBackgroundColor = theme?.textBackgroundColor ?? '#191d24', textBackgroundBorderColor = theme?.textBackgroundBorderColor ?? '#191d24', textBackgroundBorderWidth = theme?.textBackgroundBorderWidth ?? 1, textBackgroundBorderRadius = theme?.textBackgroundBorderRadius ?? 4, textBackgroundPadding = theme?.textBackgroundPadding ?? 4, areaColor = theme?.areaColor ?? '#888888', areaColorOpacity = theme?.areaColorOpacity ?? 0.15, areaBorderColor = theme?.areaBorderColor ?? '#888888', areaBorderRadius = theme?.areaBorderRadius ?? 4, areaBorderWidth = theme?.areaBorderWidth ?? 1, areaLineDash = theme?.areaLineDash, outerPadding = theme?.outerPadding ?? 4 } = annotationArea;
                const dataset = advancedVSeed.dataset.flat();
                const selectedData = selectorPoint ? dataset.filter((datum)=>selector_selector(datum, selectorPoint)) : [];
                const textPosition = annotationArea.textPosition ?? defaultTextPosition;
                const textAlign = annotationArea.textAlign ?? ANNOTATION_AREA_TEXT_STYLE_BY_POSITION[textPosition].textAlign;
                const textBaseline = annotationArea.textBaseline ?? ANNOTATION_AREA_TEXT_STYLE_BY_POSITION[textPosition].textBaseline;
                return {
                    zIndex: 1000,
                    regionRelative: true,
                    positions: (data, context)=>{
                        const positionData = data.filter((item)=>selectedData.some((datum)=>isSubset(datum, item)));
                        const xyList = positionData.map((datum)=>context.dataToPosition(datum));
                        const yAxisHelper = context.getYAxisHelper();
                        const xAxisHelper = context.getXAxisHelper();
                        if ('function' == typeof xAxisHelper?.getBandwidth) {
                            const regionRect = context.getRegion().getLayoutRect();
                            const minX = Math.min(...xyList.map((item)=>item.x)) - (outerPadding || 4);
                            const maxX = Math.max(...xyList.map((item)=>item.x)) + (outerPadding || 4);
                            const minY = 0;
                            const maxY = regionRect.height;
                            return [
                                {
                                    x: minX,
                                    y: minY
                                },
                                {
                                    x: maxX,
                                    y: minY
                                },
                                {
                                    x: maxX,
                                    y: maxY
                                },
                                {
                                    x: minX,
                                    y: maxY
                                }
                            ];
                        }
                        if ('function' == typeof yAxisHelper?.getBandwidth) {
                            const regionRect = context.getRegion().getLayoutRect();
                            const minY = Math.min(...xyList.map((item)=>item.y)) - (outerPadding || 4);
                            const maxY = Math.max(...xyList.map((item)=>item.y)) + (outerPadding || 4);
                            const minX = 0;
                            const maxX = regionRect.width;
                            return [
                                {
                                    x: minX,
                                    y: minY
                                },
                                {
                                    x: maxX,
                                    y: minY
                                },
                                {
                                    x: maxX,
                                    y: maxY
                                },
                                {
                                    x: minX,
                                    y: maxY
                                }
                            ];
                        }
                        return [];
                    },
                    label: {
                        position: positionMap[textPosition],
                        visible: true,
                        text: text,
                        style: {
                            opacity: 0.95,
                            textAlign: textAlign,
                            textBaseline: textBaseline,
                            fill: textColor,
                            stroke: textBackgroundColor,
                            lineWidth: 1,
                            fontSize: textFontSize,
                            fontWeight: textFontWeight
                        },
                        labelBackground: {
                            visible: textBackgroundVisible,
                            padding: textBackgroundPadding,
                            style: {
                                opacity: 0.95,
                                cornerRadius: textBackgroundBorderRadius ?? 4,
                                fill: textBackgroundColor,
                                stroke: textBackgroundBorderColor,
                                lineWidth: textBackgroundBorderWidth,
                                fillOpacity: 1
                            }
                        }
                    },
                    area: {
                        style: {
                            visible: true,
                            fill: areaColor,
                            fillOpacity: areaColorOpacity,
                            stroke: areaBorderColor,
                            lineWidth: areaBorderWidth,
                            cornerRadius: areaBorderRadius,
                            lineDash: areaLineDash
                        }
                    }
                };
            });
            return {
                ...spec,
                markArea: markArea
            };
        };
        const isNumber = (value, fuzzy = !1)=>{
            const type = typeof value;
            return fuzzy ? "number" === type : "number" === type || common_isType(value, "Number");
        };
        const common_isNumber = isNumber;
        const isNil = (value)=>null == value;
        const common_isNil = isNil;
        const clamp = function(input, min, max) {
            return input < min ? min : input > max ? max : input;
        };
        const common_clamp = clamp;
        function hslToRgb(h, s, l) {
            s /= 100, l /= 100;
            const c = (1 - Math.abs(2 * l - 1)) * s, x = c * (1 - Math.abs(h / 60 % 2 - 1)), m = l - c / 2;
            let r = 0, g = 0, b = 0;
            return 0 <= h && h < 60 ? (r = c, g = x, b = 0) : 60 <= h && h < 120 ? (r = x, g = c, b = 0) : 120 <= h && h < 180 ? (r = 0, g = c, b = x) : 180 <= h && h < 240 ? (r = 0, g = x, b = c) : 240 <= h && h < 300 ? (r = x, g = 0, b = c) : 300 <= h && h < 360 && (r = c, g = 0, b = x), r = Math.round(255 * (r + m)), g = Math.round(255 * (g + m)), b = Math.round(255 * (b + m)), {
                r: r,
                g: g,
                b: b
            };
        }
        function rgbToHsl(r, g, b) {
            r /= 255, g /= 255, b /= 255;
            const cMin = Math.min(r, g, b), cMax = Math.max(r, g, b), delta = cMax - cMin;
            let h = 0, s = 0, l = 0;
            return h = 0 === delta ? 0 : cMax === r ? (g - b) / delta % 6 : cMax === g ? (b - r) / delta + 2 : (r - g) / delta + 4, h = Math.round(60 * h), h < 0 && (h += 360), l = (cMax + cMin) / 2, s = 0 === delta ? 0 : delta / (1 - Math.abs(2 * l - 1)), s = +(100 * s).toFixed(1), l = +(100 * l).toFixed(1), {
                h: h,
                s: s,
                l: l
            };
        }
        const REG_HEX = /^#([0-9a-f]{3,8})$/, DEFAULT_COLORS_OPACITY = {
            transparent: 4294967040
        };
        const DEFAULT_COLORS = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
        };
        function Color_hex(value) {
            return ((value = Math.max(0, Math.min(255, Math.round(value) || 0))) < 16 ? "0" : "") + value.toString(16);
        }
        function Color_rgb(value) {
            return common_isNumber(value) ? new RGB(value >> 16, value >> 8 & 255, 255 & value, 1) : common_isArray(value) ? new RGB(value[0], value[1], value[2]) : new RGB(255, 255, 255);
        }
        function rgba(value) {
            return common_isNumber(value) ? new RGB(value >>> 24, value >>> 16 & 255, value >>> 8 & 255, 255 & value) : common_isArray(value) ? new RGB(value[0], value[1], value[2], value[3]) : new RGB(255, 255, 255, 1);
        }
        function SRGBToLinear(c) {
            return c < .04045 ? .0773993808 * c : Math.pow(.9478672986 * c + .0521327014, 2.4);
        }
        function LinearToSRGB(c) {
            return c < .0031308 ? 12.92 * c : 1.055 * Math.pow(c, .41666) - .055;
        }
        const setHex = (formatValue, forceHex)=>{
            const isHex = REG_HEX.exec(formatValue);
            if (forceHex || isHex) {
                const hex = parseInt(isHex[1], 16), hexLength = isHex[1].length;
                return 3 === hexLength ? new RGB((hex >> 8 & 15) + ((hex >> 8 & 15) << 4), (hex >> 4 & 15) + ((hex >> 4 & 15) << 4), (15 & hex) + ((15 & hex) << 4), 1) : 6 === hexLength ? Color_rgb(hex) : 8 === hexLength ? new RGB(hex >> 24 & 255, hex >> 16 & 255, hex >> 8 & 255, (255 & hex) / 255) : null;
            }
        };
        class Color {
            static Brighter(source, b = 1) {
                return 1 === b ? source : new Color(source).brighter(b).toRGBA();
            }
            static SetOpacity(source, o = 1) {
                return 1 === o ? source : new Color(source).setOpacity(o).toRGBA();
            }
            static getColorBrightness(source, model = "hsl") {
                const color = source instanceof Color ? source : new Color(source);
                switch(model){
                    case "hsv":
                    default:
                        return color.getHSVBrightness();
                    case "hsl":
                        return color.getHSLBrightness();
                    case "lum":
                        return color.getLuminance();
                    case "lum2":
                        return color.getLuminance2();
                    case "lum3":
                        return color.getLuminance3();
                    case "wcag":
                        return color.getLuminanceWCAG();
                }
            }
            static parseColorString(value) {
                if (common_isValid(DEFAULT_COLORS_OPACITY[value])) return rgba(DEFAULT_COLORS_OPACITY[value]);
                if (common_isValid(DEFAULT_COLORS[value])) return Color_rgb(DEFAULT_COLORS[value]);
                const formatValue = `${value}`.trim().toLowerCase(), hexRes = setHex(formatValue);
                if (void 0 !== hexRes) return hexRes;
                if (/^(rgb|RGB|rgba|RGBA)/.test(formatValue)) {
                    const aColor = formatValue.replace(/(?:\(|\)|rgba|RGBA|rgb|RGB)*/g, "").split(",");
                    return new RGB(parseInt(aColor[0], 10), parseInt(aColor[1], 10), parseInt(aColor[2], 10), parseFloat(aColor[3]));
                }
                if (/^(hsl|HSL|hsla|HSLA)/.test(formatValue)) {
                    const aColor = formatValue.replace(/(?:\(|\)|hsla|HSLA|hsl|HSL)*/g, "").split(","), rgb = hslToRgb(parseInt(aColor[0], 10), parseInt(aColor[1], 10), parseInt(aColor[2], 10));
                    return new RGB(rgb.r, rgb.g, rgb.b, parseFloat(aColor[3]));
                }
            }
            constructor(value){
                const color = Color.parseColorString(value);
                color ? this.color = color : (console.warn(`Warn: 传入${value}无法解析为Color`), this.color = new RGB(255, 255, 255));
            }
            toRGBA() {
                return this.color.formatRgb();
            }
            toString() {
                return this.color.formatRgb();
            }
            toHex() {
                return this.color.formatHex();
            }
            toHsl() {
                return this.color.formatHsl();
            }
            brighter(k) {
                const { r: r, g: g, b: b } = this.color;
                return this.color.r = Math.max(0, Math.min(255, Math.floor(r * k))), this.color.g = Math.max(0, Math.min(255, Math.floor(g * k))), this.color.b = Math.max(0, Math.min(255, Math.floor(b * k))), this;
            }
            add(color) {
                const { r: r, g: g, b: b } = this.color;
                return this.color.r += Math.min(255, r + color.color.r), this.color.g += Math.min(255, g + color.color.g), this.color.b += Math.min(255, b + color.color.b), this;
            }
            sub(color) {
                return this.color.r = Math.max(0, this.color.r - color.color.r), this.color.g = Math.max(0, this.color.g - color.color.g), this.color.b = Math.max(0, this.color.b - color.color.b), this;
            }
            multiply(color) {
                const { r: r, g: g, b: b } = this.color;
                return this.color.r = Math.max(0, Math.min(255, Math.floor(r * color.color.r))), this.color.g = Math.max(0, Math.min(255, Math.floor(g * color.color.g))), this.color.b = Math.max(0, Math.min(255, Math.floor(b * color.color.b))), this;
            }
            getHSVBrightness() {
                return Math.max(this.color.r, this.color.g, this.color.b) / 255;
            }
            getHSLBrightness() {
                return .5 * (Math.max(this.color.r, this.color.g, this.color.b) / 255 + Math.min(this.color.r, this.color.g, this.color.b) / 255);
            }
            setHsl(h, s, l) {
                const opacity = this.color.opacity, hsl = rgbToHsl(this.color.r, this.color.g, this.color.b), rgb = hslToRgb(common_isNil(h) ? hsl.h : common_clamp(h, 0, 360), common_isNil(s) ? hsl.s : s >= 0 && s <= 1 ? 100 * s : s, common_isNil(l) ? hsl.l : l <= 1 && l >= 0 ? 100 * l : l);
                return this.color = new RGB(rgb.r, rgb.g, rgb.b, opacity), this;
            }
            setRGB(r, g, b) {
                return common_isNil(r) || (this.color.r = r), common_isNil(g) || (this.color.g = g), common_isNil(b) || (this.color.b = b), this;
            }
            setHex(value) {
                const formatValue = `${value}`.trim().toLowerCase(), res = setHex(formatValue, !0);
                return null != res ? res : this;
            }
            setColorName(name) {
                const hex = DEFAULT_COLORS[name.toLowerCase()];
                return void 0 !== hex ? this.setHex(hex) : console.warn("THREE.Color: Unknown color " + name), this;
            }
            setScalar(scalar) {
                return this.color.r = scalar, this.color.g = scalar, this.color.b = scalar, this;
            }
            setOpacity(o = 1) {
                return this.color.opacity = o, this;
            }
            getLuminance() {
                return (.2126 * this.color.r + .7152 * this.color.g + .0722 * this.color.b) / 255;
            }
            getLuminance2() {
                return (.2627 * this.color.r + .678 * this.color.g + .0593 * this.color.b) / 255;
            }
            getLuminance3() {
                return (.299 * this.color.r + .587 * this.color.g + .114 * this.color.b) / 255;
            }
            getLuminanceWCAG() {
                const RsRGB = this.color.r / 255, GsRGB = this.color.g / 255, BsRGB = this.color.b / 255;
                let R, G, B;
                R = RsRGB <= .03928 ? RsRGB / 12.92 : Math.pow((RsRGB + .055) / 1.055, 2.4), G = GsRGB <= .03928 ? GsRGB / 12.92 : Math.pow((GsRGB + .055) / 1.055, 2.4), B = BsRGB <= .03928 ? BsRGB / 12.92 : Math.pow((BsRGB + .055) / 1.055, 2.4);
                return .2126 * R + .7152 * G + .0722 * B;
            }
            clone() {
                return new Color(this.color.toString());
            }
            copyGammaToLinear(color, gammaFactor = 2) {
                return this.color.r = Math.pow(color.color.r, gammaFactor), this.color.g = Math.pow(color.color.g, gammaFactor), this.color.b = Math.pow(color.color.b, gammaFactor), this;
            }
            copyLinearToGamma(color, gammaFactor = 2) {
                const safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
                return this.color.r = Math.pow(color.color.r, safeInverse), this.color.g = Math.pow(color.color.g, safeInverse), this.color.b = Math.pow(color.color.b, safeInverse), this;
            }
            convertGammaToLinear(gammaFactor) {
                return this.copyGammaToLinear(this, gammaFactor), this;
            }
            convertLinearToGamma(gammaFactor) {
                return this.copyLinearToGamma(this, gammaFactor), this;
            }
            copySRGBToLinear(color) {
                return this.color.r = SRGBToLinear(color.color.r), this.color.g = SRGBToLinear(color.color.g), this.color.b = SRGBToLinear(color.color.b), this;
            }
            copyLinearToSRGB(color) {
                return this.color.r = LinearToSRGB(color.color.r), this.color.g = LinearToSRGB(color.color.g), this.color.b = LinearToSRGB(color.color.b), this;
            }
            convertSRGBToLinear() {
                return this.copySRGBToLinear(this), this;
            }
            convertLinearToSRGB() {
                return this.copyLinearToSRGB(this), this;
            }
        }
        class RGB {
            constructor(r, g, b, opacity){
                this.r = isNaN(+r) ? 255 : Math.max(0, Math.min(255, +r)), this.g = isNaN(+g) ? 255 : Math.max(0, Math.min(255, +g)), this.b = isNaN(+b) ? 255 : Math.max(0, Math.min(255, +b)), common_isValid(opacity) ? this.opacity = isNaN(+opacity) ? 1 : Math.max(0, Math.min(1, +opacity)) : this.opacity = 1;
            }
            formatHex() {
                return `#${Color_hex(this.r) + Color_hex(this.g) + Color_hex(this.b) + (1 === this.opacity ? "" : Color_hex(255 * this.opacity))}`;
            }
            formatRgb() {
                const opacity = this.opacity;
                return `${1 === opacity ? "rgb(" : "rgba("}${this.r},${this.g},${this.b}${1 === opacity ? ")" : `,${opacity})`}`;
            }
            formatHsl() {
                const opacity = this.opacity, { h: h, s: s, l: l } = rgbToHsl(this.r, this.g, this.b);
                return `${1 === opacity ? "hsl(" : "hsla("}${h},${s}%,${l}%${1 === opacity ? ")" : `,${opacity})`}`;
            }
            toString() {
                return this.formatHex();
            }
        }
        function clamper(a, b) {
            let t;
            return a > b && (t = a, a = b, b = t), (x)=>Math.max(a, Math.min(b, x));
        }
        const formatGradientStops = (stops)=>{
            const firstInvalidateIndex = stops.findIndex((stop)=>stop.offset < 0 || stop.offset > 1);
            if (firstInvalidateIndex >= 0) {
                if (stops[firstInvalidateIndex].offset > 1) {
                    const newStops = stops.slice(0, firstInvalidateIndex + 1);
                    newStops[newStops.length - 1].offset = 1;
                    return newStops;
                }
                const newStops = stops.slice(firstInvalidateIndex + 1);
                newStops[0].offset = 0;
                return newStops;
            }
            return stops;
        };
        const splitLine = (spec, context)=>{
            const { advancedVSeed } = context;
            const { annotation, chartType, datasetReshapeInfo } = advancedVSeed;
            if (!annotation || !annotation.annotationHorizontalLine) return spec;
            const baseConfig = advancedVSeed.config[chartType];
            const splitLineConfig = array_array(annotation.annotationHorizontalLine).find((item)=>!!item.splitLine);
            const splitValue = +splitLineConfig?.yValue;
            if (Number.isNaN(splitValue) || !chunk_6GTAPB47_e(splitValue)) return spec;
            const result = {
                ...spec
            };
            const colorTheme = baseConfig?.color ?? {};
            const colorConfig = {
                positiveColor: colorTheme.positiveColor || 'red',
                negativeColor: colorTheme.negativeColor || 'green',
                ...chunk_BZNENX2T_r(splitLineConfig?.splitLine) ? splitLineConfig?.splitLine : {}
            };
            const groupMark = {
                type: 'group',
                name: 'annotationHorizontalLine-splitLine',
                zIndex: 300,
                style: {
                    splitConfig: (datum, ctx)=>{
                        const vchart = ctx.vchart;
                        const chart = vchart.getChart();
                        const lineSeries = chart.getAllSeries().find((s)=>'line' === s.type || 'area' === s.type);
                        if (!lineSeries) return;
                        const lineMark = lineSeries.getMarkInName('line') ?? lineSeries.getMarkInName('area');
                        if (!lineMark) return;
                        const lineGraphics = lineMark.getGraphics();
                        if (!lineGraphics || 1 !== lineGraphics.length || !lineGraphics[0]) return;
                        const points = lineGraphics[0].attribute.points ?? [];
                        if (lineGraphics[0].attribute.segments?.length) lineGraphics[0].attribute.segments.forEach((seg)=>{
                            seg.points.forEach((pt)=>{
                                points.push({
                                    x: pt.x,
                                    y: pt.y
                                });
                            });
                        });
                        if (!points || !points.length) return;
                        const scale = lineSeries.getYAxisHelper().getScale(0);
                        const splitCoordinate = scale.scale(splitValue);
                        const minY = Math.min(...points.map((p)=>p.y));
                        const maxY = Math.max(...points.map((p)=>p.y));
                        const ratio = (splitCoordinate - minY) / (maxY - minY);
                        const lineStroke = {
                            gradient: 'linear',
                            x0: 0,
                            x1: 0,
                            y0: 0,
                            y1: 1,
                            stops: formatGradientStops([
                                {
                                    color: colorConfig.positiveColor,
                                    offset: 0
                                },
                                {
                                    color: colorConfig.positiveColor,
                                    offset: ratio
                                },
                                {
                                    color: colorConfig.negativeColor,
                                    offset: ratio + 0.0000001
                                },
                                {
                                    color: colorConfig.negativeColor,
                                    offset: 1
                                }
                            ])
                        };
                        const areaFill = {
                            gradient: 'linear',
                            x0: 0,
                            x1: 0,
                            y0: 0,
                            y1: 1,
                            stops: formatGradientStops([
                                {
                                    color: colorConfig.positiveColor,
                                    offset: 0
                                },
                                {
                                    color: new Color(colorConfig.positiveColor).setOpacity(0).toRGBA(),
                                    offset: ratio
                                },
                                {
                                    offset: ratio + 0.0000001,
                                    color: new Color(colorConfig.negativeColor).setOpacity(0).toRGBA()
                                },
                                {
                                    color: colorConfig.negativeColor,
                                    offset: 1
                                }
                            ])
                        };
                        const attrs = {
                            segments: null,
                            points
                        };
                        if ('area' === lineGraphics[0].type) {
                            attrs.stroke = lineStroke;
                            attrs.fill = areaFill;
                        } else attrs.stroke = lineStroke;
                        lineGraphics[0].setAttributes(attrs);
                        lineGraphics[0].setFinalAttributes?.(attrs);
                        const start = lineSeries.getRegion().getLayoutStartPoint();
                        const range = scale.range();
                        return {
                            points: points.map((entry)=>({
                                    x: entry.x + start.x,
                                    y: entry.y + start.y
                                })),
                            splitCoordinate: clamper(range[0], range[range.length - 1])(splitCoordinate) + start.y,
                            areaFill,
                            lineStroke
                        };
                    }
                },
                children: [
                    {
                        type: 'area',
                        interactive: false,
                        zIndex: 500,
                        style: {
                            fillOpacity: 0.5,
                            points: (datum, ctx, opt)=>{
                                const parentNode = opt.mark?._product?.parent;
                                if (parentNode?.attribute?.splitConfig) {
                                    const { points, splitCoordinate } = parentNode.attribute.splitConfig;
                                    return points.map((entry)=>({
                                            ...entry,
                                            y1: splitCoordinate
                                        }));
                                }
                                return [];
                            },
                            fill: (datum, ctx, opt)=>{
                                const parentNode = opt.mark?._product?.parent;
                                if (parentNode?.attribute?.splitConfig) {
                                    const { areaFill } = parentNode.attribute.splitConfig;
                                    return areaFill;
                                }
                            }
                        }
                    }
                ]
            };
            if (!result.customMark) result.customMark = [];
            result.customMark.push(groupMark);
            const seriesSpec = 'line' === result.type || 'area' === result.type ? result : result.series?.find((s)=>'line' === s.type || 'area' === s.type);
            if (seriesSpec) {
                if (!seriesSpec.point) seriesSpec.point = {};
                if (!seriesSpec.line) seriesSpec.line = {};
                if (!seriesSpec.point.style) seriesSpec.point.style = {};
                if (!seriesSpec.line.style) seriesSpec.line.style = {};
                const measureValueKey = datasetReshapeInfo[0].foldInfo.measureValue;
                seriesSpec.point.style.fill = (datum)=>datum?.[measureValueKey] < splitValue ? colorConfig.negativeColor : colorConfig.positiveColor;
                seriesSpec.line.style.stroke = (datum)=>datum?.[measureValueKey] < splitValue ? colorConfig.negativeColor : colorConfig.positiveColor;
                if (seriesSpec.label && seriesSpec.label.visible && chunk_JK3VNB42_n(seriesSpec.label.style?.fill)) seriesSpec.label.style = {
                    ...seriesSpec.label.style,
                    fill: (datum)=>datum?.[measureValueKey] < splitValue ? colorConfig.negativeColor : colorConfig.positiveColor
                };
            }
            return result;
        };
        const initPivot = (spec)=>{
            const result = {
                ...spec
            };
            return {
                ...result,
                animation: true,
                rows: [],
                columns: [],
                indicators: [],
                records: [],
                widthMode: 'standard',
                autoFillWidth: true,
                defaultHeaderColWidth: 'auto',
                defaultColWidth: 240,
                heightMode: 'standard',
                autoFillHeight: true,
                defaultRowHeight: 180,
                defaultHeaderRowHeight: 'auto',
                indicatorsAsCol: false,
                select: {
                    highlightMode: 'cell',
                    headerSelectMode: 'inline'
                },
                hover: {
                    highlightMode: 'cross'
                },
                tooltip: {
                    isShowOverflowTextTooltip: true
                },
                corner: {
                    titleOnDimension: 'row'
                },
                animationAppear: {
                    duration: 600,
                    type: 'all',
                    direction: 'row'
                }
            };
        };
        const pivotGridStyle = (spec, context)=>{
            const { vseed, advancedVSeed } = context;
            const { config, chartType } = advancedVSeed;
            const themConfig = config?.[chartType]?.pivotGrid ?? {};
            const onlyCombination = !chatType_isPivot(vseed) && isCombination(vseed);
            const result = {
                ...spec
            };
            const transparent = 'rgba(0,0,0,0)';
            const borderColor = themConfig.borderColor ?? '#e3e5eb';
            const bodyFontColor = themConfig.bodyFontColor ?? '#141414';
            const headerFontColor = themConfig.headerFontColor ?? '#21252c';
            const headerBackgroundColor = themConfig.headerBackgroundColor ?? 'rgba(0,0,0,0)';
            const hoverHeaderBackgroundColor = onlyCombination ? transparent : themConfig.hoverHeaderBackgroundColor ?? '#D9DDE4';
            const hoverHeaderInlineBackgroundColor = onlyCombination ? transparent : themConfig.hoverHeaderInlineBackgroundColor ?? '#D9DDE455';
            const outlineBorderLineWidth = themConfig.outlineBorderLineWidth ?? 0;
            const frameCornerRadius = themConfig.frameCornerRadius ?? 0;
            if (!chunk_JK3VNB42_n(themConfig.minChartWidth)) result.defaultColWidth = themConfig.minChartWidth;
            if (!chunk_JK3VNB42_n(themConfig.minChartHeight)) result.defaultRowHeight = themConfig.minChartHeight;
            return {
                ...result,
                theme: {
                    underlayBackgroundColor: transparent,
                    bodyStyle: {
                        borderColor,
                        color: bodyFontColor,
                        borderLineWidth: (arg)=>{
                            const noYAxis = 'pie' === chartType || 'rose' === chartType || 'donut' === chartType || 'funnel' === chartType || 'radar' === chartType || 'roseParallel' === chartType;
                            return [
                                0 === arg.row ? outlineBorderLineWidth : 1,
                                outlineBorderLineWidth,
                                0,
                                0 === arg.col || noYAxis && 1 === arg.col && arg.table.colCount <= 2 ? outlineBorderLineWidth : 1
                            ];
                        },
                        bgColor: transparent,
                        hover: {
                            cellBgColor: 'transparent'
                        }
                    },
                    headerStyle: {
                        borderColor,
                        fontSize: 12,
                        borderLineWidth: (arg)=>[
                                outlineBorderLineWidth,
                                outlineBorderLineWidth,
                                1,
                                0 === arg.col ? outlineBorderLineWidth : 1
                            ],
                        color: headerFontColor,
                        textAlign: 'center',
                        bgColor: headerBackgroundColor,
                        hover: {
                            cellBgColor: hoverHeaderBackgroundColor,
                            inlineRowBgColor: hoverHeaderInlineBackgroundColor || void 0,
                            inlineColumnBgColor: hoverHeaderInlineBackgroundColor || void 0
                        }
                    },
                    rowHeaderStyle: {
                        borderColor,
                        fontSize: 12,
                        color: headerFontColor,
                        padding: [
                            0,
                            12,
                            0,
                            4
                        ],
                        borderLineWidth: (arg)=>[
                                0 === arg.row ? outlineBorderLineWidth : 1,
                                1,
                                0,
                                outlineBorderLineWidth
                            ],
                        bgColor: headerBackgroundColor,
                        hover: {
                            cellBgColor: hoverHeaderBackgroundColor,
                            inlineRowBgColor: hoverHeaderInlineBackgroundColor || void 0,
                            inlineColumnBgColor: hoverHeaderInlineBackgroundColor || void 0
                        }
                    },
                    cornerHeaderStyle: {
                        borderColor,
                        textAlign: 'center',
                        fontSize: 12,
                        color: headerFontColor,
                        padding: [
                            0,
                            12,
                            0,
                            4
                        ],
                        fontWeight: 'bold',
                        borderLineWidth: [
                            outlineBorderLineWidth,
                            1,
                            1,
                            outlineBorderLineWidth
                        ],
                        bgColor: headerBackgroundColor,
                        frameStyle: {
                            borderColor
                        },
                        hover: {
                            cellBgColor: hoverHeaderBackgroundColor,
                            inlineRowBgColor: hoverHeaderInlineBackgroundColor || void 0,
                            inlineColumnBgColor: hoverHeaderInlineBackgroundColor || void 0
                        }
                    },
                    cornerLeftBottomCellStyle: {
                        borderColor,
                        borderLineWidth: [
                            outlineBorderLineWidth,
                            0,
                            outlineBorderLineWidth,
                            outlineBorderLineWidth
                        ],
                        bgColor: headerBackgroundColor,
                        frameStyle: {
                            borderColor,
                            borderLineWidth: [
                                1,
                                0,
                                outlineBorderLineWidth,
                                outlineBorderLineWidth
                            ]
                        },
                        hover: {
                            cellBgColor: hoverHeaderBackgroundColor
                        }
                    },
                    cornerRightTopCellStyle: {
                        borderColor,
                        borderLineWidth: [
                            outlineBorderLineWidth,
                            outlineBorderLineWidth,
                            1,
                            1
                        ],
                        frameStyle: {
                            borderColor,
                            borderLineWidth: 0
                        },
                        bgColor: headerBackgroundColor,
                        hover: {
                            cellBgColor: hoverHeaderBackgroundColor
                        }
                    },
                    rightFrozenStyle: {
                        borderColor,
                        bgColor: headerBackgroundColor,
                        borderLineWidth: (arg)=>[
                                0 === arg.row ? outlineBorderLineWidth : 1,
                                outlineBorderLineWidth,
                                0,
                                1
                            ],
                        frameStyle: {
                            borderLineWidth: 0
                        },
                        hover: {
                            borderLineWidth: 0,
                            cellBgColor: hoverHeaderBackgroundColor
                        }
                    },
                    cornerRightBottomCellStyle: {
                        borderColor,
                        bgColor: headerBackgroundColor,
                        borderLineWidth: [
                            1,
                            outlineBorderLineWidth,
                            outlineBorderLineWidth,
                            1
                        ],
                        frameStyle: {
                            borderColor,
                            borderLineWidth: [
                                1,
                                outlineBorderLineWidth,
                                outlineBorderLineWidth,
                                1
                            ]
                        },
                        hover: {
                            cellBgColor: hoverHeaderBackgroundColor
                        }
                    },
                    bottomFrozenStyle: {
                        borderColor,
                        borderLineWidth: [
                            1,
                            outlineBorderLineWidth,
                            outlineBorderLineWidth,
                            1
                        ],
                        bgColor: headerBackgroundColor,
                        hover: {
                            cellBgColor: hoverHeaderBackgroundColor
                        }
                    },
                    selectionStyle: {
                        cellBgColor: '',
                        cellBorderColor: ''
                    },
                    frameStyle: {
                        borderColor,
                        cornerRadius: frameCornerRadius,
                        borderLineWidth: outlineBorderLineWidth
                    },
                    axisStyle: {
                        leftAxisStyle: {
                            cellPaddingLeft: 10
                        },
                        bottomAxisStyle: {
                            cellPaddingBottom: 4
                        },
                        rightAxisStyle: {
                            cellPaddingRight: 4
                        }
                    },
                    scrollStyle: {
                        visible: 'scrolling',
                        hoverOn: false
                    }
                }
            };
        };
        const pivotIndicators_pivotIndicators = (chartPipeline)=>(spec, context)=>{
                const result = {
                    ...spec
                };
                const { advancedVSeed } = context;
                const { measures, datasetReshapeInfo, dataset, encoding } = advancedVSeed;
                const colorItems = chunk_QJLMYOTX_i(datasetReshapeInfo.flatMap((d)=>d.unfoldInfo.colorItems));
                const allMeasureIds = chunk_QJLMYOTX_i(datasetReshapeInfo.flatMap((d)=>Object.keys(d.foldInfo.foldMap || {})));
                const indicators = datasetReshapeInfo.map((reshapeInfo, index)=>{
                    const measureGroup = measures?.find((d)=>`${d.id}` === reshapeInfo.id);
                    const subMeasuresId = (measureGroup?.children || []).map((d)=>d.id);
                    const invalideMeasuresIds = allMeasureIds.filter((id)=>!subMeasuresId.includes(id));
                    const newDataset = dataset[index];
                    const newDatasetReshapeInfo = [
                        {
                            ...reshapeInfo,
                            unfoldInfo: {
                                ...reshapeInfo.unfoldInfo,
                                colorItems
                            }
                        }
                    ];
                    const newContext = {
                        ...context,
                        advancedVSeed: {
                            ...advancedVSeed,
                            pivotAllDatasetReshapeInfo: datasetReshapeInfo,
                            datasetReshapeInfo: newDatasetReshapeInfo,
                            encoding: Object.keys(encoding).reduce((res, key)=>{
                                res[key] = encoding[key]?.filter((e)=>!invalideMeasuresIds.includes(e));
                                return res;
                            }, {}),
                            dataset: newDataset
                        }
                    };
                    const chartSpec = execPipeline(chartPipeline, newContext, {});
                    return {
                        indicatorKey: `${reshapeInfo.id}`,
                        title: measureGroup?.alias,
                        cellType: 'chart',
                        chartModule: 'vchart',
                        chartSpec: chartSpec,
                        style: {
                            padding: [
                                1,
                                1,
                                0,
                                1
                            ]
                        }
                    };
                });
                return {
                    ...result,
                    indicators: indicators
                };
            };
        const pivotIndicatorsAsRow = (spec)=>{
            const result = {
                ...spec
            };
            return {
                ...result,
                indicatorsAsCol: false
            };
        };
        const pivotIndicatorsAsCol = (spec)=>{
            const result = {
                ...spec
            };
            return {
                ...result,
                indicatorsAsCol: true
            };
        };
        const datasetPivot = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed } = context;
            const { dataset, datasetReshapeInfo } = advancedVSeed;
            const records = dataset.reduce((pre, cur, index)=>{
                const id = datasetReshapeInfo[index].id;
                pre[id] = cur;
                return pre;
            }, {});
            return {
                ...result,
                records: records
            };
        };
        const pivotAxisStyle = (axisStyle)=>(spec, context)=>{
                const result = axisStyle(spec, context);
                if (result.axes) {
                    const { advancedVSeed } = context;
                    const { config, chartType } = advancedVSeed;
                    const themConfig = config?.[chartType]?.pivotGrid ?? {};
                    result.axes.forEach((axis)=>{
                        axis.domainLine = {
                            visible: false
                        };
                        if (themConfig.chartGridColor && axis.grid && axis.grid.visible && axis.grid.style) axis.grid.style.stroke = themConfig.chartGridColor;
                        if (themConfig.axisLabelColor && axis.label && axis.label.visible && axis.label.style) axis.label.style.fill = themConfig.axisLabelColor;
                        if ('band' === axis.type) {
                            if ('left' === axis.orient || 'right' === axis.orient) axis.innerOffset = {
                                top: 2,
                                bottom: 2
                            };
                            else if ('top' === axis.orient || 'bottom' === axis.orient) axis.innerOffset = {
                                left: 2,
                                right: 2
                            };
                        } else if ('linear' === axis.type) {
                            if ('top' === axis.orient || 'bottom' === axis.orient) axis.label.flush = true;
                        }
                    });
                }
                return result;
            };
        const pivotRowDimensions = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed } = context;
            const dimensions = advancedVSeed.dimensions;
            if (!dimensions) return result;
            const rowDimensions = dimensions.filter((dim)=>'row' === dim.encoding);
            const rows = rowDimensions.map((dim)=>({
                    dimensionKey: dim.id,
                    title: dim.alias || dim.id
                }));
            return {
                ...result,
                rows: rows
            };
        };
        const pivotColumnDimensions = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed } = context;
            const dimensions = advancedVSeed.dimensions;
            if (!dimensions) return result;
            const columnDimensions = dimensions.filter((dim)=>'column' === dim.encoding);
            const columns = columnDimensions.map((dim)=>({
                    dimensionKey: dim.id,
                    title: dim.alias || dim.id
                }));
            return {
                ...result,
                columns: columns
            };
        };
        const pivotTitle = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed } = context;
            const { config, chartType } = advancedVSeed;
            const themConfig = config?.[chartType]?.pivotGrid ?? {};
            if (result.columns && result.columns.length > 0) result.title = {
                text: spec.columns.map((entry)=>entry.title).join('/'),
                align: 'center',
                orient: 'top',
                padding: [
                    2,
                    0,
                    0,
                    0
                ],
                textStyle: {
                    fontSize: themConfig.titleFontSize ?? 12,
                    fill: themConfig.titleFontColor ?? '#000',
                    fontWeight: themConfig.titleFontWeight ?? 'bold'
                }
            };
            return result;
        };
        const pivotDiscreteLegend = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed } = context;
            const { chartType } = advancedVSeed;
            const baseConfig = advancedVSeed.config[chartType];
            if (!baseConfig || !baseConfig.legend) return result;
            const { datasetReshapeInfo } = advancedVSeed;
            const colorItems = chunk_QJLMYOTX_i(datasetReshapeInfo.flatMap((d)=>d.unfoldInfo.colorItems));
            const colorIdMap = datasetReshapeInfo.reduce((prev, cur)=>({
                    ...prev,
                    ...cur.unfoldInfo.colorIdMap
                }), {});
            const { legend, color } = baseConfig;
            const { colorScheme, colorMapping } = color;
            const colorSpecified = createSpecifiedForColorMapping(colorMapping, colorIdMap, colorItems);
            const { enable, position = 'bottom', labelFontColor, labelColor, labelFontSize = 12, labelFontWeight = 400, maxSize = 1, border, shapeType = 'rectRound' } = legend || {};
            const orient = [
                'bottom',
                'bottomLeft',
                'bottomRight',
                'bl',
                'br'
            ].includes(position) ? 'bottom' : [
                'top',
                'topLeft',
                'topRight',
                'tl',
                'tr'
            ].includes(position) ? 'top' : [
                'left',
                'leftTop',
                'leftBottom',
                'lt',
                'lb'
            ].includes(position) ? 'left' : 'right';
            const legendPosition = [
                'topLeft',
                'bottomLeft',
                'leftTop',
                'rightTop',
                'lt',
                'rt',
                'tl',
                'bl'
            ].includes(position) ? 'start' : [
                'topRight',
                'bottomRight',
                'leftBottom',
                'rightBottom',
                'lb',
                'rb',
                'rt',
                'br'
            ].includes(position) ? 'end' : 'middle';
            const legends = {
                padding: 0,
                visible: enable,
                type: 'discrete',
                orient,
                position: legendPosition,
                maxCol: Math.max(1, maxSize),
                maxRow: Math.max(1, maxSize),
                data: colorItems.map((d, index)=>{
                    const color = colorSpecified?.[d] ?? colorScheme?.[index % colorScheme.length];
                    return {
                        label: d,
                        shape: {
                            outerBorder: border ? {
                                stroke: color,
                                distance: 3,
                                lineWidth: 1
                            } : void 0,
                            fill: color
                        }
                    };
                }),
                item: {
                    focus: true,
                    maxWidth: '30%',
                    focusIconStyle: {
                        size: labelFontSize + 2,
                        fill: labelColor || labelFontColor,
                        fontWeight: labelFontWeight
                    },
                    shape: {
                        space: border ? 6 : 4,
                        style: {
                            symbolType: shapeType,
                            size: border ? 8 : 10
                        }
                    },
                    label: {
                        formatMethod: (value)=>colorIdMap[value]?.alias ?? value,
                        style: {
                            fontSize: labelFontSize,
                            fill: labelColor || labelFontColor,
                            fontWeight: labelFontWeight
                        }
                    },
                    background: {
                        state: {
                            selectedHover: {
                                fill: labelColor || labelFontColor,
                                fillOpacity: 0.05
                            }
                        }
                    }
                }
            };
            return {
                ...result,
                legends
            };
        };
        const pivotColorLegend = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed } = context;
            const { chartType } = advancedVSeed;
            const baseConfig = advancedVSeed.config[chartType];
            if (!baseConfig || !baseConfig.legend) return result;
            const { datasetReshapeInfo } = advancedVSeed;
            const max = Math.max(...datasetReshapeInfo.map((d)=>d.foldInfo.statistics.colorMin));
            const min = Math.min(...datasetReshapeInfo.map((d)=>d.foldInfo.statistics.colorMax));
            const { legend, color } = baseConfig;
            const { colorScheme, linearColorScheme } = color;
            const { enable, position = 'bottom', labelFontColor, labelColor, labelFontSize = 12, labelFontWeight = 400 } = legend || {};
            const orient = [
                'bottom',
                'bottomLeft',
                'bottomRight',
                'bl',
                'br'
            ].includes(position) ? 'bottom' : [
                'top',
                'topLeft',
                'topRight',
                'tl',
                'tr'
            ].includes(position) ? 'top' : [
                'left',
                'leftTop',
                'leftBottom',
                'lt',
                'lb'
            ].includes(position) ? 'left' : 'right';
            const legendPosition = [
                'topLeft',
                'bottomLeft',
                'leftTop',
                'rightTop',
                'lt',
                'rt',
                'tl',
                'bl'
            ].includes(position) ? 'start' : [
                'topRight',
                'bottomRight',
                'leftBottom',
                'rightBottom',
                'lb',
                'rb',
                'rt',
                'br'
            ].includes(position) ? 'end' : 'middle';
            const legends = {
                visible: enable,
                type: 'color',
                orient,
                position: legendPosition,
                colors: linearColorScheme || colorScheme || [],
                value: [
                    min,
                    max
                ],
                min: min,
                max: max,
                maxWidth: '30%',
                handlerText: {
                    visible: true,
                    style: {
                        fill: labelColor || labelFontColor,
                        fontSize: labelFontSize,
                        fontWeight: labelFontWeight
                    }
                }
            };
            return {
                ...result,
                legends
            };
        };
        const dimensionLinkage = (spec, context)=>{
            const { advancedVSeed, vseed } = context;
            const { chartType } = vseed;
            const config = advancedVSeed.config?.[chartType]?.dimensionLinkage ?? {};
            if (false === config.enable) return spec;
            const indicators = spec.indicators;
            const labelHoverOnAxis = {};
            const chartSpec = indicators?.[0]?.chartSpec;
            const crosshair = chartSpec?.crosshair;
            if (crosshair?.xField) {
                const labelFormat = crosshair.xField.label?.formatMethod;
                labelHoverOnAxis.bottom = {
                    visible: config.showLabel ?? crosshair.xField.label?.visible ?? true,
                    background: crosshair.xField.label?.labelBackground,
                    textStyle: crosshair.xField.label?.style,
                    formatMethod: labelFormat ? (text)=>text || 0 === text ? labelFormat(text) : null : void 0
                };
            }
            if (crosshair?.yField) {
                const labelFormat = crosshair.yField.label?.formatMethod;
                labelHoverOnAxis.left = {
                    visible: config.showLabel ?? crosshair.yField.label?.visible ?? true,
                    background: crosshair.yField.label?.labelBackground,
                    textStyle: crosshair.yField.label?.style,
                    formatMethod: labelFormat ? (text)=>text || 0 === text ? labelFormat(text) : null : void 0
                };
            }
            if (indicators && indicators.length) indicators.forEach((ind)=>{
                const crosshair = ind?.chartSpec?.crosshair;
                if (crosshair?.xField) crosshair.xField.label = {
                    visible: false
                };
                if (crosshair?.yField) crosshair.yField.label = {
                    visible: false
                };
            });
            spec.chartDimensionLinkage = {
                showTooltip: config.showTooltip ?? chartSpec?.tooltip?.dimension?.visible ?? true,
                heightLimitToShowTooltipForLastRow: 60,
                widthLimitToShowTooltipForLastColumn: 90,
                labelHoverOnAxis
            };
            return spec;
        };
        const pivotAdapter_pivotAdapter = (pipeline, pivotPipeline)=>{
            const adapted = (spec, context)=>{
                const { vseed } = context;
                const usePivotChart = isPivotChart(vseed);
                if (usePivotChart) return execPipeline(pivotPipeline, context, spec);
                return execPipeline(pipeline, context, spec);
            };
            return adapted;
        };
        const line_line = [
            initLine,
            colorAdapter(color_color, linearColor),
            background_backgroundColor,
            datasetXY,
            progressive,
            xBand,
            yLinear,
            verticalCrosshairLine,
            colorAdapter(discreteLegend, colorLegend),
            colorPointStyleFill(pointStyle_pointStyle),
            pointStateDimensionHover,
            colorLineStyleFill(lineStyle_lineStyle),
            label_label,
            tooltip_tooltip,
            annotationPoint_annotationPoint,
            annotationVerticalLine_annotationVerticalLine,
            annotationHorizontalLine_annotationHorizontalLine,
            annotationArea_annotationArea,
            splitLine
        ];
        const pivotLine = [
            initPivot,
            pivotGridStyle,
            pivotIndicatorsAsRow,
            datasetPivot,
            pivotIndicators_pivotIndicators([
                initLine,
                colorAdapter(color_color, linearColor),
                background_backgroundColor,
                datasetXY,
                progressive,
                xBand,
                pivotAxisStyle(yLinear),
                verticalCrosshairLine,
                colorPointStyleFill(pointStyle_pointStyle),
                pointStateDimensionHover,
                colorLineStyleFill(lineStyle_lineStyle),
                label_label,
                tooltip_tooltip,
                annotationPoint_annotationPoint,
                annotationVerticalLine_annotationVerticalLine,
                annotationHorizontalLine_annotationHorizontalLine,
                annotationArea_annotationArea,
                splitLine
            ]),
            pivotRowDimensions,
            pivotColumnDimensions,
            pivotTitle,
            colorAdapter(pivotDiscreteLegend, pivotColorLegend),
            dimensionLinkage
        ];
        const lineSpecPipeline = [
            pivotAdapter_pivotAdapter(line_line, pivotLine)
        ];
        const registerLine = ()=>{
            Builder._advancedPipelineMap.line = lineAdvancedPipeline;
            Builder._specPipelineMap.line = lineSpecPipeline;
        };
        const defaultEncodingForColumn = (advancedVSeed)=>{
            const { measures: vseedMeasures = [], dimensions = [] } = advancedVSeed;
            const measures = findAllMeasures(vseedMeasures);
            const encoding = {};
            column_generateDefaultDimensionEncoding(dimensions, encoding);
            column_generateDefaultMeasureEncoding(measures, encoding);
            return {
                ...advancedVSeed,
                encoding
            };
        };
        const encodingForColumn = (advancedVSeed)=>{
            const { measures: vseedMeasures = [], dimensions = [] } = advancedVSeed;
            const measures = findAllMeasures(vseedMeasures);
            const hasDimensionEncoding = dimensions.some((item)=>item.encoding);
            const hasMeasureEncoding = measures.some((item)=>item.encoding);
            const encoding = {};
            if (hasDimensionEncoding) column_generateDimensionEncoding(dimensions, encoding, measures.length > 1);
            else column_generateDefaultDimensionEncoding(dimensions, encoding);
            if (hasMeasureEncoding) column_generateMeasureEncoding(measures, encoding);
            else column_generateDefaultMeasureEncoding(measures, encoding);
            return {
                ...advancedVSeed,
                encoding
            };
        };
        const column_generateDefaultDimensionEncoding = (dimensions, encoding)=>{
            const onlyMeasureId = 1 === dimensions.length && dimensions.find((item)=>item.id === MeasureId);
            const uniqueDimIds = chunk_QJLMYOTX_i(dimensions.map((d)=>d.id));
            encoding.x = uniqueDimIds.slice(0, 1);
            encoding.color = uniqueDimIds.slice(onlyMeasureId ? 0 : 1);
            encoding.detail = encoding.color;
            encoding.tooltip = uniqueDimIds.filter((d)=>d !== MeasureId);
            encoding.label = [];
            encoding.row = [];
            encoding.column = [];
        };
        const column_generateDimensionEncoding = (dimensions, encoding, isMultiMeasure)=>{
            encoding.x = chunk_QJLMYOTX_i(dimensions.filter((item)=>'xAxis' === item.encoding).map((item)=>item.id));
            if (0 === encoding.x.length) encoding.x = [
                dimensions[0].id
            ];
            addColorToEncoding(dimensions, encoding, isMultiMeasure);
            encoding.detail = chunk_QJLMYOTX_i(dimensions.filter((item)=>'detail' === item.encoding).map((item)=>item.id));
            if (0 === encoding.detail.length) encoding.detail = encoding.color;
            encoding.tooltip = chunk_QJLMYOTX_i(dimensions.map((item)=>item.id));
            encoding.tooltip = encoding.tooltip.filter((d)=>d !== MeasureId);
            encoding.label = chunk_QJLMYOTX_i(dimensions.filter((item)=>'label' === item.encoding).map((item)=>item.id));
            encoding.label = encoding.label.filter((d)=>d !== MeasureId);
        };
        const column_generateDefaultMeasureEncoding = (measures, encoding)=>{
            encoding.y = chunk_QJLMYOTX_i(measures.filter((item)=>'yAxis' === item.encoding || !item.encoding).map((item)=>item.id));
        };
        const column_generateMeasureEncoding = (measures, encoding)=>{
            encoding.y = chunk_QJLMYOTX_i(measures.filter((item)=>'yAxis' === item.encoding || !item.encoding).map((item)=>item.id));
            const color = chunk_QJLMYOTX_i(measures.filter((item)=>'color' === item.encoding).map((item)=>item.id));
            if (color.length > 0) encoding.color = color;
            const label = chunk_QJLMYOTX_i(measures.filter((item)=>'label' === item.encoding).map((item)=>item.id));
            encoding.label = chunk_QJLMYOTX_i([
                ...encoding.label || [],
                ...label
            ]);
            const tooltip = chunk_QJLMYOTX_i(measures.filter((item)=>'tooltip' === item.encoding).map((item)=>item.id));
            encoding.tooltip = chunk_QJLMYOTX_i([
                ...encoding.tooltip || [],
                ...label,
                ...tooltip
            ]);
        };
        const columnConfig = (advancedVSeed, context)=>{
            const { vseed } = context;
            const { chartType } = vseed;
            const result = {
                ...advancedVSeed
            };
            const pickedConfig = chunk_2T7K3PFL_i(vseed, [
                'backgroundColor',
                'color',
                'label',
                'legend',
                'tooltip',
                'xAxis',
                'yAxis',
                'crosshairRect',
                'stackCornerRadius',
                'barMaxWidth',
                'barGapInGroup',
                'dimensionLinkage'
            ]);
            const config = replaceNullToUndefined(pickedConfig);
            result.config = {
                ...result.config || {},
                [chartType]: {
                    ...config
                }
            };
            return result;
        };
        const regressionLine_regressionLine = (advancedVSeed, context)=>{
            const { vseed } = context;
            let keys = [];
            if ('histogram' === vseed.chartType) keys = [
                'kdeRegressionLine',
                'ecdfRegressionLine'
            ];
            else if ('scatter' === vseed.chartType) keys = [
                'linearRegressionLine',
                'lowessRegressionLine',
                'polynomialRegressionLine',
                'logisticRegressionLine'
            ];
            else if ('column' === vseed.chartType) keys = [
                'polynomialRegressionLine'
            ];
            if (keys.length) {
                const regressionLineConfig = {};
                let hasLine = false;
                keys.forEach((key)=>{
                    if (vseed[key]) {
                        hasLine = true;
                        regressionLineConfig[key] = vseed[key];
                    }
                });
                return hasLine ? {
                    ...advancedVSeed,
                    regressionLine: regressionLineConfig
                } : advancedVSeed;
            }
            return advancedVSeed;
        };
        const columnAdvancedPipeline = [
            initAdvancedVSeed_initAdvancedVSeed,
            default_defaultMeasures_defaultMeasures,
            defaultDimensions_defaultDimensions,
            defaultMeasureId_defaultMeasureId,
            encodingAdapter([
                defaultEncodingForColumn,
                buildMeasures
            ], [
                encodingForColumn,
                buildMeasures,
                pickMeasuresForReshape([
                    'tooltip',
                    'label',
                    'color'
                ]),
                pickDimensionsForReshape
            ]),
            pivotAdapter([
                reshapeWithEncoding
            ], [
                pivotReshapeWithEncoding
            ]),
            sortXBandAxis,
            sortLegend_sortLegend,
            columnConfig,
            theme_theme,
            markStyle_markStyle,
            annotation_annotation,
            regressionLine_regressionLine
        ];
        const initColumn = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed } = context;
            const { datasetReshapeInfo } = advancedVSeed;
            const { unfoldInfo, foldInfo } = datasetReshapeInfo[0];
            result.type = 'bar';
            result.direction = 'vertical';
            result.xField = unfoldInfo.encodingX;
            result.yField = foldInfo.measureValue;
            result.seriesField = unfoldInfo.encodingColorId;
            result.padding = 0;
            result.region = [
                {
                    clip: true
                }
            ];
            result.animation = true;
            return result;
        };
        const stackCornerRadius_stackCornerRadius = (spec, context)=>{
            const { advancedVSeed, vseed } = context;
            const { chartType } = vseed;
            const stackCornerRadius = advancedVSeed.config?.[chartType]?.stackCornerRadius;
            if ('dualAxis' === chartType && 'bar' !== spec.type) return spec;
            return {
                ...spec,
                stackCornerRadius: (_, datum)=>{
                    if (datum && datum[datum[FoldMeasureId]] > 0) return stackCornerRadius;
                    return 0;
                }
            };
        };
        const barMaxWidth_barMaxWidth = (spec, context)=>{
            const { advancedVSeed, vseed } = context;
            const { chartType } = vseed;
            const barMaxWidth = advancedVSeed.config?.[chartType]?.barMaxWidth;
            if (!chunk_JK3VNB42_n(barMaxWidth)) return {
                ...spec,
                barMaxWidth
            };
            return spec;
        };
        const stackInverse = (spec)=>{
            const result = {
                ...spec
            };
            result.stackInverse = true;
            return result;
        };
        const verticalCrosshairRect = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed, vseed } = context;
            const { chartType } = vseed;
            const config = advancedVSeed.config?.[chartType]?.crosshairRect;
            if (!config) return result;
            if (!result.crosshair) result.crosshair = {};
            const visible = config.visible || true;
            const rectColor = config.rectColor || void 0;
            const labelColor = config.labelColor || void 0;
            const labelVisible = config.labelVisible || false;
            const labelBackgroundColor = config.labelBackgroundColor || void 0;
            const crosshair = result.crosshair;
            crosshair.xField = {
                visible,
                line: {
                    type: 'rect',
                    style: {
                        lineWidth: 0,
                        opacity: 0.26,
                        fill: rectColor
                    }
                },
                label: {
                    visible: labelVisible,
                    labelBackground: {
                        visible: labelVisible,
                        style: {
                            fill: labelBackgroundColor
                        }
                    },
                    style: {
                        fill: labelColor
                    }
                }
            };
            const xAxisConfig = result.axes?.find((v)=>'bottom' === v.orient);
            const xAxisFormatter = xAxisConfig?.label?.formatMethod;
            if (xAxisFormatter) crosshair.xField.label.formatMethod = (text)=>xAxisFormatter(text);
            return result;
        };
        const colorBarStyleFill = (stylePipe)=>(spec, context)=>{
                const result = stylePipe(spec, context);
                const { advancedVSeed, vseed } = context;
                const { datasetReshapeInfo } = advancedVSeed;
                const { unfoldInfo } = datasetReshapeInfo[0];
                if (isLinearColor(advancedVSeed, vseed)) {
                    if (result?.bar?.style) result.bar.style.fill = {
                        field: unfoldInfo.encodingColor,
                        scale: 'color'
                    };
                }
                return result;
            };
        const barStyle_barStyle = (spec, context)=>{
            const { advancedVSeed } = context;
            const { markStyle, dataset = [] } = advancedVSeed;
            const { barStyle } = markStyle;
            const showStroke = dataset.length <= 100;
            const result = {
                ...spec,
                bar: {
                    style: {
                        visible: true,
                        fillOpacity: 1,
                        lineWidth: showStroke ? 1 : 0
                    },
                    state: {
                        hover: {
                            fillOpacity: 0.6
                        }
                    }
                }
            };
            if (chunk_JK3VNB42_n(barStyle) || chunk_VCYTMP4D_n(barStyle)) return result;
            const barStyles = Array.isArray(barStyle) ? barStyle : [
                barStyle
            ];
            const customMap = barStyles.reduce((result, style, index)=>{
                const { barBorderColor, barBorderStyle, barBorderWidth = 1, barColor, barColorOpacity, barBorderOpacity, barRadius, barVisible = true } = style;
                const lineDash = 'dashed' === barBorderStyle ? [
                    5,
                    2
                ] : 'dotted' === barBorderStyle ? [
                    2,
                    5
                ] : [
                    0,
                    0
                ];
                return {
                    ...result,
                    [`custom${index + 1}`]: {
                        level: index + 1,
                        filter: (datum)=>{
                            if (selector_selector(datum, style.selector)) return true;
                            return false;
                        },
                        style: {
                            visible: barVisible,
                            fill: barColor,
                            fillOpacity: barColorOpacity,
                            cornerRadius: barRadius,
                            lineWidth: barBorderWidth,
                            stroke: barBorderColor,
                            strokeOpacity: barBorderOpacity,
                            lineDash: lineDash
                        }
                    }
                };
            }, {});
            result.bar.state = {
                ...result.bar.state,
                ...customMap
            };
            return result;
        };
        const annotationAreaBand = (spec, context)=>{
            const { advancedVSeed, vseed } = context;
            const { annotation, config } = advancedVSeed;
            if (!annotation || !annotation.annotationArea) return spec;
            const theme = config?.[vseed.chartType]?.annotation?.annotationArea;
            const { annotationArea } = annotation;
            const annotationAreaList = Array.isArray(annotationArea) ? annotationArea : [
                annotationArea
            ];
            const positionMap = {
                top: 'insideTop',
                topRight: 'insideTopRight',
                topLeft: 'insideTopLeft',
                bottom: 'insideBottom',
                bottomLeft: 'insideBottomLeft',
                bottomRight: 'insideBottomRight',
                left: 'insideLeft',
                right: 'insideRight'
            };
            const defaultTextPosition = isBarLikeChart(advancedVSeed) ? 'right' : 'top';
            const markArea = annotationAreaList.flatMap((annotationArea)=>{
                const { selector: selectorPoint, text = '', textColor = theme?.textColor ?? '#ffffff', textFontSize = theme?.textFontSize ?? 12, textFontWeight = theme?.textFontWeight ?? 400, textBackgroundVisible = theme?.textBackgroundVisible ?? true, textBackgroundColor = theme?.textBackgroundColor ?? '#191d24', textBackgroundBorderColor = theme?.textBackgroundBorderColor ?? '#191d24', textBackgroundBorderWidth = theme?.textBackgroundBorderWidth ?? 1, textBackgroundBorderRadius = theme?.textBackgroundBorderRadius ?? 4, textBackgroundPadding = theme?.textBackgroundPadding ?? 4, areaColor = theme?.areaColor ?? '#888888', areaColorOpacity = theme?.areaColorOpacity ?? 0.15, areaBorderColor = theme?.areaBorderColor ?? '#888888', areaBorderRadius = theme?.areaBorderRadius ?? 4, areaBorderWidth = theme?.areaBorderWidth ?? 1, areaLineDash = theme?.areaLineDash, outerPadding = theme?.outerPadding ?? 4 } = annotationArea;
                const textPosition = annotationArea.textPosition ?? defaultTextPosition;
                const textAlign = annotationArea.textAlign ?? ANNOTATION_AREA_TEXT_STYLE_BY_POSITION[textPosition].textAlign;
                const textBaseline = annotationArea.textBaseline ?? ANNOTATION_AREA_TEXT_STYLE_BY_POSITION[textPosition].textBaseline;
                const dataset = advancedVSeed.dataset.flat();
                const selectedData = selectorPoint ? dataset.filter((datum)=>selector_selector(datum, selectorPoint)) : [];
                return {
                    zIndex: 1000,
                    regionRelative: true,
                    positions: (data, context)=>{
                        const positionData = data.filter((item)=>selectedData.some((datum)=>isSubset(datum, item)));
                        const xyList = positionData.map((datum)=>context.dataToPosition(datum));
                        const bandPosition = context?._scaleConfig?.bandPosition || 0;
                        const yAxisHelper = context.getYAxisHelper();
                        const xAxisHelper = context.getXAxisHelper();
                        if ('function' == typeof xAxisHelper?.getBandwidth) {
                            const depth = context.fieldX.length ?? 0;
                            const xBandWidth = xAxisHelper?.getBandwidth?.(depth - 1);
                            const regionRect = context.getRegion().getLayoutRect();
                            const startX = Math.min(...xyList.map((item)=>item.x)) - (outerPadding || 4);
                            const endX = Math.max(...xyList.map((item)=>item.x)) + (outerPadding || 4);
                            const width = endX - startX + xBandWidth;
                            const middleX = (endX + startX) / 2 + xBandWidth * (0.5 - bandPosition);
                            const minX = middleX - width / 2;
                            const maxX = middleX + width / 2;
                            const minY = 0;
                            const maxY = regionRect.height;
                            return [
                                {
                                    x: minX,
                                    y: minY
                                },
                                {
                                    x: maxX,
                                    y: minY
                                },
                                {
                                    x: maxX,
                                    y: maxY
                                },
                                {
                                    x: minX,
                                    y: maxY
                                }
                            ];
                        }
                        if ('function' == typeof yAxisHelper?.getBandwidth) {
                            const depth = context.fieldY.length ?? 0;
                            const yBandWidth = yAxisHelper?.getBandwidth?.(depth - 1);
                            const regionRect = context.getRegion().getLayoutRect();
                            const startY = Math.min(...xyList.map((item)=>item.y)) - (outerPadding || 4);
                            const endY = Math.max(...xyList.map((item)=>item.y)) + (outerPadding || 4);
                            const width = endY - startY + yBandWidth;
                            const middleY = (endY + startY) / 2 + yBandWidth * (0.5 - bandPosition);
                            const minY = middleY - width / 2;
                            const maxY = middleY + width / 2;
                            const minX = 0;
                            const maxX = regionRect.width;
                            return [
                                {
                                    x: minX,
                                    y: minY
                                },
                                {
                                    x: maxX,
                                    y: minY
                                },
                                {
                                    x: maxX,
                                    y: maxY
                                },
                                {
                                    x: minX,
                                    y: maxY
                                }
                            ];
                        }
                        return [];
                    },
                    label: {
                        position: positionMap[textPosition],
                        visible: true,
                        text: text,
                        style: {
                            opacity: 0.95,
                            textAlign: textAlign,
                            textBaseline: textBaseline,
                            stroke: textBackgroundColor,
                            lineWidth: 1,
                            fill: textColor,
                            fontSize: textFontSize,
                            fontWeight: textFontWeight
                        },
                        labelBackground: {
                            visible: textBackgroundVisible,
                            padding: textBackgroundPadding,
                            style: {
                                opacity: 0.95,
                                cornerRadius: textBackgroundBorderRadius ?? 4,
                                fill: textBackgroundColor,
                                stroke: textBackgroundBorderColor,
                                lineWidth: textBackgroundBorderWidth,
                                fillOpacity: 1
                            }
                        }
                    },
                    area: {
                        style: {
                            visible: true,
                            fill: areaColor,
                            fillOpacity: areaColorOpacity,
                            stroke: areaBorderColor,
                            lineWidth: areaBorderWidth,
                            cornerRadius: areaBorderRadius,
                            lineDash: areaLineDash
                        }
                    }
                };
            });
            return {
                ...spec,
                markArea: markArea
            };
        };
        function invNorm(p) {
            if (p <= 0 || p >= 1) return 0;
            const c1 = -0.00778489400243029, c2 = -0.322396458041136, c3 = -2.40075827716184, c4 = -2.54973253934373, c5 = 4.37466414146497, c6 = 2.93816398269878, d1 = .00778469570904146, d2 = .32246712907004, d3 = 2.445134137143, d4 = 3.75440866190742;
            let q, r;
            return p < .02425 ? (q = Math.sqrt(-2 * Math.log(p)), (((((c1 * q + c2) * q + c3) * q + c4) * q + c5) * q + c6) / ((((d1 * q + d2) * q + d3) * q + d4) * q + 1)) : p <= .97575 ? (q = p - .5, r = q * q, (((((-39.6968302866538 * r + 220.946098424521) * r - 275.928510446969) * r + 138.357751867269) * r - 30.6647980661472) * r + 2.50662827745924) * q / (((((-54.4760987982241 * r + 161.585836858041) * r - 155.698979859887) * r + 66.8013118877197) * r - 13.2806815528857) * r + 1)) : (q = Math.sqrt(-2 * Math.log(1 - p)), -(((((c1 * q + c2) * q + c3) * q + c4) * q + c5) * q + c6) / ((((d1 * q + d2) * q + d3) * q + d4) * q + 1));
        }
        function computeLinearCIComponents(data, x, y, predict) {
            let min = 1 / 0, max = -1 / 0, n = 0, sumX = 0;
            for(let i = 0; i < data.length; i++){
                const d = data[i];
                let dx = x(d), dy = y(d);
                !common_isNil(dx) && (dx *= 1) >= dx && !common_isNil(dy) && (dy *= 1) >= dy && (dx < min && (min = dx), dx > max && (max = dx), n++, sumX += dx);
            }
            if (0 === n) return {
                min: min,
                max: max,
                n: n,
                X: 0,
                SSE: 0,
                Sxx: 0
            };
            const X = sumX / n;
            let SSE = 0, Sxx = 0;
            for(let i = 0; i < data.length; i++){
                const d = data[i];
                let dx = x(d), dy = y(d);
                if (!common_isNil(dx) && (dx *= 1) >= dx && !common_isNil(dy) && (dy *= 1) >= dy) {
                    const r = dy - predict(dx);
                    SSE += r * r;
                    const dxc = dx - X;
                    Sxx += dxc * dxc;
                }
            }
            return {
                min: min,
                max: max,
                n: n,
                X: X,
                SSE: SSE,
                Sxx: Sxx
            };
        }
        function stdErrorsAt(px, comps) {
            const { n: n, X: X, Sxx: Sxx, SSE: SSE } = comps, s2 = n > 2 ? SSE / (n - 2) : 0;
            return {
                seMean: Sxx > 0 ? Math.sqrt(s2 * (1 / n + (px - X) * (px - X) / Sxx)) : Math.sqrt(s2 / n),
                sePred: Math.sqrt(s2 * (1 + 1 / n + (Sxx > 0 ? (px - X) * (px - X) / Sxx : 0)))
            };
        }
        function ordinaryLeastSquares(uX, uY, uXY, uX2) {
            const denom = uX2 - uX * uX;
            if (Math.abs(denom) < Number.EPSILON) return {
                a: uY,
                b: 0
            };
            const b = (uXY - uX * uY) / denom;
            return {
                a: uY - b * uX,
                b: b
            };
        }
        function visitPoints(data, x, y, callback) {
            for(let i = 0; i < data.length; i++){
                const d = data[i];
                let xi = x(d), yi = y(d);
                !common_isNil(xi) && (xi *= 1) >= xi && !common_isNil(yi) && (yi *= 1) >= yi && callback(xi, yi, i);
            }
        }
        function rSquared(data, x, y, uY, predict) {
            let ssr = 0, sst = 0;
            for(let i = 0; i < data.length; i++){
                const d = data[i];
                let yi = y(d);
                if (!common_isNil(yi) && (yi *= 1) >= yi) {
                    const r = yi - predict(x(d));
                    ssr += r * r;
                    const t = yi - uY;
                    sst += t * t;
                }
            }
            return 0 === sst ? 0 : 1 - ssr / sst;
        }
        function regressionLinear(data, x = (d)=>d.x, y = (d)=>d.y, options) {
            var _a;
            const alpha = null != (_a = null == options ? void 0 : options.alpha) ? _a : .05;
            let n = 0, meanX = 0, meanY = 0, meanXY = 0, meanX2 = 0;
            visitPoints(data, x, y, (xi, yi)=>{
                n++, meanX += (xi - meanX) / n, meanY += (yi - meanY) / n, meanXY += (xi * yi - meanXY) / n, meanX2 += (xi * xi - meanX2) / n;
            });
            const { a: a, b: b } = ordinaryLeastSquares(meanX, meanY, meanXY, meanX2), predict = (xx)=>a + b * xx, comps = computeLinearCIComponents(data, x, y, predict);
            return {
                coef: {
                    a: a,
                    b: b
                },
                predict: predict,
                rSquared: rSquared(data, x, y, meanY, predict),
                evaluateGrid: function(N) {
                    const out = [];
                    if (0 === comps.n || N <= 0) return out;
                    if (comps.min === comps.max) {
                        for(let i = 0; i < N; i++)out.push({
                            x: comps.min,
                            y: predict(comps.min)
                        });
                        return out;
                    }
                    const step = (comps.max - comps.min) / (N - 1);
                    for(let i = 0; i < N; i++){
                        const px = i === N - 1 ? comps.max : comps.min + step * i;
                        out.push({
                            x: px,
                            y: predict(px)
                        });
                    }
                    return out;
                },
                confidenceInterval: function(N = 50) {
                    const out = [];
                    if (0 === comps.n || N <= 0) return out;
                    const z = invNorm(1 - alpha / 2);
                    if (comps.min === comps.max) {
                        const m = predict(comps.min), errs = stdErrorsAt(comps.min, comps);
                        for(let i = 0; i < N; i++)out.push({
                            x: comps.min,
                            mean: m,
                            lower: m - z * errs.seMean,
                            upper: m + z * errs.seMean,
                            predLower: m - z * errs.sePred,
                            predUpper: m + z * errs.sePred
                        });
                        return out;
                    }
                    const step = (comps.max - comps.min) / (N - 1);
                    for(let i = 0; i < N; i++){
                        const px = i === N - 1 ? comps.max : comps.min + step * i, m = predict(px), errs = stdErrorsAt(px, comps);
                        out.push({
                            x: px,
                            mean: m,
                            lower: m - z * errs.seMean,
                            upper: m + z * errs.seMean,
                            predLower: m - z * errs.sePred,
                            predUpper: m + z * errs.sePred
                        });
                    }
                    return out;
                }
            };
        }
        function solveLinearSystem(A, b) {
            const n = b.length, M = new Array(n);
            for(let i = 0; i < n; i++)M[i] = A[i].slice(), M[i].push(b[i]);
            for(let k = 0; k < n; k++){
                let maxRow = k, maxVal = Math.abs(M[k][k]);
                for(let i = k + 1; i < n; i++){
                    const v = Math.abs(M[i][k]);
                    v > maxVal && (maxVal = v, maxRow = i);
                }
                if (maxRow !== k) {
                    const tmp = M[k];
                    M[k] = M[maxRow], M[maxRow] = tmp;
                }
                if (Math.abs(M[k][k]) < 1e-12) return new Array(n).fill(0);
                for(let j = k + 1; j <= n; j++)M[k][j] = M[k][j] / M[k][k];
                M[k][k] = 1;
                for(let i = 0; i < n; i++){
                    if (i === k) continue;
                    const factor = M[i][k];
                    if (0 !== factor) {
                        for(let j = k + 1; j <= n; j++)M[i][j] -= factor * M[k][j];
                        M[i][k] = 0;
                    }
                }
            }
            const x = new Array(n);
            for(let i = 0; i < n; i++)x[i] = M[i][n];
            return x;
        }
        function regressionPolynomial(data, x = (d)=>d.x, y = (d)=>d.y, options = {}) {
            var _a, _b;
            let degree = null != (_a = options.degree) ? _a : 0;
            degree < 0 && (degree = 0);
            const alpha = null != (_b = options.alpha) ? _b : .05, m = degree + 1, sums = new Array(2 * degree + 1).fill(0);
            visitPoints(data, x, y, (dx, dy)=>{
                let xp = 1;
                for(let k = 0; k < sums.length; k++)sums[k] += xp, xp *= dx;
            });
            const A = new Array(m);
            for(let i = 0; i < m; i++){
                A[i] = new Array(m).fill(0);
                for(let j = 0; j < m; j++)A[i][j] = sums[i + j];
            }
            const B = new Array(m).fill(0);
            visitPoints(data, x, y, (dx, dy)=>{
                let xp = 1;
                for(let k = 0; k < m; k++)B[k] += dy * xp, xp *= dx;
            });
            const coef = solveLinearSystem(A, B), predict = (xx)=>{
                let xp = 1, v = 0;
                for(let k = 0; k < coef.length; k++)v += coef[k] * xp, xp *= xx;
                return v;
            };
            return {
                degree: degree,
                coef: coef,
                predict: predict,
                rSquared: rSquared(data, x, y, (()=>{
                    let sum = 0, cnt = 0;
                    return visitPoints(data, x, y, (_dx, dy)=>{
                        sum += dy, cnt++;
                    }), 0 === cnt ? 0 : sum / cnt;
                })(), predict),
                evaluateGrid (N) {
                    const out = [];
                    if (N <= 0) return out;
                    let min = 1 / 0, max = -1 / 0;
                    if (visitPoints(data, x, y, (dx)=>{
                        common_isNil(dx) || (dx < min && (min = dx), dx > max && (max = dx));
                    }), min === 1 / 0 || max === -1 / 0) return out;
                    if (min === max) {
                        const v = predict(min);
                        for(let i = 0; i < N; i++)out.push({
                            x: min,
                            y: v
                        });
                        return out;
                    }
                    const step = (max - min) / (N - 1);
                    for(let i = 0; i < N; i++){
                        const px = i === N - 1 ? max : min + step * i;
                        out.push({
                            x: px,
                            y: predict(px)
                        });
                    }
                    return out;
                },
                confidenceInterval (N = 50) {
                    const out = [];
                    if (N <= 0) return out;
                    const comps = computeLinearCIComponents(data, x, y, predict);
                    if (0 === comps.n) return out;
                    const z = Math.abs(invNorm(1 - alpha / 2));
                    if (comps.min === comps.max) {
                        const v = predict(comps.min), errs = stdErrorsAt(comps.min, comps);
                        for(let i = 0; i < N; i++)out.push({
                            x: comps.min,
                            mean: v,
                            lower: v - z * errs.seMean,
                            upper: v + z * errs.seMean,
                            predLower: v - z * errs.sePred,
                            predUpper: v + z * errs.sePred
                        });
                        return out;
                    }
                    const step = (comps.max - comps.min) / (N - 1);
                    for(let i = 0; i < N; i++){
                        const px = i === N - 1 ? comps.max : comps.min + step * i, yh = predict(px), errs = stdErrorsAt(px, comps);
                        out.push({
                            x: px,
                            mean: yh,
                            lower: yh - z * errs.seMean,
                            upper: yh + z * errs.seMean,
                            predLower: yh - z * errs.sePred,
                            predUpper: yh + z * errs.sePred
                        });
                    }
                    return out;
                }
            };
        }
        const defaultRegressionLineColor = (datum, ctx, opt)=>{
            const parentNode = opt.mark?._product?.parent;
            if (parentNode?.attribute?.data) return parentNode.attribute.data.color;
        };
        const defaultRegressionLineLabelX = (datum, ctx, opt)=>{
            const parentNode = opt.mark?._product?.parent;
            if (parentNode?.attribute?.data?.linePoints) {
                const points = parentNode.attribute.data.linePoints;
                return points[points.length - 1]?.x;
            }
        };
        const defaultRegressionLineLabelY = (datum, ctx, opt)=>{
            const parentNode = opt.mark?._product?.parent;
            if (parentNode?.attribute?.data?.linePoints) {
                const points = parentNode.attribute.data.linePoints;
                return points[points.length - 1]?.y;
            }
        };
        const getAlphaByConfidenceLevel = (confidenceLevel = 0.95)=>1 - Math.max(Math.min(1, confidenceLevel), 0);
        const columnPolynomialRegressionLine = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed } = context;
            const { chartType, regressionLine } = advancedVSeed;
            const lineTheme = advancedVSeed.config[chartType]?.regressionLine;
            if (!regressionLine || !regressionLine.polynomialRegressionLine) return result;
            const lineList = array_array(regressionLine.polynomialRegressionLine);
            if (!result.extensionMark) result.extensionMark = [];
            lineList.forEach((line, lineIndex)=>{
                if (false === line.enable) return;
                const theme = lineTheme.linearRegressionLine ?? {};
                const { color, lineWidth, lineDash, text, textColor, textFontSize, textFontWeight, confidenceIntervalOpacity, confidenceLevel = 0.95, confidenceIntervalVisible = theme.confidenceIntervalVisible } = line;
                const childrenMarks = [];
                result.extensionMark.push({
                    type: 'group',
                    interactive: false,
                    zIndex: 500,
                    name: `polynomialRegressionLine-${lineIndex}`,
                    dataId: spec.data?.id,
                    style: {
                        data: (datum, ctx)=>{
                            const vchart = ctx.vchart;
                            const chart = vchart.getChart();
                            const s = chart.getAllSeries()[0];
                            if (s) {
                                const rect = s.getRegion().getLayoutRect();
                                if (0 === rect.width || 0 === rect.height) return null;
                                const yClamper = clamper(0, 0 + rect.height);
                                const data = s.getViewData()?.latestData;
                                const fieldX = s.fieldX?.[0];
                                const fieldY = s.fieldY?.[0];
                                const xValues = s.getRawDataStatisticsByField(fieldX).values;
                                const degree = line.degree ?? 2;
                                const minPoints = degree + 1;
                                if (!fieldX || !fieldY || !data || data.length < minPoints || xValues.length < minPoints) return null;
                                const { confidenceInterval, evaluateGrid } = regressionPolynomial(xValues.map((xVal, index)=>{
                                    const filteredData = data.filter((d)=>d[fieldX] === xVal);
                                    return {
                                        x: index,
                                        y: Math.max(...filteredData.map((d)=>d[fieldY]))
                                    };
                                }), void 0, void 0, {
                                    degree: line.degree ?? 2,
                                    alpha: getAlphaByConfidenceLevel(confidenceLevel)
                                });
                                const N = xValues.length;
                                const xAxisHelper = s.getXAxisHelper();
                                const halfBandWidth = xAxisHelper ? xAxisHelper.getBandwidth(0) / 2 : 0;
                                const lineData = evaluateGrid(N);
                                const linePoints = lineData.map((datum, index)=>{
                                    const d = {
                                        [fieldX]: xValues[index],
                                        [fieldY]: datum.y
                                    };
                                    return {
                                        x: s.dataToPositionX(d) + halfBandWidth,
                                        y: yClamper(s.dataToPositionY(d))
                                    };
                                });
                                const result = {
                                    linePoints,
                                    color: s.getOption().globalScale.getScale('color')?.scale(s.getSeriesKeys()[0])
                                };
                                if (confidenceIntervalVisible) {
                                    const intervalData = confidenceInterval(N);
                                    result.areaPoints = intervalData.map((datum, index)=>{
                                        const d = {
                                            [fieldX]: xValues[index],
                                            [fieldY]: datum.lower
                                        };
                                        return {
                                            x: s.dataToPositionX(d) + halfBandWidth,
                                            y: yClamper(s.dataToPositionY(d)),
                                            y1: yClamper(s.dataToPositionY({
                                                [fieldY]: datum.upper
                                            }))
                                        };
                                    });
                                }
                                return result;
                            }
                            return null;
                        }
                    },
                    children: childrenMarks
                });
                if (confidenceIntervalVisible) childrenMarks.push({
                    type: 'area',
                    interactive: false,
                    zIndex: 500,
                    dataId: spec.data?.id,
                    style: {
                        lineWidth: lineWidth ?? theme.lineWidth,
                        lineDash: lineDash ?? theme.lineDash,
                        fillOpacity: confidenceIntervalOpacity ?? theme.confidenceIntervalOpacity,
                        fill: color ?? defaultRegressionLineColor,
                        points: (datum, ctx, opt)=>{
                            const parentNode = opt.mark?._product?.parent;
                            if (parentNode?.attribute?.data) return parentNode.attribute.data.areaPoints;
                            return [];
                        }
                    }
                });
                childrenMarks.push({
                    type: 'line',
                    interactive: false,
                    zIndex: 500,
                    dataId: spec.data?.id,
                    style: {
                        lineWidth: lineWidth ?? theme.lineWidth,
                        lineDash: lineDash ?? theme.lineDash,
                        stroke: color ?? defaultRegressionLineColor,
                        points: (datum, ctx, opt)=>{
                            const parentNode = opt.mark?._product?.parent;
                            if (parentNode?.attribute?.data) return parentNode.attribute.data.linePoints;
                            return [];
                        }
                    }
                });
                if (!chunk_JK3VNB42_n(text)) childrenMarks.push({
                    type: 'text',
                    interactive: false,
                    zIndex: 500,
                    dataId: spec.data?.id,
                    dataKey: ()=>`polynomialRegressionLine-label-${lineIndex}`,
                    style: {
                        textAlign: 'end',
                        fill: textColor ?? theme.textColor,
                        fontSize: textFontSize ?? theme.textFontSize,
                        fontWeight: textFontWeight ?? theme.textFontWeight,
                        text: text,
                        x: (datum, ctx, opt)=>{
                            const parentNode = opt.mark?._product?.parent;
                            if (parentNode?.attribute?.data?.linePoints) {
                                const points = parentNode.attribute.data.linePoints;
                                return points[points.length - 1]?.x;
                            }
                        },
                        y: (datum, ctx, opt)=>{
                            const parentNode = opt.mark?._product?.parent;
                            if (parentNode?.attribute?.data?.linePoints) {
                                const points = parentNode.attribute.data.linePoints;
                                return points[points.length - 1]?.y;
                            }
                        }
                    }
                });
            });
            return result;
        };
        const column = [
            initColumn,
            stackCornerRadius_stackCornerRadius,
            barMaxWidth_barMaxWidth,
            stackInverse,
            colorAdapter(color_color, linearColor),
            background_backgroundColor,
            datasetXY,
            progressive,
            xBand,
            yLinear,
            label_label,
            tooltip_tooltip,
            verticalCrosshairRect,
            colorAdapter(discreteLegend, colorLegend),
            colorBarStyleFill(barStyle_barStyle),
            annotationPoint_annotationPoint,
            annotationVerticalLine_annotationVerticalLine,
            annotationHorizontalLine_annotationHorizontalLine,
            annotationAreaBand,
            columnPolynomialRegressionLine
        ];
        const pivotColumn = [
            initPivot,
            pivotGridStyle,
            pivotIndicatorsAsRow,
            datasetPivot,
            pivotIndicators_pivotIndicators([
                initColumn,
                stackCornerRadius_stackCornerRadius,
                barMaxWidth_barMaxWidth,
                stackInverse,
                colorAdapter(color_color, linearColor),
                background_backgroundColor,
                datasetXY,
                progressive,
                xBand,
                pivotAxisStyle(yLinear),
                label_label,
                tooltip_tooltip,
                verticalCrosshairRect,
                colorBarStyleFill(barStyle_barStyle),
                annotationPoint_annotationPoint,
                annotationVerticalLine_annotationVerticalLine,
                annotationHorizontalLine_annotationHorizontalLine,
                annotationAreaBand,
                columnPolynomialRegressionLine
            ]),
            pivotRowDimensions,
            pivotColumnDimensions,
            pivotTitle,
            colorAdapter(pivotDiscreteLegend, pivotColorLegend),
            dimensionLinkage
        ];
        const columnSpecPipeline = [
            pivotAdapter_pivotAdapter(column, pivotColumn)
        ];
        const registerColumn = ()=>{
            Builder._advancedPipelineMap.column = columnAdvancedPipeline;
            Builder._specPipelineMap.column = columnSpecPipeline;
        };
        const pieConfig = (advancedVSeed, context)=>{
            const { vseed } = context;
            const { chartType } = vseed;
            const result = {
                ...advancedVSeed
            };
            const pickedConfig = chunk_2T7K3PFL_i(vseed, [
                'backgroundColor',
                'color',
                'label',
                'legend',
                'tooltip'
            ]);
            const config = replaceNullToUndefined(pickedConfig);
            result.config = {
                ...result.config || {},
                [chartType]: {
                    ...config
                }
            };
            return result;
        };
        const areaConfig = line_lineConfig;
        const areaPercentConfig = line_lineConfig;
        const barConfig = columnConfig;
        const barParallelConfig = columnConfig;
        const barPercentConfig = columnConfig;
        const columnParallelConfig = columnConfig;
        const columnPercentConfig = columnConfig;
        const donutConfig = pieConfig;
        const roseConfig = pieConfig;
        const roseParallelConfig = pieConfig;
        const radarConfig = pieConfig;
        const funnelConfig = pieConfig;
        const heatmapConfig = pieConfig;
        const columnParallelAdvancedPipeline = [
            initAdvancedVSeed_initAdvancedVSeed,
            default_defaultMeasures_defaultMeasures,
            defaultDimensions_defaultDimensions,
            defaultMeasureId_defaultMeasureId,
            encodingAdapter([
                defaultEncodingForColumn,
                buildMeasures
            ], [
                encodingForColumn,
                buildMeasures,
                pickMeasuresForReshape([
                    'tooltip',
                    'label',
                    'color'
                ]),
                pickDimensionsForReshape
            ]),
            pivotAdapter([
                reshapeWithEncoding
            ], [
                pivotReshapeWithEncoding
            ]),
            sortXBandAxis,
            sortLegend_sortLegend,
            columnParallelConfig,
            theme_theme,
            markStyle_markStyle,
            annotation_annotation
        ];
        function chunk_HGKLN5KY_k(...n) {
            return chunk_WIMGWYZL_u(chunk_HGKLN5KY_u, n);
        }
        function chunk_HGKLN5KY_u(n, e) {
            if (n === e || Object.is(n, e)) return !0;
            if ("object" != typeof n || "object" != typeof e || null === n || null === e || Object.getPrototypeOf(n) !== Object.getPrototypeOf(e)) return !1;
            if (Array.isArray(n)) return chunk_HGKLN5KY_l(n, e);
            if (n instanceof Map) return chunk_HGKLN5KY_a(n, e);
            if (n instanceof Set) return chunk_HGKLN5KY_c(n, e);
            if (n instanceof Date) return n.getTime() === e.getTime();
            if (n instanceof RegExp) return n.toString() === e.toString();
            if (Object.keys(n).length !== Object.keys(e).length) return !1;
            for (let [r, t] of Object.entries(n))if (!(r in e) || !chunk_HGKLN5KY_u(t, e[r])) return !1;
            return !0;
        }
        function chunk_HGKLN5KY_l(n, e) {
            if (n.length !== e.length) return !1;
            for (let [r, t] of n.entries())if (!chunk_HGKLN5KY_u(t, e[r])) return !1;
            return !0;
        }
        function chunk_HGKLN5KY_a(n, e) {
            if (n.size !== e.size) return !1;
            for (let [r, t] of n.entries())if (!e.has(r) || !chunk_HGKLN5KY_u(t, e.get(r))) return !1;
            return !0;
        }
        function chunk_HGKLN5KY_c(n, e) {
            if (n.size !== e.size) return !1;
            let r = [
                ...e
            ];
            for (let t of n){
                let o = !1;
                for (let [s, f] of r.entries())if (chunk_HGKLN5KY_u(t, f)) {
                    o = !0, r.splice(s, 1);
                    break;
                }
                if (!o) return !1;
            }
            return !0;
        }
        const initColumnParallel = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed } = context;
            const { datasetReshapeInfo, encoding } = advancedVSeed;
            const { unfoldInfo, foldInfo } = datasetReshapeInfo[0];
            const sameDimensionsMode = chunk_HGKLN5KY_k(encoding.x, encoding.color);
            result.type = 'bar';
            result.direction = 'vertical';
            result.xField = [
                unfoldInfo.encodingX
            ];
            if (!sameDimensionsMode) {
                result.xField.push(unfoldInfo.encodingDetail);
                if (encoding.detail?.[0] === MeasureId && encoding.y?.length === 1) result.xField.pop();
            }
            result.yField = foldInfo.measureValue;
            result.seriesField = unfoldInfo.encodingColorId;
            result.padding = 0;
            result.region = [
                {
                    clip: true
                }
            ];
            result.animation = true;
            return result;
        };
        const barGapInGroup_barGapInGroup = (spec, context)=>{
            const { advancedVSeed, vseed } = context;
            const { chartType } = vseed;
            const barGapInGroup = advancedVSeed.config?.[chartType]?.barGapInGroup;
            if (!chunk_JK3VNB42_n(barGapInGroup)) return {
                ...spec,
                barGapInGroup
            };
            return spec;
        };
        const columnParallel = [
            initColumnParallel,
            stackCornerRadius_stackCornerRadius,
            barMaxWidth_barMaxWidth,
            barGapInGroup_barGapInGroup,
            colorAdapter(color_color, linearColor),
            background_backgroundColor,
            datasetXY,
            progressive,
            xBand,
            yLinear,
            label_label,
            tooltip_tooltip,
            colorAdapter(discreteLegend, colorLegend),
            verticalCrosshairRect,
            colorBarStyleFill(barStyle_barStyle),
            annotationPoint_annotationPoint,
            annotationVerticalLine_annotationVerticalLine,
            annotationHorizontalLine_annotationHorizontalLine,
            annotationAreaBand
        ];
        const pivotColumnParallel = [
            initPivot,
            pivotGridStyle,
            pivotIndicatorsAsRow,
            datasetPivot,
            pivotIndicators_pivotIndicators([
                initColumnParallel,
                stackCornerRadius_stackCornerRadius,
                barMaxWidth_barMaxWidth,
                colorAdapter(color_color, linearColor),
                background_backgroundColor,
                datasetXY,
                progressive,
                xBand,
                pivotAxisStyle(yLinear),
                label_label,
                tooltip_tooltip,
                verticalCrosshairRect,
                colorBarStyleFill(barStyle_barStyle),
                annotationPoint_annotationPoint,
                annotationVerticalLine_annotationVerticalLine,
                annotationHorizontalLine_annotationHorizontalLine,
                annotationAreaBand
            ]),
            pivotRowDimensions,
            pivotColumnDimensions,
            pivotTitle,
            colorAdapter(pivotDiscreteLegend, pivotColorLegend),
            dimensionLinkage
        ];
        const columnParallelSpecPipeline = [
            pivotAdapter_pivotAdapter(columnParallel, pivotColumnParallel)
        ];
        const registerColumnParallel = ()=>{
            Builder._advancedPipelineMap.columnParallel = columnParallelAdvancedPipeline;
            Builder._specPipelineMap.columnParallel = columnParallelSpecPipeline;
        };
        const columnPercentAdvancedPipeline = [
            initAdvancedVSeed_initAdvancedVSeed,
            default_defaultMeasures_defaultMeasures,
            defaultDimensions_defaultDimensions,
            defaultMeasureId_defaultMeasureId,
            encodingAdapter([
                defaultEncodingForColumn,
                buildMeasures
            ], [
                encodingForColumn,
                buildMeasures,
                pickMeasuresForReshape([
                    'tooltip',
                    'label',
                    'color'
                ]),
                pickDimensionsForReshape
            ]),
            pivotAdapter([
                reshapeWithEncoding
            ], [
                pivotReshapeWithEncoding
            ]),
            sortXBandAxis,
            sortLegend_sortLegend,
            columnPercentConfig,
            theme_theme,
            markStyle_markStyle,
            annotation_annotation
        ];
        const percent_percent = (spec)=>{
            const result = {
                ...spec
            };
            result.percent = true;
            return result;
        };
        const columnPercent = [
            initColumn,
            stackCornerRadius_stackCornerRadius,
            stackInverse,
            barMaxWidth_barMaxWidth,
            colorAdapter(color_color, linearColor),
            background_backgroundColor,
            percent_percent,
            datasetXY,
            progressive,
            xBand,
            yLinear,
            label_label,
            tooltip_tooltip,
            colorAdapter(discreteLegend, colorLegend),
            verticalCrosshairRect,
            colorBarStyleFill(barStyle_barStyle),
            annotationPoint_annotationPoint,
            annotationVerticalLine_annotationVerticalLine,
            annotationHorizontalLine_annotationHorizontalLine,
            annotationAreaBand
        ];
        const pivotColumnPercent = [
            initPivot,
            pivotGridStyle,
            pivotIndicatorsAsRow,
            datasetPivot,
            pivotIndicators_pivotIndicators([
                initColumn,
                stackCornerRadius_stackCornerRadius,
                stackInverse,
                barMaxWidth_barMaxWidth,
                colorAdapter(color_color, linearColor),
                percent_percent,
                background_backgroundColor,
                datasetXY,
                progressive,
                xBand,
                pivotAxisStyle(yLinear),
                label_label,
                tooltip_tooltip,
                verticalCrosshairRect,
                colorBarStyleFill(barStyle_barStyle),
                annotationPoint_annotationPoint,
                annotationVerticalLine_annotationVerticalLine,
                annotationHorizontalLine_annotationHorizontalLine,
                annotationAreaBand
            ]),
            pivotRowDimensions,
            pivotColumnDimensions,
            pivotTitle,
            colorAdapter(pivotDiscreteLegend, pivotColorLegend),
            dimensionLinkage
        ];
        const columnPercentSpecPipeline = [
            pivotAdapter_pivotAdapter(columnPercent, pivotColumnPercent)
        ];
        const registerColumnPercent = ()=>{
            Builder._advancedPipelineMap.columnPercent = columnPercentAdvancedPipeline;
            Builder._specPipelineMap.columnPercent = columnPercentSpecPipeline;
        };
        const defaultEncodingForBar = (advancedVSeed)=>{
            const { measures: vseedMeasures = [], dimensions = [] } = advancedVSeed;
            const measures = findAllMeasures(vseedMeasures);
            const encoding = {};
            bar_generateDefaultDimensionEncoding(dimensions, encoding);
            bar_generateDefaultMeasureEncoding(measures, encoding);
            return {
                ...advancedVSeed,
                encoding
            };
        };
        const encodingForBar = (advancedVSeed)=>{
            const { measures: vseedMeasures = [], dimensions = [] } = advancedVSeed;
            const measures = findAllMeasures(vseedMeasures);
            const hasDimensionEncoding = dimensions.some((item)=>item.encoding);
            const hasMeasureEncoding = measures.some((item)=>item.encoding);
            const encoding = {};
            if (hasDimensionEncoding) bar_generateDimensionEncoding(dimensions, encoding, measures.length > 1);
            else bar_generateDefaultDimensionEncoding(dimensions, encoding);
            if (hasMeasureEncoding) bar_generateMeasureEncoding(measures, encoding);
            else bar_generateDefaultMeasureEncoding(measures, encoding);
            return {
                ...advancedVSeed,
                encoding
            };
        };
        const bar_generateDefaultDimensionEncoding = (dimensions, encoding)=>{
            const onlyMeasureId = 1 === dimensions.length && dimensions.find((item)=>item.id === MeasureId);
            const uniqueDimIds = chunk_QJLMYOTX_i(dimensions.map((d)=>d.id));
            encoding.y = uniqueDimIds.slice(0, 1);
            encoding.color = uniqueDimIds.slice(onlyMeasureId ? 0 : 1);
            encoding.detail = encoding.color;
            encoding.tooltip = uniqueDimIds.filter((d)=>d !== MeasureId);
            encoding.label = [];
            encoding.row = [];
            encoding.column = [];
        };
        const bar_generateDimensionEncoding = (dimensions, encoding, isMultiMeasure)=>{
            encoding.y = chunk_QJLMYOTX_i(dimensions.filter((item)=>'yAxis' === item.encoding).map((item)=>item.id));
            if (0 === encoding.y.length) encoding.y = [
                dimensions[0].id
            ];
            addColorToEncoding(dimensions, encoding, isMultiMeasure);
            encoding.detail = chunk_QJLMYOTX_i(dimensions.filter((item)=>'detail' === item.encoding).map((item)=>item.id));
            if (0 === encoding.detail.length) encoding.detail = encoding.color;
            encoding.tooltip = chunk_QJLMYOTX_i(dimensions.map((item)=>item.id));
            encoding.tooltip = encoding.tooltip.filter((d)=>d !== MeasureId);
            encoding.label = chunk_QJLMYOTX_i(dimensions.filter((item)=>'label' === item.encoding).map((item)=>item.id));
            encoding.label = encoding.label.filter((d)=>d !== MeasureId);
        };
        const bar_generateDefaultMeasureEncoding = (measures, encoding)=>{
            encoding.x = chunk_QJLMYOTX_i(measures.filter((item)=>'xAxis' === item.encoding || !item.encoding).map((item)=>item.id));
        };
        const bar_generateMeasureEncoding = (measures, encoding)=>{
            encoding.x = chunk_QJLMYOTX_i(measures.filter((item)=>'xAxis' === item.encoding || !item.encoding).map((item)=>item.id));
            const color = chunk_QJLMYOTX_i(measures.filter((item)=>'color' === item.encoding).map((item)=>item.id));
            if (color.length > 0) encoding.color = color;
            const label = chunk_QJLMYOTX_i(measures.filter((item)=>'label' === item.encoding).map((item)=>item.id));
            encoding.label = chunk_QJLMYOTX_i([
                ...encoding.label || [],
                ...label
            ]);
            const tooltip = chunk_QJLMYOTX_i(measures.filter((item)=>'tooltip' === item.encoding).map((item)=>item.id));
            encoding.tooltip = chunk_QJLMYOTX_i([
                ...encoding.tooltip || [],
                ...label,
                ...tooltip
            ]);
        };
        const sortYBandAxis = (advancedVSeed, context)=>{
            const result = {
                ...advancedVSeed
            };
            const { vseed } = context;
            const { sort: sortAxis } = vseed;
            const { datasetReshapeInfo, dataset } = advancedVSeed;
            const { unfoldInfo } = datasetReshapeInfo[0];
            const yField = unfoldInfo?.encodingY;
            if (!sortAxis || !yField) return advancedVSeed;
            if (!result.analysis) result.analysis = {};
            if (!result.analysis.orderMapping) result.analysis.orderMapping = {};
            const axisOrderResult = calcOrder(sortAxis, yField, dataset.flat(2));
            result.analysis.orderMapping[yField] = axisOrderResult;
            return result;
        };
        const barAdvancedPipeline = [
            initAdvancedVSeed_initAdvancedVSeed,
            default_defaultMeasures_defaultMeasures,
            defaultDimensions_defaultDimensions,
            defaultMeasureId_defaultMeasureId,
            encodingAdapter([
                defaultEncodingForBar,
                buildMeasures
            ], [
                encodingForBar,
                buildMeasures,
                pickMeasuresForReshape([
                    'tooltip',
                    'label',
                    'color'
                ]),
                pickDimensionsForReshape
            ]),
            pivotAdapter([
                reshapeWithEncoding
            ], [
                pivotReshapeWithEncoding
            ]),
            sortYBandAxis,
            sortLegend_sortLegend,
            barConfig,
            theme_theme,
            markStyle_markStyle,
            annotation_annotation
        ];
        const initBar = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed } = context;
            const { datasetReshapeInfo } = advancedVSeed;
            const { unfoldInfo, foldInfo } = datasetReshapeInfo[0];
            result.type = 'bar';
            result.direction = 'horizontal';
            result.yField = unfoldInfo.encodingY;
            result.xField = foldInfo.measureValue;
            result.seriesField = unfoldInfo.encodingColorId;
            result.padding = 0;
            result.region = [
                {
                    clip: true
                }
            ];
            result.animation = true;
            return result;
        };
        const datasetYX = (spec, context)=>{
            const { advancedVSeed, vseed } = context;
            const { analysis, datasetReshapeInfo } = advancedVSeed;
            const { unfoldInfo } = datasetReshapeInfo[0];
            const orderMapping = analysis?.orderMapping || {};
            const angle = unfoldInfo.encodingAngle;
            const y = unfoldInfo.encodingY;
            const colorId = unfoldInfo.encodingColorId;
            const id = datasetReshapeInfo[0].id;
            const fields = {};
            if (angle) fields[angle] = {
                sortIndex: 0
            };
            if (y) {
                const order = orderMapping[y];
                if (order) fields[y] = {
                    sortIndex: 0,
                    domain: order,
                    lockStatisticsByDomain: true
                };
                else fields[y] = {
                    sortIndex: 0
                };
            }
            if (colorId) {
                const order = orderMapping[colorId];
                if (order) fields[colorId] = {
                    sortIndex: 0,
                    domain: order,
                    lockStatisticsByDomain: true
                };
                else fields[colorId] = {
                    sortIndex: 0
                };
            }
            return {
                ...spec,
                data: {
                    id,
                    values: isPivotChart(vseed) ? void 0 : advancedVSeed.dataset,
                    fields: fields
                }
            };
        };
        const xLinear = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed, vseed } = context;
            const { encoding, dimensions, measures } = advancedVSeed;
            const { chartType } = vseed;
            const config = advancedVSeed.config?.[chartType]?.xAxis ?? {};
            if (!result.axes) result.axes = [];
            const isPivot = isPivotChart(vseed);
            const { visible = true, label, tick, title, grid, line, zero, nice, inverse, max, min, log, logBase = 10, autoFormat, numFormat = {} } = config;
            const formatter = createNumFormatter(numFormat);
            const percentFormatter = createNumFormatter({
                type: 'percent'
            });
            const linearAxis = {
                ...isPivot ? {
                    range: {
                        min,
                        max
                    }
                } : {
                    min,
                    max
                },
                visible,
                type: log ? 'log' : 'linear',
                base: logBase,
                orient: 'bottom',
                nice,
                zero: log ? false : zero,
                inverse,
                label: {
                    space: 8,
                    visible: label?.visible,
                    formatMethod: (value)=>{
                        if (isBarPercent(vseed) || isColumnPercent(vseed) || isAreaPercent(vseed)) return createLinearPercentFormat(value, autoFormat, numFormat, formatter, percentFormatter);
                        return createLinearFormat(value, autoFormat, numFormat, formatter);
                    },
                    style: {
                        fill: label?.labelColor,
                        angle: label?.labelAngle,
                        fontSize: label?.labelFontSize,
                        fontWeight: label?.labelFontWeight
                    }
                },
                title: {
                    visible: title?.visible,
                    text: title?.titleText || defaultTitleText(measures, dimensions, encoding.x),
                    style: {
                        fill: title?.titleColor,
                        fontSize: title?.titleFontSize,
                        fontWeight: title?.titleFontWeight
                    }
                },
                tick: {
                    visible: tick?.visible,
                    tickSize: tick?.tickSize,
                    inside: tick?.tickInside,
                    style: {
                        stroke: tick?.tickColor
                    }
                },
                grid: {
                    visible: grid?.visible,
                    style: {
                        lineWidth: grid?.gridWidth,
                        stroke: grid?.gridColor,
                        lineDash: grid?.gridLineDash
                    }
                },
                domainLine: {
                    visible: line?.visible,
                    style: {
                        lineWidth: line?.lineWidth,
                        stroke: line?.lineColor
                    }
                },
                innerOffset: {
                    right: 12
                }
            };
            result.axes = [
                ...result.axes,
                linearAxis
            ];
            return result;
        };
        const yBand = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed, vseed } = context;
            const { chartType } = vseed;
            const { measures, dimensions, encoding, datasetReshapeInfo, pivotAllDatasetReshapeInfo } = advancedVSeed;
            const config = advancedVSeed.config?.[chartType]?.yAxis ?? {};
            if (!result.axes) result.axes = [];
            const { visible = true, label, tick, title, grid, line, labelAutoHide, labelAutoHideGap, labelAutoLimit, labelAutoLimitLength = 80, labelAutoRotate, labelAutoRotateAngleRange } = config;
            const sampling = !(labelAutoHide || labelAutoRotate || labelAutoLimit);
            const onlyMeasureId = 0 === (encoding.y || []).filter((v)=>v !== MeasureId).length;
            const bandAxis = {
                visible,
                type: 'band',
                orient: 'left',
                maxWidth: labelAutoLimitLength + 60,
                sampling,
                hover: true,
                label: {
                    visible: label?.visible,
                    flush: true,
                    containerAlign: 'right',
                    space: 8,
                    style: {
                        maxLineWidth: labelAutoLimitLength,
                        fill: label?.labelColor,
                        angle: label?.labelAngle,
                        fontSize: label?.labelFontSize,
                        fontWeight: label?.labelFontWeight
                    },
                    minGap: labelAutoHideGap,
                    autoHide: labelAutoHide,
                    autoHideMethod: 'greedy',
                    autoHideSeparation: labelAutoHideGap,
                    autoLimit: labelAutoLimit,
                    autoRotate: labelAutoRotate,
                    autoRotateAngle: labelAutoRotateAngleRange,
                    lastVisible: true
                },
                title: {
                    visible: title?.visible,
                    text: title?.titleText || defaultTitleText(measures, dimensions, encoding.y),
                    style: {
                        fill: title?.titleColor,
                        fontSize: title?.titleFontSize,
                        fontWeight: title?.titleFontWeight
                    }
                },
                tick: {
                    visible: tick?.visible,
                    tickSize: tick?.tickSize,
                    inside: tick?.tickInside,
                    style: {
                        stroke: tick?.tickColor
                    }
                },
                grid: {
                    visible: grid?.visible,
                    style: {
                        lineWidth: grid?.gridWidth,
                        stroke: grid?.gridColor,
                        lineDash: grid?.gridLineDash
                    }
                },
                domainLine: {
                    visible: line?.visible,
                    style: {
                        lineWidth: line?.lineWidth,
                        stroke: line?.lineColor
                    }
                },
                paddingInner: [
                    0.15,
                    0.1
                ],
                paddingOuter: [
                    0.075,
                    0.1
                ]
            };
            if (onlyMeasureId && bandAxis.label) {
                const allDatasetReshapeInfo = pivotAllDatasetReshapeInfo || datasetReshapeInfo;
                const colorIdMap = allDatasetReshapeInfo.reduce((prev, cur)=>({
                        ...prev,
                        ...cur.unfoldInfo.colorIdMap
                    }), {});
                bandAxis.label.formatMethod = (text)=>common_isArray(text) ? text : colorIdMap[String(text)]?.alias ?? text;
            }
            result.axes = [
                ...result.axes,
                bandAxis
            ];
            return result;
        };
        const horizontalCrosshairRect = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed, vseed } = context;
            const { chartType } = vseed;
            const config = advancedVSeed.config?.[chartType]?.crosshairRect;
            if (!config) return result;
            if (!result.crosshair) result.crosshair = {};
            const visible = config.visible || true;
            const rectColor = config.rectColor || void 0;
            const labelColor = config.labelColor || void 0;
            const labelVisible = config.labelVisible || false;
            const labelBackgroundColor = config.labelBackgroundColor || void 0;
            const crosshair = result.crosshair;
            crosshair.yField = {
                visible,
                line: {
                    type: 'rect',
                    style: {
                        lineWidth: 0,
                        opacity: 0.26,
                        fill: rectColor
                    }
                },
                label: {
                    visible: labelVisible,
                    labelBackground: {
                        visible: labelVisible,
                        style: {
                            fill: labelBackgroundColor
                        }
                    },
                    style: {
                        fill: labelColor
                    }
                }
            };
            const yAxisConfig = result.axes?.find((v)=>'left' === v.orient);
            const yAxisFormatter = yAxisConfig?.label?.formatMethod;
            if (yAxisFormatter) crosshair.yField.label.formatMethod = (text)=>yAxisFormatter(text);
            return result;
        };
        const bar = [
            initBar,
            stackCornerRadius_stackCornerRadius,
            barMaxWidth_barMaxWidth,
            colorAdapter(color_color, linearColor),
            background_backgroundColor,
            datasetYX,
            progressive,
            xLinear,
            yBand,
            label_label,
            tooltip_tooltip,
            colorAdapter(discreteLegend, colorLegend),
            horizontalCrosshairRect,
            colorBarStyleFill(barStyle_barStyle),
            annotationPoint_annotationPoint,
            annotationVerticalLine_annotationVerticalLine,
            annotationHorizontalLine_annotationHorizontalLine,
            annotationAreaBand
        ];
        const pivotBar = [
            initPivot,
            pivotGridStyle,
            pivotIndicatorsAsCol,
            datasetPivot,
            pivotIndicators_pivotIndicators([
                initBar,
                stackCornerRadius_stackCornerRadius,
                barMaxWidth_barMaxWidth,
                colorAdapter(color_color, linearColor),
                background_backgroundColor,
                datasetYX,
                progressive,
                xLinear,
                pivotAxisStyle(yBand),
                label_label,
                tooltip_tooltip,
                colorBarStyleFill(barStyle_barStyle),
                horizontalCrosshairRect,
                annotationPoint_annotationPoint,
                annotationVerticalLine_annotationVerticalLine,
                annotationHorizontalLine_annotationHorizontalLine,
                annotationAreaBand
            ]),
            pivotRowDimensions,
            pivotColumnDimensions,
            pivotTitle,
            colorAdapter(pivotDiscreteLegend, pivotColorLegend),
            dimensionLinkage
        ];
        const barSpecPipeline = [
            pivotAdapter_pivotAdapter(bar, pivotBar)
        ];
        const registerBar = ()=>{
            Builder._advancedPipelineMap.bar = barAdvancedPipeline;
            Builder._specPipelineMap.bar = barSpecPipeline;
        };
        const barParallelAdvancedPipeline = [
            initAdvancedVSeed_initAdvancedVSeed,
            default_defaultMeasures_defaultMeasures,
            defaultDimensions_defaultDimensions,
            defaultMeasureId_defaultMeasureId,
            encodingAdapter([
                defaultEncodingForBar,
                buildMeasures
            ], [
                encodingForBar,
                buildMeasures,
                pickMeasuresForReshape([
                    'tooltip',
                    'label',
                    'color'
                ]),
                pickDimensionsForReshape
            ]),
            pivotAdapter([
                reshapeWithEncoding
            ], [
                pivotReshapeWithEncoding
            ]),
            sortYBandAxis,
            sortLegend_sortLegend,
            barParallelConfig,
            theme_theme,
            markStyle_markStyle,
            annotation_annotation
        ];
        const initBarParallel = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed } = context;
            const { datasetReshapeInfo, encoding } = advancedVSeed;
            const { unfoldInfo, foldInfo } = datasetReshapeInfo[0];
            const sameDimensionsMode = chunk_HGKLN5KY_k(encoding.y, encoding.color);
            result.type = 'bar';
            result.direction = 'horizontal';
            result.yField = [
                unfoldInfo.encodingY
            ];
            if (!sameDimensionsMode) {
                result.yField.push(unfoldInfo.encodingDetail);
                if (encoding.detail?.[0] === MeasureId && encoding.x?.length === 1) result.yField.pop();
            }
            result.xField = foldInfo.measureValue;
            result.seriesField = unfoldInfo.encodingColorId;
            result.padding = 0;
            result.region = [
                {
                    clip: true
                }
            ];
            result.animation = true;
            return result;
        };
        const barParallel = [
            initBarParallel,
            stackCornerRadius_stackCornerRadius,
            barMaxWidth_barMaxWidth,
            barGapInGroup_barGapInGroup,
            colorAdapter(color_color, linearColor),
            background_backgroundColor,
            datasetYX,
            progressive,
            xLinear,
            yBand,
            label_label,
            tooltip_tooltip,
            colorAdapter(discreteLegend, colorLegend),
            horizontalCrosshairRect,
            colorBarStyleFill(barStyle_barStyle),
            annotationPoint_annotationPoint,
            annotationVerticalLine_annotationVerticalLine,
            annotationHorizontalLine_annotationHorizontalLine,
            annotationAreaBand
        ];
        const pivotBarParallel = [
            initPivot,
            pivotGridStyle,
            pivotIndicatorsAsCol,
            datasetPivot,
            pivotIndicators_pivotIndicators([
                initBarParallel,
                stackCornerRadius_stackCornerRadius,
                barMaxWidth_barMaxWidth,
                colorAdapter(color_color, linearColor),
                background_backgroundColor,
                datasetYX,
                xLinear,
                pivotAxisStyle(yBand),
                label_label,
                tooltip_tooltip,
                colorBarStyleFill(barStyle_barStyle),
                horizontalCrosshairRect,
                annotationPoint_annotationPoint,
                annotationVerticalLine_annotationVerticalLine,
                annotationHorizontalLine_annotationHorizontalLine,
                annotationAreaBand
            ]),
            pivotRowDimensions,
            pivotColumnDimensions,
            pivotTitle,
            colorAdapter(pivotDiscreteLegend, pivotColorLegend),
            dimensionLinkage
        ];
        const barParallelSpecPipeline = [
            pivotAdapter_pivotAdapter(barParallel, pivotBarParallel)
        ];
        const registerBarParallel = ()=>{
            Builder._advancedPipelineMap.barParallel = barParallelAdvancedPipeline;
            Builder._specPipelineMap.barParallel = barParallelSpecPipeline;
        };
        const barPercentAdvancedPipeline = [
            initAdvancedVSeed_initAdvancedVSeed,
            default_defaultMeasures_defaultMeasures,
            defaultDimensions_defaultDimensions,
            defaultMeasureId_defaultMeasureId,
            encodingAdapter([
                defaultEncodingForBar,
                buildMeasures
            ], [
                encodingForBar,
                buildMeasures,
                pickMeasuresForReshape([
                    'tooltip',
                    'label',
                    'color'
                ]),
                pickDimensionsForReshape
            ]),
            pivotAdapter([
                reshapeWithEncoding
            ], [
                pivotReshapeWithEncoding
            ]),
            sortYBandAxis,
            sortLegend_sortLegend,
            barPercentConfig,
            theme_theme,
            markStyle_markStyle,
            annotation_annotation
        ];
        const barPercent = [
            initBar,
            stackCornerRadius_stackCornerRadius,
            barMaxWidth_barMaxWidth,
            colorAdapter(color_color, linearColor),
            background_backgroundColor,
            percent_percent,
            datasetYX,
            progressive,
            xLinear,
            yBand,
            label_label,
            tooltip_tooltip,
            colorAdapter(discreteLegend, colorLegend),
            horizontalCrosshairRect,
            colorBarStyleFill(barStyle_barStyle),
            annotationPoint_annotationPoint,
            annotationVerticalLine_annotationVerticalLine,
            annotationHorizontalLine_annotationHorizontalLine,
            annotationAreaBand
        ];
        const pivotBarPercent = [
            initPivot,
            pivotGridStyle,
            pivotIndicatorsAsCol,
            datasetPivot,
            pivotIndicators_pivotIndicators([
                initBar,
                stackCornerRadius_stackCornerRadius,
                barMaxWidth_barMaxWidth,
                colorAdapter(color_color, linearColor),
                background_backgroundColor,
                percent_percent,
                datasetYX,
                xLinear,
                pivotAxisStyle(yBand),
                label_label,
                tooltip_tooltip,
                colorBarStyleFill(barStyle_barStyle),
                horizontalCrosshairRect,
                annotationPoint_annotationPoint,
                annotationVerticalLine_annotationVerticalLine,
                annotationHorizontalLine_annotationHorizontalLine,
                annotationAreaBand
            ]),
            pivotRowDimensions,
            pivotColumnDimensions,
            pivotTitle,
            colorAdapter(pivotDiscreteLegend, pivotColorLegend),
            dimensionLinkage
        ];
        const barPercentSpecPipeline = [
            pivotAdapter_pivotAdapter(barPercent, pivotBarPercent)
        ];
        const registerBarPercent = ()=>{
            Builder._advancedPipelineMap.barPercent = barPercentAdvancedPipeline;
            Builder._specPipelineMap.barPercent = barPercentSpecPipeline;
        };
        const areaAdvancedPipeline = [
            initAdvancedVSeed_initAdvancedVSeed,
            default_defaultMeasures_defaultMeasures,
            defaultDimensions_defaultDimensions,
            defaultMeasureId_defaultMeasureId,
            encodingAdapter([
                defaultEncodingForLine,
                buildMeasures
            ], [
                encodingForLine,
                buildMeasures,
                pickMeasuresForReshape([
                    'tooltip',
                    'label',
                    'color'
                ]),
                pickDimensionsForReshape
            ]),
            pivotAdapter([
                reshapeWithEncoding
            ], [
                pivotReshapeWithEncoding
            ]),
            sortXBandAxis,
            sortLegend_sortLegend,
            areaConfig,
            theme_theme,
            markStyle_markStyle,
            annotation_annotation
        ];
        const initArea = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed, vseed } = context;
            const { datasetReshapeInfo } = advancedVSeed;
            const { unfoldInfo, foldInfo } = datasetReshapeInfo[0];
            result.type = 'area';
            result.direction = 'vertical';
            result.yField = foldInfo.measureValue;
            result.xField = unfoldInfo.encodingX;
            result.seriesField = isLinearColor(advancedVSeed, vseed) ? unfoldInfo.encodingDetail : unfoldInfo.encodingColorId;
            result.padding = 0;
            result.region = [
                {
                    clip: true
                }
            ];
            result.animation = true;
            return result;
        };
        const colorAreaStyleFill = (stylePipe)=>(spec, context)=>{
                const result = stylePipe(spec, context);
                const { advancedVSeed, vseed } = context;
                const { datasetReshapeInfo } = advancedVSeed;
                const { unfoldInfo } = datasetReshapeInfo[0];
                if (isLinearColor(advancedVSeed, vseed)) {
                    if (result?.area?.style) result.area.style.fill = {
                        field: unfoldInfo.encodingColor,
                        scale: 'color'
                    };
                }
                return result;
            };
        function chunk_HVPVHFDT_i(...e) {
            return chunk_WIMGWYZL_u(chunk_HVPVHFDT_p, e);
        }
        var chunk_HVPVHFDT_p = (e, d)=>{
            let r = Object.create(null);
            for(let n = 0; n < e.length; n++){
                let t = e[n], y = d(t, n, e);
                if (void 0 !== y) {
                    let o = r[y];
                    void 0 === o ? r[y] = [
                        t
                    ] : o.push(t);
                }
            }
            return Object.setPrototypeOf(r, Object.prototype), r;
        };
        const areaStyle_areaStyle = (spec, context)=>{
            const { advancedVSeed } = context;
            const { markStyle, datasetReshapeInfo, dataset } = advancedVSeed;
            const { areaStyle, lineStyle } = markStyle;
            const { unfoldInfo } = datasetReshapeInfo[0];
            const result = {
                ...spec,
                area: {
                    visible: true,
                    style: {}
                }
            };
            if (chunk_JK3VNB42_n(areaStyle) || chunk_VCYTMP4D_n(areaStyle)) return result;
            const areaStyles = Array.isArray(areaStyle) ? areaStyle : [
                areaStyle
            ];
            const lineStyles = Array.isArray(lineStyle) ? lineStyle : [
                lineStyle
            ];
            const group = unfoldInfo.encodingColorId;
            const areaGroups = chunk_HVPVHFDT_i(dataset, (d)=>d[group ?? '']);
            const customMap = areaStyles.reduce((result, style, index)=>{
                const { areaColor, areaColorOpacity, areaVisible = true } = style;
                const curveType = getCurveType(context.vseed, lineStyles[index]?.lineSmooth);
                const curveTension = getCurveTension(context.vseed, lineStyles[index]?.lineSmooth);
                return {
                    ...result,
                    [`custom${index + 1}`]: {
                        level: index + 1,
                        filter: (datum)=>{
                            const lineData = areaGroups[datum[group ?? '']];
                            for (const d of lineData)if (selector_selector(d, style.selector)) return true;
                            return false;
                        },
                        style: {
                            curveType,
                            curveTension,
                            visible: areaVisible,
                            fill: areaColor,
                            fillOpacity: areaColorOpacity
                        }
                    }
                };
            }, {});
            return {
                ...result,
                area: {
                    ...result.area,
                    visible: true,
                    state: {
                        ...customMap
                    }
                }
            };
        };
        const area_area = [
            initArea,
            stackInverse,
            colorAdapter(color_color, linearColor),
            background_backgroundColor,
            datasetXY,
            progressive,
            xBand,
            yLinear,
            label_label,
            tooltip_tooltip,
            colorAdapter(discreteLegend, colorLegend),
            verticalCrosshairLine,
            colorPointStyleFill(pointStyle_pointStyle),
            pointStateDimensionHover,
            colorLineStyleFill(lineStyle_lineStyle),
            colorAreaStyleFill(areaStyle_areaStyle),
            annotationPoint_annotationPoint,
            annotationVerticalLine_annotationVerticalLine,
            annotationHorizontalLine_annotationHorizontalLine,
            annotationArea_annotationArea,
            splitLine
        ];
        const pivotArea = [
            initPivot,
            pivotGridStyle,
            pivotIndicatorsAsRow,
            datasetPivot,
            pivotIndicators_pivotIndicators([
                initArea,
                colorAdapter(color_color, linearColor),
                background_backgroundColor,
                stackInverse,
                datasetXY,
                progressive,
                xBand,
                pivotAxisStyle(yLinear),
                label_label,
                tooltip_tooltip,
                verticalCrosshairLine,
                colorPointStyleFill(pointStyle_pointStyle),
                pointStateDimensionHover,
                colorLineStyleFill(lineStyle_lineStyle),
                colorAreaStyleFill(areaStyle_areaStyle),
                annotationPoint_annotationPoint,
                annotationVerticalLine_annotationVerticalLine,
                annotationHorizontalLine_annotationHorizontalLine,
                annotationArea_annotationArea,
                splitLine
            ]),
            pivotRowDimensions,
            pivotColumnDimensions,
            pivotTitle,
            colorAdapter(pivotDiscreteLegend, pivotColorLegend),
            dimensionLinkage
        ];
        const areaSpecPipeline = [
            pivotAdapter_pivotAdapter(area_area, pivotArea)
        ];
        const registerArea = ()=>{
            Builder._advancedPipelineMap.area = areaAdvancedPipeline;
            Builder._specPipelineMap.area = areaSpecPipeline;
        };
        const areaPercentAdvancedPipeline = [
            initAdvancedVSeed_initAdvancedVSeed,
            default_defaultMeasures_defaultMeasures,
            defaultDimensions_defaultDimensions,
            defaultMeasureId_defaultMeasureId,
            encodingAdapter([
                defaultEncodingForLine,
                buildMeasures
            ], [
                encodingForLine,
                buildMeasures,
                pickMeasuresForReshape([
                    'tooltip',
                    'label',
                    'color'
                ]),
                pickDimensionsForReshape
            ]),
            pivotAdapter([
                reshapeWithEncoding
            ], [
                pivotReshapeWithEncoding
            ]),
            sortXBandAxis,
            sortLegend_sortLegend,
            areaPercentConfig,
            theme_theme,
            markStyle_markStyle,
            annotation_annotation
        ];
        const areaPercent = [
            initArea,
            stackInverse,
            colorAdapter(color_color, linearColor),
            background_backgroundColor,
            percent_percent,
            datasetXY,
            progressive,
            xBand,
            yLinear,
            label_label,
            tooltip_tooltip,
            colorAdapter(discreteLegend, colorLegend),
            verticalCrosshairLine,
            colorPointStyleFill(pointStyle_pointStyle),
            pointStateDimensionHover,
            colorLineStyleFill(lineStyle_lineStyle),
            colorAreaStyleFill(areaStyle_areaStyle),
            annotationPoint_annotationPoint,
            annotationVerticalLine_annotationVerticalLine,
            annotationHorizontalLine_annotationHorizontalLine,
            annotationArea_annotationArea
        ];
        const pivotAreaPercent = [
            initPivot,
            pivotGridStyle,
            pivotIndicatorsAsRow,
            datasetPivot,
            pivotIndicators_pivotIndicators([
                initArea,
                stackInverse,
                colorAdapter(color_color, linearColor),
                background_backgroundColor,
                percent_percent,
                datasetXY,
                progressive,
                xBand,
                pivotAxisStyle(yLinear),
                label_label,
                tooltip_tooltip,
                verticalCrosshairLine,
                colorPointStyleFill(pointStyle_pointStyle),
                pointStateDimensionHover,
                colorLineStyleFill(lineStyle_lineStyle),
                colorAreaStyleFill(areaStyle_areaStyle),
                annotationPoint_annotationPoint,
                annotationVerticalLine_annotationVerticalLine,
                annotationHorizontalLine_annotationHorizontalLine,
                annotationArea_annotationArea
            ]),
            pivotRowDimensions,
            pivotColumnDimensions,
            pivotTitle,
            colorAdapter(pivotDiscreteLegend, pivotColorLegend),
            dimensionLinkage
        ];
        const areaPercentSpecPipeline = [
            pivotAdapter_pivotAdapter(areaPercent, pivotAreaPercent)
        ];
        const registerAreaPercent = ()=>{
            Builder._advancedPipelineMap.areaPercent = areaPercentAdvancedPipeline;
            Builder._specPipelineMap.areaPercent = areaPercentSpecPipeline;
        };
        const defaultEncodingForScatter = (advancedVSeed)=>{
            const { measures: vseedMeasures = [], dimensions = [] } = advancedVSeed;
            const measures = findAllMeasures(vseedMeasures);
            const encoding = {};
            scatter_generateDefaultDimensionEncoding(dimensions, encoding);
            scatter_generateDefaultMeasureEncoding(measures, encoding);
            return {
                ...advancedVSeed,
                encoding
            };
        };
        const encodingForScatter = (advancedVSeed)=>{
            const { measures: vseedMeasures = [], dimensions = [] } = advancedVSeed;
            const measures = findAllMeasures(vseedMeasures);
            const hasDimensionEncoding = dimensions.some((item)=>item.encoding);
            const hasMeasureEncoding = measures.some((item)=>item.encoding);
            const encoding = {};
            if (hasDimensionEncoding) scatter_generateDimensionEncoding(dimensions, encoding);
            else scatter_generateDefaultDimensionEncoding(dimensions, encoding);
            if (hasMeasureEncoding) scatter_generateMeasureEncoding(measures, encoding);
            else scatter_generateDefaultMeasureEncoding(measures, encoding);
            return {
                ...advancedVSeed,
                encoding
            };
        };
        const scatter_generateDefaultDimensionEncoding = (dimensions, encoding)=>{
            const dimensionsWithoutMeasureId = dimensions.filter((item)=>item.id !== MeasureId);
            const uniqueDimIds = chunk_QJLMYOTX_i(dimensionsWithoutMeasureId.map((d)=>d.id));
            encoding.detail = encoding.color;
            encoding.tooltip = uniqueDimIds.filter((d)=>d !== MeasureId);
            encoding.label = [];
            encoding.row = [];
            encoding.column = [];
        };
        const scatter_generateDimensionEncoding = (dimensions, encoding)=>{
            encoding.color = chunk_QJLMYOTX_i(dimensions.filter((item)=>'color' === item.encoding).map((item)=>item.id));
            encoding.detail = chunk_QJLMYOTX_i(dimensions.filter((item)=>'detail' === item.encoding).map((item)=>item.id));
            if (0 === encoding.detail.length) encoding.detail = [
                MeasureId
            ];
            encoding.tooltip = chunk_QJLMYOTX_i(dimensions.map((item)=>item.id));
            encoding.tooltip = encoding.tooltip.filter((d)=>d !== MeasureId);
            encoding.label = chunk_QJLMYOTX_i(dimensions.filter((item)=>'label' === item.encoding).map((item)=>item.id));
            encoding.label = encoding.label.filter((d)=>d !== MeasureId);
        };
        const scatter_generateDefaultMeasureEncoding = (measures, encoding)=>{
            encoding.y = chunk_QJLMYOTX_i(measures.filter((item)=>'xAxis' === item.encoding || 'yAxis' === item.encoding || !item.encoding).map((item)=>item.id));
        };
        const scatter_generateMeasureEncoding = (measures, encoding)=>{
            encoding.y = chunk_QJLMYOTX_i(measures.filter((item)=>'xAxis' === item.encoding || 'yAxis' === item.encoding || !item.encoding).map((item)=>item.id));
            const color = chunk_QJLMYOTX_i(measures.filter((item)=>'color' === item.encoding).map((item)=>item.id));
            if (color.length > 0) encoding.color = [
                color[0]
            ];
            encoding.size = chunk_QJLMYOTX_i(measures.filter((item)=>'size' === item.encoding).map((item)=>item.id));
            const label = chunk_QJLMYOTX_i(measures.filter((item)=>'label' === item.encoding).map((item)=>item.id));
            encoding.label = chunk_QJLMYOTX_i([
                ...encoding.label || [],
                ...label
            ]);
            const tooltip = chunk_QJLMYOTX_i(measures.filter((item)=>'tooltip' === item.encoding).map((item)=>item.id));
            encoding.tooltip = chunk_QJLMYOTX_i([
                ...encoding.tooltip || [],
                ...label,
                ...tooltip
            ]);
        };
        const buildMeasuresForScatter = (advancedVSeed, context)=>{
            const { vseed } = context;
            if (isMeasureTreeWithChildren(advancedVSeed.measures)) return advancedVSeed;
            if (isMeasureTreeWithParentId(advancedVSeed.measures)) {
                advancedVSeed.measures = buildMeasuresForScatter_generateMeasuresByParentId(advancedVSeed.measures);
                return advancedVSeed;
            }
            const scatterMeasures = vseed.scatterMeasures ? chunk_BCBB46UE_d(vseed.scatterMeasures) : basicMeasuresToScatterMeasures(advancedVSeed.measures || []);
            advancedVSeed.measures = scatterMeasuresToMeasureTree(scatterMeasures);
            return advancedVSeed;
        };
        const basicMeasuresToScatterMeasures = (basicMeasures)=>{
            const yMeasures = [];
            const xMeasures = [];
            for(let index = 0; index < basicMeasures.length; index++){
                const item = basicMeasures[index];
                const encoding = Array.isArray(item.encoding) ? item.encoding : [
                    item.encoding
                ];
                const isYAxis = encoding.includes('yAxis');
                const isXAxis = encoding.includes('xAxis');
                if (isYAxis) yMeasures.push(item);
                else if (isXAxis) xMeasures.push(item);
                else if (0 !== index) yMeasures.push(item);
                else xMeasures.push(item);
            }
            if (0 === yMeasures.length && xMeasures.length > 0) yMeasures.push(xMeasures[0]);
            return [
                {
                    id: 'scatterMeasures',
                    xMeasures,
                    yMeasures
                }
            ];
        };
        const scatterMeasuresToMeasureTree = (scatterMeasures)=>{
            const measureTree = scatterMeasures.map((item, index)=>{
                const { id, xMeasures, yMeasures } = item;
                const groupChildren = [];
                let groupId = `${id}-`;
                if (xMeasures) {
                    const arrPrimaryMeasures = Array.isArray(xMeasures) ? xMeasures : [
                        xMeasures
                    ];
                    const alias = arrPrimaryMeasures.map((item)=>item.alias || item.id).toString();
                    groupId += alias;
                    groupChildren.push({
                        id: `${index}-x`,
                        alias: arrPrimaryMeasures.map((item)=>item.alias || item.id).toString(),
                        children: arrPrimaryMeasures
                    });
                }
                if (yMeasures) {
                    const arrSecondaryMeasures = Array.isArray(yMeasures) ? yMeasures : [
                        yMeasures
                    ];
                    const alias = arrSecondaryMeasures.map((item)=>item.alias || item.id).toString();
                    groupId += alias;
                    groupChildren.push({
                        id: `${index}-y`,
                        alias: arrSecondaryMeasures.map((item)=>item.alias || item.id).toString(),
                        children: arrSecondaryMeasures
                    });
                }
                return {
                    id: groupId,
                    alias: groupId,
                    children: groupChildren
                };
            });
            if (1 === scatterMeasures.length) return measureTree[0].children || [];
            return measureTree;
        };
        const buildMeasuresForScatter_generateMeasuresByParentId = (measures)=>{
            const scatterMeasures = [];
            measures.forEach((item)=>{
                const id = item.parentId || DEFAULT_PARENT_ID;
                if (!scatterMeasures.find((d)=>d.id === id)) scatterMeasures.push({
                    id,
                    yMeasures: [],
                    xMeasures: []
                });
                const scatterChart = scatterMeasures.find((d)=>d.id === id);
                if (!scatterChart || !Array.isArray(scatterChart.yMeasures) || !Array.isArray(scatterChart.xMeasures)) return;
                const encoding = Array.isArray(item.encoding) ? item.encoding : [
                    item.encoding
                ].filter(Boolean);
                const isX = encoding.includes('xAxis');
                const isY = encoding.includes('yAxis');
                const isEmpty = !encoding.length;
                if (isY) scatterChart.yMeasures.push(item);
                else if (isX) scatterChart.xMeasures.push(item);
                else if (isEmpty) if (0 !== scatterChart.yMeasures.length) scatterChart.yMeasures.push(item);
                else scatterChart.xMeasures.push(item);
            });
            return scatterMeasuresToMeasureTree(scatterMeasures);
        };
        const scatterConfig = (advancedVSeed, context)=>{
            const { vseed } = context;
            const { chartType } = vseed;
            const result = {
                ...advancedVSeed
            };
            const pickedConfig = chunk_2T7K3PFL_i(vseed, [
                'backgroundColor',
                'color',
                'label',
                'legend',
                'tooltip',
                'xAxis',
                'yAxis',
                'sizeRange',
                'size',
                'crosshairLine',
                'dimensionLinkage'
            ]);
            const config = replaceNullToUndefined(pickedConfig);
            result.config = {
                ...result.config || {},
                [chartType]: {
                    ...config
                }
            };
            return result;
        };
        const reshapeWithScatterEncoding = (advancedVSeed, context)=>{
            const result = {
                ...advancedVSeed
            };
            const { vseed } = context;
            const { dataset } = vseed;
            const { encoding, chartType } = advancedVSeed;
            const measures = advancedVSeed.reshapeMeasures ?? advancedVSeed.measures ?? [];
            const dimensions = advancedVSeed.reshapeDimensions ?? advancedVSeed.dimensions ?? [];
            if (measures.length > 2) throw new Error('measures can not be more than 2 groups in scatter');
            const foldInfoList = [];
            const unfoldInfoList = [];
            const datasets = [];
            const xMeasures = measures[0];
            const yMeasures = measures[1] || xMeasures;
            if (xMeasures && xMeasures.children) {
                const { dataset: newDataset, foldInfo, unfoldInfo } = dataReshapeByEncoding(dataset, T(dimensions, (d)=>d.id), T(xMeasures.children, (d)=>d.id), encoding, {
                    foldMeasureValue: FoldXMeasureValue,
                    foldMeasureId: FoldXMeasureId,
                    colorItemAsId: true,
                    colorMeasureId: getColorMeasureId(advancedVSeed, vseed)
                });
                datasets.push(newDataset);
                foldInfoList.push(foldInfo);
                unfoldInfoList.push(unfoldInfo);
            }
            if (yMeasures && yMeasures.children) {
                const { dataset: newDataset, foldInfo, unfoldInfo } = dataReshapeByEncoding(datasets[0], T(dimensions, (d)=>d.id), T(yMeasures.children, (d)=>d.id), encoding, {
                    foldMeasureValue: FoldYMeasureValue,
                    foldMeasureId: FoldYMeasureId,
                    colorItemAsId: true,
                    colorMeasureId: getColorMeasureId(advancedVSeed, vseed)
                });
                datasets[0] = newDataset;
                foldInfoList.push(foldInfo);
                unfoldInfoList.push(unfoldInfo);
            }
            const unfoldInfo = {
                ...unfoldInfoList[0],
                colorItems: unfoldInfoList.flatMap((d)=>d.colorItems),
                colorIdMap: unfoldInfoList.reduce((prev, cur)=>({
                        ...prev,
                        ...cur.colorIdMap
                    }), {})
            };
            return {
                ...result,
                dataset: datasets[0],
                datasetReshapeInfo: [
                    {
                        id: String(chartType),
                        index: 0,
                        foldInfo: foldInfoList[0],
                        foldInfoList: foldInfoList,
                        unfoldInfo: unfoldInfo
                    }
                ]
            };
        };
        const pivotReshapeWithScatterEncoding = (advancedVSeed, context)=>{
            const result = {
                ...advancedVSeed
            };
            const { vseed } = context;
            const { dataset } = vseed;
            const { encoding, chartType } = advancedVSeed;
            const measures = advancedVSeed.reshapeMeasures ?? advancedVSeed.measures ?? [];
            const dimensions = advancedVSeed.reshapeDimensions ?? advancedVSeed.dimensions ?? [];
            const allMeasures = findAllMeasures(measures);
            const measureGroups = [];
            const depth = measureDepth(measures);
            if (3 === depth) measures.forEach((measure)=>{
                measureGroups.push(measure.children);
            });
            else if (2 === depth) measureGroups.push(measures);
            const datasetList = [];
            const datasetReshapeInfo = [];
            measureGroups.forEach((measures, index)=>{
                if (measures.length > 2) throw new Error('measures can not be more than 2 groups in scatter');
                const foldInfoList = [];
                const unfoldInfoList = [];
                const datasets = [];
                const xMeasures = measures[0];
                const yMeasures = measures[1] || xMeasures;
                if (xMeasures && xMeasures.children) {
                    const { dataset: newDataset, foldInfo, unfoldInfo } = dataReshapeByEncoding(dataset, dimensions, xMeasures.children, encoding, {
                        foldMeasureValue: `${FoldXMeasureValue}${index}`,
                        colorItemAsId: true,
                        colorMeasureId: getColorMeasureId(advancedVSeed, vseed),
                        omitIds: allMeasures.map((item)=>item.id)
                    });
                    datasets.push(newDataset);
                    foldInfoList.push(foldInfo);
                    unfoldInfoList.push(unfoldInfo);
                }
                if (yMeasures && yMeasures.children) {
                    const { dataset: newDataset, foldInfo, unfoldInfo } = dataReshapeByEncoding(dataset, dimensions, yMeasures.children, encoding, {
                        foldMeasureValue: `${FoldYMeasureValue}${index}`,
                        colorItemAsId: true,
                        colorMeasureId: getColorMeasureId(advancedVSeed, vseed),
                        omitIds: allMeasures.map((item)=>item.id)
                    });
                    datasets.push(newDataset);
                    foldInfoList.push(foldInfo);
                    unfoldInfoList.push(unfoldInfo);
                }
                const unfoldInfo = {
                    ...unfoldInfoList[0],
                    colorItems: unfoldInfoList.flatMap((d)=>d.colorItems),
                    colorIdMap: unfoldInfoList.reduce((prev, cur)=>({
                            ...prev,
                            ...cur.colorIdMap
                        }), {})
                };
                const reshapeInfo = {
                    id: `${chartType}-${index}`,
                    index,
                    foldInfo: foldInfoList[0],
                    foldInfoList: foldInfoList,
                    unfoldInfo: unfoldInfo
                };
                datasetReshapeInfo.push(reshapeInfo);
                datasetList.push(datasets[0].map((d, index)=>({
                        ...d,
                        ...datasets[1]?.[index] || {}
                    })));
            });
            return {
                ...result,
                dataset: datasetList,
                datasetReshapeInfo: datasetReshapeInfo
            };
        };
        const scatterAdvancedPipeline = [
            initAdvancedVSeed_initAdvancedVSeed,
            default_defaultMeasures_defaultMeasures,
            defaultDimensions_defaultDimensions,
            defaultMeasureId_defaultMeasureId,
            encodingAdapter([
                defaultEncodingForScatter,
                buildMeasuresForScatter
            ], [
                encodingForScatter,
                buildMeasuresForScatter,
                pickMeasuresForReshape([
                    'tooltip',
                    'label',
                    'size'
                ]),
                pickDimensionsForReshape
            ]),
            pivotAdapter([
                reshapeWithScatterEncoding
            ], [
                pivotReshapeWithScatterEncoding
            ]),
            scatterConfig,
            theme_theme,
            markStyle_markStyle,
            annotation_annotation,
            regressionLine_regressionLine
        ];
        const initScatter = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed } = context;
            const { datasetReshapeInfo } = advancedVSeed;
            const { unfoldInfo, foldInfoList } = datasetReshapeInfo[0];
            result.type = 'scatter';
            result.direction = 'vertical';
            result.xField = foldInfoList?.[0].measureValue;
            if (foldInfoList?.[1]) result.yField = foldInfoList[1].measureValue;
            result.seriesField = unfoldInfo.encodingColorId;
            result.padding = 0;
            result.region = [
                {
                    clip: true
                }
            ];
            result.animation = true;
            return result;
        };
        const datasetScatter = (spec, context)=>{
            const { advancedVSeed, vseed } = context;
            const { datasetReshapeInfo } = advancedVSeed;
            const id = datasetReshapeInfo[0].id;
            const fields = {};
            return {
                ...spec,
                data: {
                    id,
                    values: isPivotChart(vseed) ? void 0 : advancedVSeed.dataset.flat(),
                    fields: fields
                }
            };
        };
        const scatterSize = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed } = context;
            const { chartType, encoding } = advancedVSeed;
            const baseConfig = advancedVSeed.config[chartType];
            const hasSizeEncoding = encoding?.size?.[0];
            if (!hasSizeEncoding) return result;
            const size = baseConfig.size ?? baseConfig.sizeRange;
            result.size = {
                type: 'linear',
                range: Array.isArray(size) ? size : [
                    size,
                    size
                ]
            };
            result.sizeField = encoding?.size?.[0] || void 0;
            return result;
        };
        const labelScatter = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed, vseed } = context;
            const { datasetReshapeInfo } = advancedVSeed;
            const { chartType, encoding } = advancedVSeed;
            const baseConfig = advancedVSeed.config[chartType];
            const foldInfoList = datasetReshapeInfo[0].foldInfoList;
            const { label } = baseConfig;
            result.label = buildLabel(label, vseed.measures, vseed.dimensions, advancedVSeed.dimensions, advancedVSeed.measures, encoding, foldInfoList);
            return result;
        };
        const tooltipScatter = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed, vseed } = context;
            const { datasetReshapeInfo, chartType, locale, dimensions, encoding } = advancedVSeed;
            const baseConfig = advancedVSeed.config[chartType];
            const { tooltip = {
                enable: true
            } } = baseConfig;
            const { enable } = tooltip;
            const { foldInfoList } = datasetReshapeInfo[0];
            result.tooltip = {
                style: getTooltipStyle(tooltip),
                visible: enable,
                mark: {
                    title: {
                        visible: false
                    },
                    content: tooltipScatter_createMarkContent(encoding.tooltip || [], dimensions, findAllMeasures(vseed.measures), locale, foldInfoList)
                },
                dimension: {
                    visible: false
                }
            };
            return result;
        };
        const tooltipScatter_createMarkContent = (tooltip, dimensions, measures, locale, foldInfoList)=>{
            const dims = T(dimensions.filter((item)=>tooltip.includes(item.id)), (item)=>item.id);
            const meas = T(measures.filter((item)=>tooltip.includes(item.id)), (item)=>item.id);
            const dimContent = dims.map((item)=>({
                    visible: true,
                    hasShape: true,
                    shapeType: 'rectRound',
                    key: (v)=>{
                        const datum = v;
                        if (item.alias || item.id) return item.alias || item.id;
                        return datum && datum[item.id];
                    },
                    value: (v)=>{
                        const datum = v;
                        return datum && datum[item.id];
                    }
                }));
            const meaContent = meas.map((item)=>({
                    visible: true,
                    hasShape: true,
                    shapeType: 'rectRound',
                    key: item.alias || item.id,
                    value: (v)=>{
                        const datum = v;
                        if (!datum) return '';
                        const id = item.id;
                        if (!datum || !datum[ORIGINAL_DATA] || !datum[ORIGINAL_DATA]) return '';
                        const originalData = datum[ORIGINAL_DATA];
                        const value = originalData[id];
                        const measure = findMeasureById(measures, id);
                        const formatter = createFormatterByMeasure(measure);
                        return formatter(value);
                    }
                }));
            const foldMeaContent = foldInfoList.map((foldInfo)=>({
                    visible: true,
                    hasShape: true,
                    shapeType: 'rectRound',
                    key: Object.values(foldInfo.foldMap)[0],
                    value: (v)=>{
                        const { measureId, measureValue } = foldInfo;
                        const datum = v;
                        if (!datum) return '';
                        const value = datum[measureValue];
                        const id = datum[measureId];
                        const measure = findMeasureById(measures, id);
                        const formatter = createFormatterByMeasure(measure);
                        return formatter(value);
                    }
                }));
            return [
                ...dimContent,
                ...foldMeaContent,
                ...meaContent
            ];
        };
        const horizontalCrosshairLine = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed, vseed } = context;
            const { chartType } = vseed;
            const config = advancedVSeed.config?.[chartType]?.crosshairLine;
            if (!config) return result;
            if (!result.crosshair) result.crosshair = {};
            const visible = config.visible || true;
            const lineColor = config.lineColor || void 0;
            const labelColor = config.labelColor || void 0;
            const labelVisible = config.labelVisible || void 0;
            const labelBackgroundColor = config.labelBackgroundColor || void 0;
            const crosshair = result.crosshair;
            crosshair.yField = {
                visible,
                line: {
                    type: 'line',
                    style: {
                        lineWidth: 1,
                        opacity: 1,
                        stroke: lineColor,
                        lineDash: config.lineDash ?? [
                            4,
                            2
                        ]
                    }
                },
                label: {
                    visible: labelVisible,
                    labelBackground: {
                        visible: labelVisible,
                        style: {
                            fill: labelBackgroundColor
                        }
                    },
                    style: {
                        fill: labelColor
                    }
                }
            };
            const yAxisConfig = result.axes?.find((v)=>'left' === v.orient);
            const yAxisFormatter = yAxisConfig?.label?.formatMethod;
            if (yAxisFormatter) crosshair.yField.label.formatMethod = (text)=>yAxisFormatter(text);
            return result;
        };
        function tricube(u) {
            const uu = Math.abs(u);
            if (uu >= 1) return 0;
            const t = 1 - uu * uu * uu;
            return t * t * t;
        }
        function regressionLowess(data, x = (d)=>d.x, y = (d)=>d.y, options = {}) {
            var _a;
            const span = options.span || .3, degree = 0 === options.degree ? 0 : 1, alpha = null != (_a = null == options ? void 0 : options.alpha) ? _a : .05, iterations = null == options.iterations ? 2 : options.iterations, ptsX = [], ptsY = [];
            visitPoints(data, x, y, (dx, dy)=>{
                ptsX.push(dx), ptsY.push(dy);
            });
            const n = ptsX.length;
            function predictSingle(x0, robustWeights) {
                if (0 === n) return 0;
                const dists = [];
                for(let i = 0; i < n; i++)dists.push({
                    idx: i,
                    dist: Math.abs(ptsX[i] - x0)
                });
                dists.sort((a, b)=>a.dist - b.dist);
                const m = Math.max(2, Math.min(n, Math.floor(span * n))), maxDist = dists[m - 1].dist || 0, w = new Array(m);
                let sumw = 0;
                for(let i = 0; i < m; i++){
                    const idx = dists[i].idx;
                    let wi = tricube(0 === maxDist ? 0 : dists[i].dist / maxDist);
                    robustWeights && null != robustWeights[idx] && (wi *= robustWeights[idx]), w[i] = wi, sumw += wi;
                }
                if (0 === sumw) return ptsY[dists[0].idx];
                if (0 === degree) {
                    let s = 0;
                    for(let i = 0; i < m; i++)s += w[i] * ptsY[dists[i].idx];
                    return s / sumw;
                }
                let sw = 0, sx = 0, sy = 0, sxx = 0, sxy = 0;
                for(let i = 0; i < m; i++){
                    const idx = dists[i].idx, xi = ptsX[idx], yi = ptsY[idx], wi = w[i];
                    sw += wi, sx += wi * xi, sy += wi * yi, sxx += wi * xi * xi, sxy += wi * xi * yi;
                }
                const meanX = sx / sw, meanY = sy / sw, denom = sxx - sx * meanX, slope = Math.abs(denom) < 1e-12 ? 0 : (sxy - sx * meanY) / denom;
                return meanY - slope * meanX + slope * x0;
            }
            function predict(x0) {
                if (Array.isArray(x0)) {
                    const out = [];
                    for(let i = 0; i < x0.length; i++)out.push(predictSingle(x0[i]));
                    return out;
                }
                return predictSingle(x0);
            }
            return {
                predict: predict,
                evaluate: predict,
                evaluateGrid: function(N) {
                    const out = [];
                    if (N <= 0) return out;
                    if (0 === n) return out;
                    let min = 1 / 0, max = -1 / 0;
                    for(let i = 0; i < n; i++)ptsX[i] < min && (min = ptsX[i]), ptsX[i] > max && (max = ptsX[i]);
                    if (min === max) {
                        const v = predictSingle(min);
                        for(let i = 0; i < N; i++)out.push({
                            x: min,
                            y: v
                        });
                        return out;
                    }
                    const step = (max - min) / (N - 1);
                    let robustWeights;
                    for(let iter = 0; iter < iterations; iter++){
                        const fits = [];
                        for(let i = 0; i < n; i++)fits.push(predictSingle(ptsX[i], robustWeights));
                        const res = [];
                        for(let i = 0; i < n; i++)res.push(Math.abs(ptsY[i] - fits[i]));
                        const med = res.slice().sort((a, b)=>a - b)[Math.floor(n / 2)] || 0;
                        robustWeights = new Array(n);
                        for(let i = 0; i < n; i++){
                            const u = 0 === med ? 0 : res[i] / (6 * med), w = Math.abs(u) >= 1 ? 0 : (1 - u * u) * (1 - u * u);
                            robustWeights[i] = w;
                        }
                    }
                    for(let i = 0; i < N; i++){
                        const px = i === N - 1 ? max : min + step * i;
                        out.push({
                            x: px,
                            y: predictSingle(px, robustWeights)
                        });
                    }
                    return out;
                },
                confidenceInterval: function(N = 50) {
                    const out = [];
                    if (N <= 0) return out;
                    if (0 === n) return out;
                    let min = 1 / 0, max = -1 / 0;
                    for(let i = 0; i < n; i++)ptsX[i] < min && (min = ptsX[i]), ptsX[i] > max && (max = ptsX[i]);
                    if (min === 1 / 0 || max === -1 / 0) return out;
                    const comps = computeLinearCIComponents(data, x, y, (xx)=>predictSingle(xx));
                    if (0 === comps.n) return out;
                    const z = Math.abs(invNorm(1 - alpha / 2));
                    if (comps.min === comps.max) {
                        const v = predictSingle(comps.min), errs = stdErrorsAt(comps.min, comps);
                        for(let i = 0; i < N; i++)out.push({
                            x: comps.min,
                            mean: v,
                            lower: v - z * errs.seMean,
                            upper: v + z * errs.seMean,
                            predLower: v - z * errs.sePred,
                            predUpper: v + z * errs.sePred
                        });
                        return out;
                    }
                    const step = (max - min) / (N - 1);
                    for(let i = 0; i < N; i++){
                        const px = i === N - 1 ? max : min + step * i, yh = predictSingle(px), errs = stdErrorsAt(px, comps);
                        out.push({
                            x: px,
                            mean: yh,
                            lower: yh - z * errs.seMean,
                            upper: yh + z * errs.seMean,
                            predLower: yh - z * errs.sePred,
                            predUpper: yh + z * errs.sePred
                        });
                    }
                    return out;
                }
            };
        }
        function regressionLogistic(data, x = (d)=>d.x, y = (d)=>d.y, options) {
            var _a, _b, _c;
            const maxIter = null != (_a = null == options ? void 0 : options.maxIteration) ? _a : 25, tol = null != (_b = null == options ? void 0 : options.tol) ? _b : 1e-6, alpha = null != (_c = null == options ? void 0 : options.alpha) ? _c : .05, xs = [], ys = [];
            visitPoints(data, x, y, (dx, dy)=>{
                xs.push(dx), ys.push(dy ? 1 : 0);
            });
            const n = xs.length;
            if (0 === n) return {
                coef: [
                    0,
                    0
                ],
                predict: (_x)=>0,
                evaluateGrid: (N)=>[],
                confidenceInterval: (N = 50)=>[]
            };
            let intercept = 0, beta = 0;
            for(let iter = 0; iter < maxIter; iter++){
                const p = new Array(n);
                let converged = !0;
                for(let i = 0; i < n; i++){
                    const z = intercept + beta * xs[i], pi = 1 / (1 + Math.exp(-z));
                    p[i] = pi;
                }
                let g0 = 0, g1 = 0, h00 = 0, h01 = 0, h11 = 0;
                for(let i = 0; i < n; i++){
                    const wi = p[i] * (1 - p[i]), diff = ys[i] - p[i];
                    g0 += diff, g1 += diff * xs[i], h00 += wi, h01 += wi * xs[i], h11 += wi * xs[i] * xs[i];
                }
                const det = h00 * h11 - h01 * h01;
                if (Math.abs(det) < 1e-12) break;
                const delta0 = (h11 * g0 - h01 * g1) / det, delta1 = (-h01 * g0 + h00 * g1) / det;
                if (intercept += delta0, beta += delta1, (Math.abs(delta0) > tol || Math.abs(delta1) > tol) && (converged = !1), converged) break;
            }
            const predict = (xx)=>{
                const z = intercept + beta * xx;
                return 1 / (1 + Math.exp(-z));
            };
            return {
                coef: [
                    intercept,
                    beta
                ],
                predict: predict,
                evaluateGrid: function(N) {
                    const out = [];
                    if (N <= 0) return out;
                    let min = 1 / 0, max = -1 / 0;
                    if (visitPoints(data, x, y, (dx)=>{
                        dx < min && (min = dx), dx > max && (max = dx);
                    }), min === 1 / 0 || max === -1 / 0) return out;
                    if (min === max) {
                        const v = predict(min);
                        for(let i = 0; i < N; i++)out.push({
                            x: min,
                            y: v
                        });
                        return out;
                    }
                    const step = (max - min) / (N - 1);
                    for(let i = 0; i < N; i++){
                        const px = i === N - 1 ? max : min + step * i;
                        out.push({
                            x: px,
                            y: predict(px)
                        });
                    }
                    return out;
                },
                confidenceInterval: function(N = 50) {
                    const out = [];
                    if (N <= 0) return out;
                    const comps = computeLinearCIComponents(data, x, y, predict);
                    if (0 === comps.n) return out;
                    const z = Math.abs(invNorm(1 - alpha / 2));
                    if (comps.min === comps.max) {
                        const v = predict(comps.min), errs = stdErrorsAt(comps.min, comps);
                        for(let i = 0; i < N; i++)out.push({
                            x: comps.min,
                            mean: v,
                            lower: v - z * errs.seMean,
                            upper: v + z * errs.seMean,
                            predLower: v - z * errs.sePred,
                            predUpper: v + z * errs.sePred
                        });
                        return out;
                    }
                    const step = (comps.max - comps.min) / (N - 1);
                    for(let i = 0; i < N; i++){
                        const px = i === N - 1 ? comps.max : comps.min + step * i, yh = predict(px), errs = stdErrorsAt(px, comps);
                        out.push({
                            x: px,
                            mean: yh,
                            lower: yh - z * errs.seMean,
                            upper: yh + z * errs.seMean,
                            predLower: yh - z * errs.sePred,
                            predUpper: yh + z * errs.sePred
                        });
                    }
                    return out;
                }
            };
        }
        const generateRegressionLinePipe = (type, regressionFunction, getOptions = getDefaultRegressionOptions, getMinPoints = ()=>2)=>(spec, context)=>{
                const result = {
                    ...spec
                };
                const { advancedVSeed } = context;
                const { chartType, regressionLine } = advancedVSeed;
                const lineTheme = advancedVSeed.config[chartType]?.regressionLine;
                if (!regressionLine || !regressionLine[type]) return result;
                const lineList = array_array(regressionLine[type]);
                if (!result.extensionMark) result.extensionMark = [];
                lineList.forEach((line, lineIndex)=>{
                    if (false === line.enable) return;
                    const theme = lineTheme.linearRegressionLine ?? {};
                    const { color, lineWidth, lineDash, text, textColor, textFontSize, textFontWeight, confidenceIntervalOpacity, confidenceIntervalVisible = theme.confidenceIntervalVisible } = line;
                    const childrenMarks = [];
                    result.extensionMark.push({
                        type: 'group',
                        interactive: false,
                        zIndex: 500,
                        name: `${type}-${lineIndex}`,
                        layoutType: 'region-relative',
                        dataId: spec.data?.id,
                        animation: false,
                        style: {
                            data: (datum, ctx)=>{
                                const vchart = ctx.vchart;
                                const chart = vchart.getChart();
                                const s = chart.getAllSeries()[0];
                                if (s) {
                                    const rect = s.getRegion().getLayoutRect();
                                    const segments = [];
                                    if (0 === rect.width || 0 === rect.height) return segments;
                                    const yClamper = clamper(0, rect.height);
                                    const colorAttrOptions = s.getColorAttribute();
                                    const groups = s.getSeriesKeys();
                                    const data = s.getViewData()?.latestData;
                                    const fieldX = s.fieldX?.[0];
                                    const fieldY = s.fieldY?.[0];
                                    if (!groups.length) groups.push(void 0);
                                    groups.forEach((group)=>{
                                        const groupData = data.filter((d)=>d[colorAttrOptions?.field] === group);
                                        const minPoints = getMinPoints(line);
                                        if (groupData.length < minPoints) return;
                                        const { confidenceInterval, evaluateGrid } = regressionFunction(groupData, (datum)=>datum?.[fieldX], (datum)=>datum?.[fieldY], getOptions?.(line));
                                        const N = Math.max(3, Math.floor(groupData.length / 4));
                                        const mainColor = color ?? colorAttrOptions?.scale?.scale(group);
                                        const lineData = evaluateGrid(N);
                                        const linePoints = [];
                                        lineData.forEach((ld, index)=>{
                                            const d = {
                                                [fieldX]: ld.x,
                                                [fieldY]: ld.y
                                            };
                                            const x = s.dataToPositionX(d);
                                            const y = yClamper(s.dataToPositionY(d));
                                            if (segments.length && 0 === index) segments[segments.length - 1].linePoints.push({
                                                x,
                                                y: NaN
                                            });
                                            linePoints.push({
                                                x,
                                                y
                                            });
                                        });
                                        const segment = {
                                            color: mainColor,
                                            linePoints
                                        };
                                        if (confidenceIntervalVisible) {
                                            const intervalData = confidenceInterval(N);
                                            const areaPoints = [];
                                            intervalData.map((datum, index)=>{
                                                const d = {
                                                    [fieldX]: datum.x,
                                                    [fieldY]: datum.lower
                                                };
                                                const x = s.dataToPositionX(d);
                                                const y = yClamper(s.dataToPositionY(d));
                                                const y1 = yClamper(s.dataToPositionY({
                                                    [fieldY]: datum.upper
                                                }));
                                                if (segments.length && 0 === index) segments[segments.length - 1].areaPoints.push({
                                                    x,
                                                    y: NaN,
                                                    y1: NaN
                                                });
                                                areaPoints.push({
                                                    x,
                                                    y,
                                                    y1
                                                });
                                            });
                                            segment.areaPoints = areaPoints;
                                        }
                                        segments.push(segment);
                                    });
                                    return segments;
                                }
                                return [];
                            }
                        },
                        children: childrenMarks
                    });
                    if (confidenceIntervalVisible) childrenMarks.push({
                        type: 'area',
                        interactive: false,
                        zIndex: 500,
                        dataId: spec.data?.id,
                        style: {
                            stroke: false,
                            lineWidth: lineWidth ?? theme.lineWidth,
                            lineDash: lineDash ?? theme.lineDash,
                            fillOpacity: confidenceIntervalOpacity ?? theme.confidenceIntervalOpacity,
                            fill: 'red',
                            segments: (datum, ctx, opt)=>{
                                const parentNode = opt.mark?._product?.parent;
                                if (parentNode) {
                                    const data = parentNode.finalAttribute?.data ?? parentNode.attribute?.data;
                                    if (data?.length) return data.map((d)=>({
                                            points: d.areaPoints ?? [],
                                            fill: d.color
                                        }));
                                }
                                return [];
                            }
                        }
                    });
                    childrenMarks.push({
                        type: 'line',
                        interactive: false,
                        zIndex: 500,
                        animation: false,
                        dataId: spec.data?.id,
                        style: {
                            lineWidth: lineWidth ?? theme.lineWidth,
                            lineDash: lineDash ?? theme.lineDash,
                            stroke: 'red',
                            segments: (datum, ctx, opt)=>{
                                const parentNode = opt.mark?._product?.parent;
                                if (parentNode) {
                                    const data = parentNode.finalAttribute?.data ?? parentNode.attribute?.data;
                                    if (data?.length) return data.map((d)=>({
                                            points: d.linePoints,
                                            stroke: d.color
                                        }));
                                }
                                return [];
                            }
                        }
                    });
                    if (!chunk_JK3VNB42_n(text)) childrenMarks.push({
                        type: 'text',
                        interactive: false,
                        zIndex: 500,
                        animation: false,
                        dataId: spec.data?.id,
                        dataKey: ()=>`regressionLine-label-${lineIndex}`,
                        style: {
                            textAlign: 'end',
                            fill: textColor ?? theme.textColor,
                            fontSize: textFontSize ?? theme.textFontSize,
                            fontWeight: textFontWeight ?? theme.textFontWeight,
                            text: text,
                            x: (datum, ctx, opt)=>{
                                const parentNode = opt.mark?._product?.parent;
                                if (parentNode?.attribute?.data?.length) {
                                    const point = parentNode.attribute.data[parentNode.attribute.data.length - 1].linePoints;
                                    return point[point.length - 1]?.x;
                                }
                            },
                            y: (datum, ctx, opt)=>{
                                const parentNode = opt.mark?._product?.parent;
                                if (parentNode?.attribute?.data?.length) {
                                    const point = parentNode.attribute.data[parentNode.attribute.data.length - 1].linePoints;
                                    return point[point.length - 1]?.y;
                                }
                            }
                        }
                    });
                });
                return result;
            };
        const getDefaultRegressionOptions = (lineConfig)=>{
            const alpha = getAlphaByConfidenceLevel(lineConfig?.confidenceLevel);
            return {
                alpha
            };
        };
        const linearRegressionLine = generateRegressionLinePipe('linearRegressionLine', regressionLinear, getDefaultRegressionOptions);
        const lowessRegressionLine = generateRegressionLinePipe('lowessRegressionLine', regressionLowess, getDefaultRegressionOptions);
        const polynomialRegressionLine = generateRegressionLinePipe('polynomialRegressionLine', regressionPolynomial, (lineConfig)=>({
                ...getDefaultRegressionOptions(lineConfig),
                degree: lineConfig.degree ?? 2
            }), (lineConfig)=>(lineConfig.degree ?? 2) + 1);
        const logisticRegressionLine = generateRegressionLinePipe('logisticRegressionLine', regressionLogistic, getDefaultRegressionOptions);
        const scatter = [
            initScatter,
            colorAdapter(color_color, linearColor),
            background_backgroundColor,
            datasetScatter,
            progressive,
            xLinear,
            yLinear,
            scatterSize,
            labelScatter,
            tooltipScatter,
            colorAdapter(discreteLegend, colorLegend),
            verticalCrosshairLine,
            horizontalCrosshairLine,
            colorPointStyleFill(pointStyle_pointStyle),
            pointStateHover,
            annotationPoint_annotationPoint,
            annotationVerticalLine_annotationVerticalLine,
            annotationHorizontalLine_annotationHorizontalLine,
            annotationArea_annotationArea,
            linearRegressionLine,
            lowessRegressionLine,
            polynomialRegressionLine,
            logisticRegressionLine
        ];
        const pivotScatter = [
            initPivot,
            pivotGridStyle,
            pivotIndicatorsAsRow,
            datasetPivot,
            pivotIndicators_pivotIndicators([
                initScatter,
                colorAdapter(color_color, linearColor),
                background_backgroundColor,
                datasetScatter,
                progressive,
                xLinear,
                pivotAxisStyle(yLinear),
                scatterSize,
                labelScatter,
                tooltipScatter,
                verticalCrosshairLine,
                horizontalCrosshairLine,
                colorPointStyleFill(pointStyle_pointStyle),
                pointStateHover,
                annotationPoint_annotationPoint,
                annotationVerticalLine_annotationVerticalLine,
                annotationHorizontalLine_annotationHorizontalLine,
                annotationArea_annotationArea,
                linearRegressionLine,
                lowessRegressionLine,
                polynomialRegressionLine,
                logisticRegressionLine
            ]),
            pivotRowDimensions,
            pivotColumnDimensions,
            pivotTitle,
            colorAdapter(pivotDiscreteLegend, pivotColorLegend),
            dimensionLinkage
        ];
        const scatterSpecPipeline = [
            pivotAdapter_pivotAdapter(scatter, pivotScatter)
        ];
        const registerScatter = ()=>{
            Builder._advancedPipelineMap.scatter = scatterAdvancedPipeline;
            Builder._specPipelineMap.scatter = scatterSpecPipeline;
        };
        const defaultEncodingForDualAxis = (advancedVSeed)=>{
            const { measures: vseedMeasures = [], dimensions = [] } = advancedVSeed;
            const measures = findAllMeasures(vseedMeasures);
            const encoding = {};
            dualAxis_generateDefaultDimensionEncoding(dimensions, encoding);
            dualAxis_generateDefaultMeasureEncoding(measures, encoding);
            return {
                ...advancedVSeed,
                encoding
            };
        };
        const encodingForDualAxis = (advancedVSeed)=>{
            const { measures: vseedMeasures = [], dimensions = [] } = advancedVSeed;
            const measures = findAllMeasures(vseedMeasures);
            const hasDimensionEncoding = dimensions.some((item)=>item.encoding);
            const hasMeasureEncoding = measures.some((item)=>item.encoding);
            const encoding = {};
            if (hasDimensionEncoding) dualAxis_generateDimensionEncoding(dimensions, encoding, measures.length > 1);
            else dualAxis_generateDefaultDimensionEncoding(dimensions, encoding);
            if (hasMeasureEncoding) dualAxis_generateMeasureEncoding(measures, encoding);
            else dualAxis_generateDefaultMeasureEncoding(measures, encoding);
            return {
                ...advancedVSeed,
                encoding
            };
        };
        const dualAxis_generateDefaultDimensionEncoding = (dimensions, encoding)=>{
            const onlyMeasureId = 1 === dimensions.length && dimensions.find((item)=>item.id === MeasureId);
            const uniqueDimIds = chunk_QJLMYOTX_i(dimensions.map((d)=>d.id));
            encoding.x = uniqueDimIds.slice(0, 1);
            encoding.color = uniqueDimIds.slice(onlyMeasureId ? 0 : 1);
            encoding.detail = encoding.color;
            encoding.tooltip = uniqueDimIds.filter((d)=>d !== MeasureId);
            encoding.label = [];
            encoding.row = [];
            encoding.column = [];
        };
        const dualAxis_generateDimensionEncoding = (dimensions, encoding, isMultiMeasure)=>{
            encoding.x = chunk_QJLMYOTX_i(dimensions.filter((item)=>'xAxis' === item.encoding).map((item)=>item.id));
            if (0 === encoding.x.length) encoding.x = [
                dimensions[0].id
            ];
            addColorToEncoding(dimensions, encoding, isMultiMeasure);
            encoding.detail = chunk_QJLMYOTX_i(dimensions.filter((item)=>'detail' === item.encoding).map((item)=>item.id));
            if (0 === encoding.detail.length) encoding.detail = encoding.color;
            encoding.tooltip = chunk_QJLMYOTX_i(dimensions.map((item)=>item.id));
            encoding.tooltip = encoding.tooltip.filter((d)=>d !== MeasureId);
            encoding.label = chunk_QJLMYOTX_i(dimensions.filter((item)=>'label' === item.encoding).map((item)=>item.id));
            encoding.label = encoding.label.filter((d)=>d !== MeasureId);
        };
        const dualAxis_generateDefaultMeasureEncoding = (measures, encoding)=>{
            encoding.y = chunk_QJLMYOTX_i(measures.filter((item)=>'primaryYAxis' === item.encoding || 'secondaryYAxis' === item.encoding || !item.encoding).map((item)=>item.id));
        };
        const dualAxis_generateMeasureEncoding = (measures, encoding)=>{
            encoding.y = chunk_QJLMYOTX_i(measures.filter((item)=>'primaryYAxis' === item.encoding || 'secondaryYAxis' === item.encoding || !item.encoding).map((item)=>item.id));
            const color = chunk_QJLMYOTX_i(measures.filter((item)=>'color' === item.encoding).map((item)=>item.id));
            if (color.length > 0) encoding.color = color;
            const label = chunk_QJLMYOTX_i(measures.filter((item)=>'label' === item.encoding).map((item)=>item.id));
            encoding.label = chunk_QJLMYOTX_i([
                ...encoding.label || [],
                ...label
            ]);
            const tooltip = chunk_QJLMYOTX_i(measures.filter((item)=>'tooltip' === item.encoding).map((item)=>item.id));
            encoding.tooltip = chunk_QJLMYOTX_i([
                ...encoding.tooltip || [],
                ...label,
                ...tooltip
            ]);
        };
        const buildMeasuresForDualAxis = (advancedVSeed, context)=>{
            const { vseed } = context;
            if (isMeasureTreeWithChildren(advancedVSeed.measures)) return advancedVSeed;
            if (isMeasureTreeWithParentId(advancedVSeed.measures)) {
                advancedVSeed.measures = buildMeasuresForDualAxis_generateMeasuresByParentId(advancedVSeed.measures);
                return advancedVSeed;
            }
            const dualMeasures = vseed.dualMeasures ? chunk_BCBB46UE_d(vseed.dualMeasures) : basicMeasuresToDualMeasures(advancedVSeed.measures || []);
            advancedVSeed.measures = dualMeasuresToMeasureTree(dualMeasures);
            return advancedVSeed;
        };
        const basicMeasuresToDualMeasures = (basicMeasures)=>{
            const primaryMeasures = [];
            const secondaryMeasures = [];
            for(let index = 0; index < basicMeasures.length; index++){
                const item = basicMeasures[index];
                const encoding = Array.isArray(item.encoding) ? item.encoding : [
                    item.encoding
                ];
                const isPrimaryYAxis = encoding.includes('primaryYAxis');
                const isSecondaryYAxis = encoding.includes('secondaryYAxis');
                if (isPrimaryYAxis) primaryMeasures.push(item);
                else if (isSecondaryYAxis) secondaryMeasures.push(item);
                else if (0 === index) primaryMeasures.push(item);
                else secondaryMeasures.push(item);
            }
            return [
                {
                    id: 'dualMeasures',
                    primaryMeasures,
                    secondaryMeasures
                }
            ];
        };
        const dualMeasuresToMeasureTree = (dualMeasures)=>{
            const measureTree = dualMeasures.map((item, index)=>{
                const { id, primaryMeasures, secondaryMeasures } = item;
                const groupChildren = [];
                let groupId = `${id}-`;
                if (primaryMeasures) {
                    const arrPrimaryMeasures = Array.isArray(primaryMeasures) ? primaryMeasures : [
                        primaryMeasures
                    ];
                    const alias = arrPrimaryMeasures.map((item)=>item.alias || item.id).toString();
                    groupId += alias;
                    groupChildren.push({
                        id: `${index}-primary`,
                        alias: arrPrimaryMeasures.map((item)=>item.alias || item.id).toString(),
                        children: arrPrimaryMeasures
                    });
                }
                if (secondaryMeasures) {
                    const arrSecondaryMeasures = Array.isArray(secondaryMeasures) ? secondaryMeasures : [
                        secondaryMeasures
                    ];
                    const alias = arrSecondaryMeasures.map((item)=>item.alias || item.id).toString();
                    groupId += alias;
                    groupChildren.push({
                        id: `${index}-secondary`,
                        alias: arrSecondaryMeasures.map((item)=>item.alias || item.id).toString(),
                        children: arrSecondaryMeasures
                    });
                }
                return {
                    id: groupId,
                    alias: groupId,
                    children: groupChildren
                };
            });
            if (1 === dualMeasures.length) return measureTree[0].children || [];
            return measureTree;
        };
        const buildMeasuresForDualAxis_generateMeasuresByParentId = (measures)=>{
            const dualMeasures = [];
            measures.forEach((item)=>{
                const id = item.parentId || DEFAULT_PARENT_ID;
                if (!dualMeasures.find((d)=>d.id === id)) dualMeasures.push({
                    id,
                    primaryMeasures: [],
                    secondaryMeasures: []
                });
                const dualChart = dualMeasures.find((d)=>d.id === id);
                if (!dualChart || !Array.isArray(dualChart.primaryMeasures) || !Array.isArray(dualChart.secondaryMeasures)) return;
                const encoding = Array.isArray(item.encoding) ? item.encoding : [
                    item.encoding
                ].filter(Boolean);
                const isPrimary = encoding.includes('primaryYAxis');
                const isSecondary = encoding.includes('secondaryYAxis');
                const isEmpty = !item.encoding;
                if (isPrimary) dualChart.primaryMeasures.push(item);
                else if (isSecondary) dualChart.secondaryMeasures.push(item);
                else if (isEmpty) if (0 === dualChart.primaryMeasures.length) dualChart.primaryMeasures.push(item);
                else dualChart.secondaryMeasures.push(item);
            });
            return dualMeasuresToMeasureTree(dualMeasures);
        };
        const reshapeWithDualEncoding = (advancedVSeed, context)=>{
            const result = {
                ...advancedVSeed
            };
            const { vseed } = context;
            const { dataset } = vseed;
            const { encoding, chartType } = advancedVSeed;
            const measures = advancedVSeed.reshapeMeasures ?? advancedVSeed.measures ?? [];
            const dimensions = advancedVSeed.reshapeDimensions ?? advancedVSeed.dimensions ?? [];
            if (measures.length > 2) throw new Error('measures can not be more than 2 groups in dualAxis');
            const foldInfoList = [];
            const unfoldInfoList = [];
            const datasets = [];
            const primaryMeasures = measures[0];
            const secondaryMeasures = measures[1] || [];
            if (primaryMeasures && primaryMeasures.children) {
                const { dataset: newDataset, foldInfo, unfoldInfo } = dataReshapeByEncoding(dataset, T(dimensions, (item)=>item.id), T(primaryMeasures.children, (item)=>item.id), encoding, {
                    colorItemAsId: false,
                    foldMeasureValue: FoldPrimaryMeasureValue,
                    colorMeasureId: getColorMeasureId(advancedVSeed, vseed)
                });
                datasets.push(newDataset);
                foldInfoList.push(foldInfo);
                unfoldInfoList.push(unfoldInfo);
            }
            if (secondaryMeasures && secondaryMeasures.children) {
                const { dataset: newDataset, foldInfo, unfoldInfo } = dataReshapeByEncoding(dataset, T(dimensions, (item)=>item.id), T(secondaryMeasures.children, (item)=>item.id), encoding, {
                    colorItemAsId: false,
                    foldMeasureValue: FoldSecondaryMeasureValue,
                    colorMeasureId: getColorMeasureId(advancedVSeed, vseed)
                });
                datasets.push(newDataset);
                foldInfoList.push(foldInfo);
                unfoldInfoList.push(unfoldInfo);
            }
            const unfoldInfo = {
                ...unfoldInfoList[0],
                colorItems: unfoldInfoList.flatMap((d)=>d.colorItems),
                colorIdMap: unfoldInfoList.reduce((prev, cur)=>({
                        ...prev,
                        ...cur.colorIdMap
                    }), {})
            };
            return {
                ...result,
                dataset: datasets,
                datasetReshapeInfo: [
                    {
                        id: String(chartType),
                        index: 0,
                        foldInfo: foldInfoList[0],
                        foldInfoList: foldInfoList,
                        unfoldInfo: unfoldInfo
                    }
                ]
            };
        };
        const pivotReshapeWithDualEncoding = (advancedVSeed, context)=>{
            const result = {
                ...advancedVSeed
            };
            const { vseed } = context;
            const { dataset } = vseed;
            const { encoding, chartType } = advancedVSeed;
            const measures = advancedVSeed.reshapeMeasures ?? advancedVSeed.measures ?? [];
            const dimensions = advancedVSeed.reshapeDimensions ?? advancedVSeed.dimensions ?? [];
            const allMeasures = findAllMeasures(measures);
            const datasetList = [];
            const datasetReshapeInfo = [];
            const measureGroups = [];
            const depth = measureDepth(measures);
            if (3 === depth) measures.forEach((measure)=>{
                measureGroups.push(measure.children);
            });
            else if (2 === depth) measureGroups.push(measures);
            measureGroups.forEach((measures, index)=>{
                if (measures.length > 2) throw new Error('measures can not be more than 2 groups in dualAxis');
                const foldInfoList = [];
                const unfoldInfoList = [];
                const datasets = [];
                const primaryMeasures = measures[0];
                const secondaryMeasures = measures[1] || [];
                if (primaryMeasures && primaryMeasures.children) {
                    const { dataset: newDataset, foldInfo, unfoldInfo } = dataReshapeByEncoding(dataset, T(dimensions, (item)=>item.id), T(primaryMeasures.children, (item)=>item.id), encoding, {
                        colorItemAsId: false,
                        foldMeasureValue: `${FoldPrimaryMeasureValue}${index}`,
                        colorMeasureId: getColorMeasureId(advancedVSeed, vseed),
                        omitIds: allMeasures.map((item)=>item.id)
                    });
                    datasets.push(newDataset);
                    foldInfoList.push(foldInfo);
                    unfoldInfoList.push(unfoldInfo);
                }
                if (secondaryMeasures && secondaryMeasures.children) {
                    const { dataset: newDataset, foldInfo, unfoldInfo } = dataReshapeByEncoding(dataset, T(dimensions, (item)=>item.id), T(secondaryMeasures.children, (item)=>item.id), encoding, {
                        colorItemAsId: false,
                        foldMeasureValue: `${FoldSecondaryMeasureValue}${index}`,
                        colorMeasureId: getColorMeasureId(advancedVSeed, vseed),
                        omitIds: allMeasures.map((item)=>item.id)
                    });
                    datasets.push(newDataset);
                    foldInfoList.push(foldInfo);
                    unfoldInfoList.push(unfoldInfo);
                }
                const unfoldInfo = {
                    ...unfoldInfoList[0],
                    colorItems: unfoldInfoList.flatMap((d)=>d.colorItems),
                    colorIdMap: unfoldInfoList.reduce((prev, cur)=>({
                            ...prev,
                            ...cur.colorIdMap
                        }), {})
                };
                const reshapeInfo = {
                    id: `${chartType}-${index}`,
                    index,
                    foldInfo: foldInfoList[0],
                    foldInfoList: foldInfoList,
                    unfoldInfo: unfoldInfo
                };
                datasetReshapeInfo.push(reshapeInfo);
                datasetList.push(datasets.flat(2));
            });
            return {
                ...result,
                dataset: datasetList,
                datasetReshapeInfo: datasetReshapeInfo
            };
        };
        const dualAxisConfig = (advancedVSeed, context)=>{
            const { vseed } = context;
            const { chartType } = vseed;
            const result = {
                ...advancedVSeed
            };
            const pickedConfig = chunk_2T7K3PFL_i(vseed, [
                'backgroundColor',
                'color',
                'label',
                'legend',
                'tooltip',
                'xAxis',
                'dualChartType',
                'alignTicks',
                'primaryYAxis',
                'secondaryYAxis',
                'crosshairLine',
                'crosshairRect',
                'barGapInGroup',
                'barMaxWidth',
                'stackCornerRadius',
                'dimensionLinkage'
            ]);
            const config = replaceNullToUndefined(pickedConfig);
            result.config = {
                ...result.config || {},
                [chartType]: {
                    ...config
                }
            };
            return result;
        };
        const dualAxisAdvancedPipeline = [
            initAdvancedVSeed_initAdvancedVSeed,
            default_defaultMeasures_defaultMeasures,
            defaultDimensions_defaultDimensions,
            defaultMeasureId_defaultMeasureId,
            encodingAdapter([
                defaultEncodingForDualAxis,
                buildMeasuresForDualAxis
            ], [
                encodingForDualAxis,
                buildMeasuresForDualAxis,
                pickMeasuresForReshape([
                    'tooltip',
                    'label',
                    'color'
                ]),
                pickDimensionsForReshape
            ]),
            pivotAdapter([
                reshapeWithDualEncoding
            ], [
                pivotReshapeWithDualEncoding
            ]),
            sortXBandAxis,
            sortLegend_sortLegend,
            dualAxisConfig,
            theme_theme,
            markStyle_markStyle,
            annotation_annotation
        ];
        const series_series = (...args)=>{
            const result = {
                type: 'common',
                padding: 0,
                region: [
                    {
                        clip: true
                    }
                ]
            };
            return (_, context)=>{
                result.series = args.map((pipeline)=>execPipeline(pipeline, context, {}));
                return result;
            };
        };
        const seriesDualAxis = (...args)=>{
            const result = {
                type: 'common',
                padding: 0,
                labelLayout: 'region',
                region: [
                    {
                        clip: true
                    }
                ]
            };
            const createDualContext = (context, index)=>{
                const { advancedVSeed } = context;
                const dataset = advancedVSeed.dataset[index];
                return {
                    ...context,
                    advancedVSeed: {
                        ...advancedVSeed,
                        dataset: dataset
                    }
                };
            };
            return (_, context)=>{
                result.series = args.map((pipeline, index)=>{
                    const seriesContext = createDualContext(context, index);
                    return execPipeline(pipeline, seriesContext, {});
                });
                return result;
            };
        };
        const initDualAxisPrimary = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed } = context;
            const { datasetReshapeInfo } = advancedVSeed;
            const { unfoldInfo, foldInfoList, id } = datasetReshapeInfo[0];
            result.id = `${id}-primary-series`;
            result.type = 'bar';
            result.direction = 'vertical';
            result.xField = unfoldInfo.encodingX;
            result.seriesField = unfoldInfo.encodingColorId;
            result.yField = foldInfoList?.[0].measureValue;
            result.animation = true;
            return result;
        };
        const initDualAxisSecondary = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed, vseed } = context;
            const { datasetReshapeInfo } = advancedVSeed;
            const { unfoldInfo, foldInfoList, id } = datasetReshapeInfo[0];
            result.id = `${id}-secondary-series`;
            result.type = 'line';
            result.direction = 'vertical';
            result.xField = unfoldInfo.encodingX;
            if (foldInfoList?.[1]) result.yField = foldInfoList[1].measureValue;
            result.seriesField = isLinearColor(advancedVSeed, vseed) ? unfoldInfo.encodingDetail : unfoldInfo.encodingColorId;
            result.animation = true;
            return result;
        };
        const dualChartTypePrimary = (spec, context)=>{
            const result = {
                ...spec,
                zIndex: 1001
            };
            const { advancedVSeed, vseed } = context;
            const { chartType } = vseed;
            const { datasetReshapeInfo } = advancedVSeed;
            const index = datasetReshapeInfo[0].index;
            const config = advancedVSeed.config?.[chartType]?.dualChartType || {
                primary: 'column',
                secondary: 'line'
            };
            const primary = Array.isArray(config) ? config[index].primary || config[0].primary : config.primary;
            const secondary = Array.isArray(config) ? config[index].secondary || config[0].secondary : config.secondary;
            const bothColumn = 'column' === primary && 'column' === secondary;
            const type = bothColumn ? 'columnParallel' : primary;
            switch(type){
                case 'line':
                    result.type = 'line';
                    break;
                case 'column':
                    result.type = 'bar';
                    result.zIndex = 1000;
                    break;
                case 'columnParallel':
                    {
                        const columnSpec = result;
                        if (Array.isArray(columnSpec.xField)) columnSpec.xField.push(datasetReshapeInfo[0].unfoldInfo.encodingDetail);
                        else if (columnSpec.xField) columnSpec.xField = [
                            columnSpec.xField,
                            datasetReshapeInfo[0].unfoldInfo.encodingDetail
                        ];
                        columnSpec.type = 'bar';
                        result.zIndex = 1000;
                        break;
                    }
                case 'columnPercent':
                    result.type = 'bar';
                    result.percent = true;
                    result.zIndex = 1000;
                    break;
                case 'area':
                    result.type = 'area';
                    break;
                case 'areaPercent':
                    result.type = 'area';
                    result.percent = true;
                    break;
                case 'scatter':
                    result.type = 'scatter';
                    break;
                default:
                    result.type = primary;
            }
            return result;
        };
        const dualChartTypeSecondary = (spec, context)=>{
            const result = {
                ...spec,
                zIndex: 1001
            };
            const { advancedVSeed, vseed } = context;
            const { chartType } = vseed;
            const { datasetReshapeInfo } = advancedVSeed;
            const config = advancedVSeed.config?.[chartType]?.dualChartType || {
                primary: 'column',
                secondary: 'line'
            };
            const index = datasetReshapeInfo[0].index;
            const primary = Array.isArray(config) ? config[index].primary || config[0].primary : config.primary;
            const secondary = Array.isArray(config) ? config[index].secondary || config[0].secondary : config.secondary;
            const bothColumn = 'column' === primary && 'column' === secondary;
            const type = bothColumn ? 'columnParallel' : secondary;
            switch(type){
                case 'line':
                    result.type = 'line';
                    break;
                case 'column':
                    result.type = 'bar';
                    result.zIndex = 1000;
                    break;
                case 'columnParallel':
                    {
                        const columnSpec = result;
                        if (Array.isArray(columnSpec.xField)) columnSpec.xField.push(datasetReshapeInfo[0].unfoldInfo.encodingDetail);
                        else if (columnSpec.xField) columnSpec.xField = [
                            columnSpec.xField,
                            datasetReshapeInfo[0].unfoldInfo.encodingDetail
                        ];
                        columnSpec.type = 'bar';
                        result.zIndex = 1000;
                        break;
                    }
                case 'columnPercent':
                    result.type = 'bar';
                    result.percent = true;
                    result.zIndex = 1000;
                    break;
                case 'area':
                    result.type = 'area';
                    break;
                case 'areaPercent':
                    result.type = 'area';
                    result.percent = true;
                    break;
                case 'scatter':
                    result.type = 'scatter';
                    break;
                default:
                    result.type = secondary;
            }
            return result;
        };
        const datasetPrimary = (spec, context)=>{
            const { advancedVSeed, vseed } = context;
            const { analysis, datasetReshapeInfo } = advancedVSeed;
            const orderMapping = analysis?.orderMapping || {};
            const { unfoldInfo } = datasetReshapeInfo[0];
            const x = unfoldInfo.encodingX;
            const colorId = unfoldInfo.encodingColorId;
            const id = datasetReshapeInfo[0].id;
            const fields = {};
            if (x) {
                const order = orderMapping[x];
                if (order) fields[x] = {
                    sortIndex: 0,
                    domain: order,
                    lockStatisticsByDomain: true
                };
                else fields[x] = {
                    sortIndex: 0
                };
            }
            if (colorId) {
                const order = orderMapping[colorId];
                if (order) fields[colorId] = {
                    sortIndex: 0,
                    domain: order,
                    lockStatisticsByDomain: true
                };
                else fields[colorId] = {
                    sortIndex: 0
                };
            }
            return {
                ...spec,
                data: {
                    id: `${id}-primary-dataset`,
                    values: isPivotChart(vseed) ? void 0 : advancedVSeed.dataset,
                    fields: fields
                }
            };
        };
        const datasetSecondary = (spec, context)=>{
            const { advancedVSeed, vseed } = context;
            const { analysis, datasetReshapeInfo } = advancedVSeed;
            const orderMapping = analysis?.orderMapping || {};
            const { unfoldInfo } = datasetReshapeInfo[0];
            const x = unfoldInfo.encodingX;
            const colorId = unfoldInfo.encodingColorId;
            const id = datasetReshapeInfo[0].id;
            const fields = {};
            if (x) {
                const order = orderMapping[x];
                if (order) fields[x] = {
                    sortIndex: 0,
                    domain: order,
                    lockStatisticsByDomain: true
                };
                else fields[x] = {
                    sortIndex: 0
                };
            }
            if (colorId) {
                const order = orderMapping[colorId];
                if (order) fields[colorId] = {
                    sortIndex: 0,
                    domain: order,
                    lockStatisticsByDomain: true
                };
                else fields[colorId] = {
                    sortIndex: 0
                };
            }
            return {
                ...spec,
                data: {
                    id: `${id}-secondary-dataset`,
                    values: isPivotChart(vseed) ? void 0 : advancedVSeed.dataset,
                    fields: fields
                }
            };
        };
        const labelPrimary = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed, vseed } = context;
            const { datasetReshapeInfo, encoding } = advancedVSeed;
            const { chartType } = advancedVSeed;
            const baseConfig = advancedVSeed.config[chartType];
            const foldInfoList = datasetReshapeInfo[0].foldInfoList;
            result.label = buildLabel(baseConfig.label, vseed.measures, vseed.dimensions, advancedVSeed.dimensions, advancedVSeed.measures, encoding, [
                foldInfoList[0]
            ]);
            result.label.zIndex = 1002;
            return result;
        };
        const labelSecondary = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed, vseed } = context;
            const { datasetReshapeInfo, encoding } = advancedVSeed;
            const { chartType } = advancedVSeed;
            const baseConfig = advancedVSeed.config[chartType];
            const foldInfoList = datasetReshapeInfo[0].foldInfoList;
            result.label = buildLabel(baseConfig.label, vseed.measures, vseed.dimensions, advancedVSeed.dimensions, advancedVSeed.measures, encoding, [
                foldInfoList[1]
            ]);
            result.label.zIndex = 1002;
            return result;
        };
        const tooltipPrimary = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed, vseed } = context;
            const { measures, datasetReshapeInfo, chartType, dimensions, encoding } = advancedVSeed;
            const baseConfig = advancedVSeed.config[chartType];
            const { tooltip = {
                enable: true
            } } = baseConfig;
            const { enable } = tooltip;
            const foldInfoList = datasetReshapeInfo[0].foldInfoList;
            const unfoldInfo = datasetReshapeInfo[0].unfoldInfo;
            result.tooltip = {
                visible: enable,
                mark: {
                    title: {
                        visible: false
                    },
                    content: createMarkContent(encoding.tooltip || [], dimensions, findAllMeasures(vseed.measures), foldInfoList[0], unfoldInfo)
                },
                dimension: {
                    title: {
                        visible: true
                    },
                    content: createDimensionContent(dimensions, measures, foldInfoList[0], unfoldInfo)
                }
            };
            return result;
        };
        const tooltipSecondary = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed, vseed } = context;
            const { measures, datasetReshapeInfo, chartType, dimensions, encoding } = advancedVSeed;
            const baseConfig = advancedVSeed.config[chartType];
            const { tooltip = {
                enable: true
            } } = baseConfig;
            const { enable } = tooltip;
            if (chunk_JK3VNB42_n(datasetReshapeInfo[0].foldInfoList?.[1])) return result;
            const foldInfoList = datasetReshapeInfo[0].foldInfoList;
            const unfoldInfo = datasetReshapeInfo[0].unfoldInfo;
            result.tooltip = {
                visible: enable,
                mark: {
                    title: {
                        visible: false
                    },
                    content: createMarkContent(encoding.tooltip || [], dimensions, findAllMeasures(vseed.measures), foldInfoList[1], unfoldInfo)
                },
                dimension: {
                    title: {
                        visible: true
                    },
                    content: createDimensionContent(dimensions, measures, foldInfoList[1], unfoldInfo)
                }
            };
            return result;
        };
        const tooltipDualAxis = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed } = context;
            const { chartType } = advancedVSeed;
            const baseConfig = advancedVSeed.config[chartType];
            const { tooltip = {
                enable: true
            } } = baseConfig;
            result.tooltip = {
                style: getTooltipStyle(tooltip)
            };
            return result;
        };
        const barStyleFilter = (pipe)=>(spec, context)=>{
                if ('bar' === spec.type) return pipe(spec, context);
                return spec;
            };
        const pointStyleFilter = (pipe)=>(spec, context)=>{
                if ('line' === spec.type || 'area' === spec.type) return pipe(spec, context);
                return spec;
            };
        const lineStyleFilter = (pipe)=>(spec, context)=>{
                if ('line' === spec.type) return pipe(spec, context);
                return spec;
            };
        const areaStyleFilter = (pipe)=>(spec, context)=>{
                if ('area' === spec.type) return pipe(spec, context);
                return spec;
            };
        const yLinearPrimary = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed, vseed } = context;
            const { chartType } = vseed;
            const { datasetReshapeInfo, encoding, measures, dimensions } = advancedVSeed;
            const { index, id: reshapeInfoId, foldInfoList } = datasetReshapeInfo[0];
            const primaryYAxis = advancedVSeed.config?.[chartType]?.primaryYAxis;
            const yAxisConfig = Array.isArray(primaryYAxis) ? primaryYAxis[index] || primaryYAxis[0] : primaryYAxis;
            const alignTicks = advancedVSeed.config?.[chartType]?.alignTicks;
            const alignTicksConfig = Array.isArray(alignTicks) ? alignTicks[index] || alignTicks[0] : alignTicks;
            if (chunk_JK3VNB42_n(foldInfoList?.[0])) return result;
            const isEmptySecondary = chunk_VCYTMP4D_n(foldInfoList?.[0].foldMap);
            const id = `${reshapeInfoId}-primary-axis`;
            const seriesIds = [
                `${reshapeInfoId}-primary-series`,
                `${reshapeInfoId}-secondary-series`
            ];
            const seriesId = alignTicksConfig ? seriesIds : seriesIds[0];
            if (!result.axes) result.axes = [];
            const { visible = true, label, tick, title, grid, line, zero, nice, inverse, max, min, log, logBase = 10, autoFormat, numFormat = {} } = yAxisConfig ?? {};
            const formatter = createNumFormatter(numFormat);
            const linearAxis = {
                visible: isEmptySecondary ? false : visible,
                id,
                seriesId,
                type: log ? 'log' : 'linear',
                base: logBase,
                orient: 'left',
                nice,
                zero: log ? false : zero,
                inverse,
                max,
                min,
                label: {
                    space: 8,
                    visible: label?.visible,
                    formatMethod: (value)=>createLinearFormat(value, autoFormat, numFormat, formatter),
                    style: {
                        fill: label?.labelColor,
                        angle: label?.labelAngle,
                        fontSize: label?.labelFontSize,
                        fontWeight: label?.labelFontWeight
                    }
                },
                title: {
                    visible: title?.visible,
                    text: title?.titleText || defaultTitleText(measures, dimensions, encoding.y),
                    style: {
                        fill: title?.titleColor,
                        fontSize: title?.titleFontSize,
                        fontWeight: title?.titleFontWeight
                    }
                },
                tick: {
                    visible: tick?.visible,
                    tickSize: tick?.tickSize,
                    inside: tick?.tickInside,
                    style: {
                        stroke: tick?.tickColor
                    }
                },
                grid: {
                    visible: grid?.visible,
                    style: {
                        lineWidth: grid?.gridWidth,
                        stroke: grid?.gridColor,
                        lineDash: grid?.gridLineDash
                    }
                },
                domainLine: {
                    visible: line?.visible,
                    style: {
                        lineWidth: line?.lineWidth,
                        stroke: line?.lineColor
                    }
                },
                innerOffset: {
                    top: 12
                }
            };
            result.axes = [
                ...result.axes,
                linearAxis
            ];
            return result;
        };
        const yLinearSecondary = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed, vseed } = context;
            const { chartType } = vseed;
            const { datasetReshapeInfo, measures, dimensions, encoding } = advancedVSeed;
            const { index, id: reshapeInfoId, foldInfoList } = datasetReshapeInfo[0];
            const secondaryYAxis = advancedVSeed.config?.[chartType]?.secondaryYAxis;
            const yAxisConfig = Array.isArray(secondaryYAxis) ? secondaryYAxis[index] || secondaryYAxis[0] : secondaryYAxis;
            const alignTicks = advancedVSeed.config?.[chartType]?.alignTicks;
            const alignTicksConfig = Array.isArray(alignTicks) ? alignTicks[index] || alignTicks[0] : alignTicks;
            if (chunk_JK3VNB42_n(foldInfoList?.[1])) return result;
            const isEmptySecondary = chunk_VCYTMP4D_n(foldInfoList?.[1].foldMap);
            const onlySecondary = chunk_VCYTMP4D_n(foldInfoList?.[0].foldMap) && !isEmptySecondary;
            const sync = {
                axisId: `${reshapeInfoId}-primary-axis`,
                zeroAlign: true
            };
            const id = `${reshapeInfoId}-secondary-axis`;
            const seriesIds = [
                `${reshapeInfoId}-primary-series`,
                `${reshapeInfoId}-secondary-series`
            ];
            const seriesId = alignTicksConfig ? seriesIds : seriesIds[1];
            if (!result.axes) result.axes = [];
            const { visible = true, label, tick, title, grid, line, zero, nice, inverse, max, min, log, logBase = 10, numFormat = {}, autoFormat } = yAxisConfig ?? {};
            const formatter = createNumFormatter(numFormat);
            const linearAxis = {
                visible: isEmptySecondary ? false : visible,
                id,
                seriesId,
                sync,
                type: log ? 'log' : 'linear',
                base: logBase,
                orient: 'right',
                nice,
                zero: log ? false : zero,
                inverse,
                max,
                min,
                label: {
                    space: 8,
                    visible: label?.visible,
                    formatMethod: (value)=>createLinearFormat(value, autoFormat, numFormat, formatter),
                    style: {
                        fill: label?.labelColor,
                        angle: label?.labelAngle,
                        fontSize: label?.labelFontSize,
                        fontWeight: label?.labelFontWeight
                    }
                },
                title: {
                    visible: title?.visible,
                    text: title?.titleText || defaultTitleText(measures, dimensions, encoding.y),
                    style: {
                        fill: title?.titleColor,
                        fontSize: title?.titleFontSize,
                        fontWeight: title?.titleFontWeight
                    }
                },
                tick: {
                    visible: tick?.visible,
                    tickSize: tick?.tickSize,
                    inside: tick?.tickInside,
                    style: {
                        stroke: tick?.tickColor
                    }
                },
                grid: {
                    visible: onlySecondary ? true : grid?.visible,
                    style: {
                        lineWidth: grid?.gridWidth,
                        stroke: grid?.gridColor,
                        lineDash: grid?.gridLineDash
                    }
                },
                domainLine: {
                    visible: line?.visible,
                    style: {
                        lineWidth: line?.lineWidth,
                        stroke: line?.lineColor
                    }
                },
                innerOffset: {
                    top: 12
                }
            };
            result.axes = [
                ...result.axes,
                linearAxis
            ];
            return result;
        };
        const linearColorForDualAxis = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed } = context;
            const { datasetReshapeInfo, chartType } = advancedVSeed;
            const { unfoldInfo, id } = datasetReshapeInfo[0];
            const baseConfig = advancedVSeed.config[chartType];
            if (!baseConfig || !baseConfig.color) return result;
            const { color } = baseConfig;
            const { colorScheme, linearColorScheme } = color;
            result.color = {
                type: 'linear',
                range: linearColorScheme || colorScheme || [],
                domain: [
                    {
                        dataId: `${id}-primary-dataset`,
                        fields: [
                            unfoldInfo.encodingColor
                        ]
                    },
                    {
                        dataId: `${id}-secondary-dataset`,
                        fields: [
                            unfoldInfo.encodingColor
                        ]
                    }
                ]
            };
            return result;
        };
        const isObjectLike = (value)=>"object" == typeof value && null !== value;
        const common_isObjectLike = isObjectLike;
        const isPlainObject = function(value) {
            if (!common_isObjectLike(value) || !common_isType(value, "Object")) return !1;
            if (null === Object.getPrototypeOf(value)) return !0;
            let proto = value;
            for(; null !== Object.getPrototypeOf(proto);)proto = Object.getPrototypeOf(proto);
            return Object.getPrototypeOf(value) === proto;
        };
        const common_isPlainObject = isPlainObject;
        const isString = (value, fuzzy = !1)=>{
            const type = typeof value;
            return fuzzy ? "string" === type : "string" === type || common_isType(value, "String");
        };
        const common_isString = isString;
        function pickWithout(obj, keys) {
            if (!obj || !common_isPlainObject(obj)) return obj;
            const result = {};
            return Object.keys(obj).forEach((k)=>{
                const v = obj[k];
                let match = !1;
                keys.forEach((itKey)=>{
                    (common_isString(itKey) && itKey === k || itKey instanceof RegExp && k.match(itKey)) && (match = !0);
                }), match || (result[k] = v);
            }), result;
        }
        const annotationPointOfDualAxis = generateAnnotationPointPipe({
            findSelectedDatas: (dataset, s, spec, context)=>dataset.reduce((res, d)=>{
                    const { advancedVSeed } = context;
                    const allMeasureIds = findAllMeasures(advancedVSeed.reshapeMeasures ?? advancedVSeed.measures).map((m)=>m.id);
                    const pickedDatum = pickWithout(d, allMeasureIds.filter((id)=>id !== d[MeasureId]));
                    if (selector_selector(pickedDatum, s)) res.push(pickedDatum);
                    return res;
                }, []),
            generateMarkPoint: (datum, spec, context)=>{
                const { advancedVSeed } = context;
                const allMeasureIds = findAllMeasures(advancedVSeed.reshapeMeasures ?? advancedVSeed.measures).map((m)=>m.id);
                return spec.series?.map((s, index)=>({
                        relativeSeriesIndex: index,
                        coordinate: (data)=>data.find((item)=>isSubset(datum, item, allMeasureIds.filter((id)=>id !== item[MeasureId])))
                    }));
            }
        });
        const dualAxis = [
            seriesDualAxis([
                initDualAxisPrimary,
                dualChartTypePrimary,
                datasetPrimary,
                labelPrimary,
                tooltipPrimary,
                progressive,
                barMaxWidth_barMaxWidth,
                barGapInGroup_barGapInGroup,
                stackCornerRadius_stackCornerRadius,
                barStyleFilter(colorBarStyleFill(barStyle_barStyle)),
                pointStyleFilter(colorPointStyleFill(pointStyle_pointStyle)),
                pointStyleFilter(pointStateDimensionHover),
                lineStyleFilter(colorLineStyleFill(lineStyle_lineStyle)),
                areaStyleFilter(colorAreaStyleFill(areaStyle_areaStyle))
            ], [
                initDualAxisSecondary,
                dualChartTypeSecondary,
                datasetSecondary,
                labelSecondary,
                tooltipSecondary,
                progressive,
                barMaxWidth_barMaxWidth,
                barGapInGroup_barGapInGroup,
                stackCornerRadius_stackCornerRadius,
                barStyleFilter(colorBarStyleFill(barStyle_barStyle)),
                pointStyleFilter(colorPointStyleFill(pointStyle_pointStyle)),
                pointStyleFilter(pointStateDimensionHover),
                lineStyleFilter(colorLineStyleFill(lineStyle_lineStyle)),
                areaStyleFilter(colorAreaStyleFill(areaStyle_areaStyle))
            ]),
            xBand,
            yLinearPrimary,
            yLinearSecondary,
            colorAdapter(color_color, linearColorForDualAxis),
            colorAdapter(discreteLegend, colorLegend),
            background_backgroundColor,
            verticalCrosshairRect,
            annotationPointOfDualAxis,
            annotationVerticalLine_annotationVerticalLine,
            annotationHorizontalLine_annotationHorizontalLine,
            annotationAreaBand,
            tooltipDualAxis
        ];
        const pivotDualAxis = [
            initPivot,
            pivotGridStyle,
            pivotIndicatorsAsRow,
            datasetPivot,
            pivotIndicators_pivotIndicators([
                series_series([
                    initDualAxisPrimary,
                    dualChartTypePrimary,
                    datasetPrimary,
                    labelPrimary,
                    tooltipPrimary,
                    progressive,
                    stackCornerRadius_stackCornerRadius,
                    barMaxWidth_barMaxWidth,
                    barGapInGroup_barGapInGroup,
                    colorBarStyleFill(barStyle_barStyle),
                    colorPointStyleFill(pointStyle_pointStyle),
                    pointStateDimensionHover,
                    colorLineStyleFill(lineStyle_lineStyle),
                    colorAreaStyleFill(areaStyle_areaStyle)
                ], [
                    initDualAxisSecondary,
                    dualChartTypeSecondary,
                    datasetSecondary,
                    labelSecondary,
                    tooltipSecondary,
                    progressive,
                    stackCornerRadius_stackCornerRadius,
                    barMaxWidth_barMaxWidth,
                    barGapInGroup_barGapInGroup,
                    colorBarStyleFill(barStyle_barStyle),
                    colorPointStyleFill(pointStyle_pointStyle),
                    pointStateDimensionHover,
                    colorLineStyleFill(lineStyle_lineStyle),
                    colorAreaStyleFill(areaStyle_areaStyle)
                ]),
                xBand,
                yLinearPrimary,
                pivotAxisStyle(yLinearSecondary),
                colorAdapter(color_color, linearColor),
                background_backgroundColor,
                verticalCrosshairRect,
                annotationPointOfDualAxis,
                annotationVerticalLine_annotationVerticalLine,
                annotationHorizontalLine_annotationHorizontalLine,
                annotationAreaBand,
                tooltipDualAxis
            ]),
            pivotRowDimensions,
            pivotColumnDimensions,
            pivotTitle,
            colorAdapter(pivotDiscreteLegend, pivotColorLegend),
            dimensionLinkage
        ];
        const dualAxisSpecPipeline = [
            pivotAdapter_pivotAdapter(dualAxis, pivotDualAxis)
        ];
        const registerDualAxis = ()=>{
            Builder._advancedPipelineMap.dualAxis = dualAxisAdvancedPipeline;
            Builder._specPipelineMap.dualAxis = dualAxisSpecPipeline;
        };
        const defaultEncodingForPie = (advancedVSeed)=>{
            const { measures: vseedMeasures = [], dimensions = [] } = advancedVSeed;
            const measures = findAllMeasures(vseedMeasures);
            const encoding = {};
            pie_generateDefaultDimensionEncoding(dimensions, encoding, hasMultipleMeasureInSingleView(vseedMeasures));
            pie_generateDefaultMeasureEncoding(measures, encoding);
            return {
                ...advancedVSeed,
                encoding
            };
        };
        const encodingForPie = (advancedVSeed)=>{
            const { measures: vseedMeasures = [], dimensions = [] } = advancedVSeed;
            const measures = findAllMeasures(vseedMeasures);
            const hasDimensionEncoding = dimensions.some((item)=>item.encoding);
            const hasMeasureEncoding = measures.some((item)=>item.encoding);
            const encoding = {};
            const hasMulti = hasMultipleMeasureInSingleView(vseedMeasures);
            if (hasDimensionEncoding) pie_generateDimensionEncoding(dimensions, encoding, hasMulti);
            else pie_generateDefaultDimensionEncoding(dimensions, encoding, hasMulti);
            if (hasMeasureEncoding) pie_generateMeasureEncoding(measures, encoding);
            else pie_generateDefaultMeasureEncoding(measures, encoding);
            return {
                ...advancedVSeed,
                encoding
            };
        };
        const pie_generateDefaultDimensionEncoding = (dimensions, encoding, isMultiMeasure)=>{
            const uniqueDimIds = chunk_QJLMYOTX_i(dimensions.map((d)=>d.id));
            if (isMultiMeasure) encoding.color = uniqueDimIds.slice(0);
            else encoding.color = uniqueDimIds.filter((d)=>d !== MeasureId);
            encoding.detail = encoding.color;
            encoding.tooltip = uniqueDimIds.filter((d)=>d !== MeasureId);
            encoding.label = [];
            encoding.row = [];
            encoding.column = [];
        };
        const pie_generateDimensionEncoding = (dimensions, encoding, isMultiMeasure)=>{
            addColorToEncoding(dimensions, encoding, isMultiMeasure);
            encoding.detail = chunk_QJLMYOTX_i(dimensions.filter((item)=>'detail' === item.encoding).map((item)=>item.id));
            if (0 === encoding.detail.length) encoding.detail = [
                MeasureId
            ];
            encoding.tooltip = chunk_QJLMYOTX_i(dimensions.map((item)=>item.id));
            encoding.tooltip = encoding.tooltip.filter((d)=>d !== MeasureId);
            encoding.label = chunk_QJLMYOTX_i(dimensions.filter((item)=>'label' === item.encoding).map((item)=>item.id));
            encoding.label = encoding.label.filter((d)=>d !== MeasureId);
        };
        const pie_generateDefaultMeasureEncoding = (measures, encoding)=>{
            encoding.angle = chunk_QJLMYOTX_i(measures.filter((item)=>'angle' === item.encoding || !item.encoding).map((item)=>item.id));
        };
        const pie_generateMeasureEncoding = (measures, encoding)=>{
            encoding.angle = chunk_QJLMYOTX_i(measures.filter((item)=>'angle' === item.encoding || !item.encoding).map((item)=>item.id));
            const color = chunk_QJLMYOTX_i(measures.filter((item)=>'color' === item.encoding).map((item)=>item.id));
            if (color.length > 0) encoding.color = color;
            const label = chunk_QJLMYOTX_i(measures.filter((item)=>'label' === item.encoding).map((item)=>item.id));
            encoding.label = chunk_QJLMYOTX_i([
                ...encoding.label || [],
                ...label
            ]);
            const tooltip = chunk_QJLMYOTX_i(measures.filter((item)=>'tooltip' === item.encoding).map((item)=>item.id));
            encoding.tooltip = chunk_QJLMYOTX_i([
                ...encoding.tooltip || [],
                ...label,
                ...tooltip
            ]);
        };
        const pieAdvancedPipeline = [
            initAdvancedVSeed_initAdvancedVSeed,
            default_defaultMeasures_defaultMeasures,
            defaultDimensions_defaultDimensions,
            defaultMeasureId_defaultMeasureId,
            encodingAdapter([
                buildMeasures,
                defaultEncodingForPie
            ], [
                buildMeasures,
                encodingForPie,
                pickMeasuresForReshape([
                    'tooltip',
                    'label',
                    'color'
                ]),
                pickDimensionsForReshape
            ]),
            pivotAdapter([
                reshapeWithEncoding
            ], [
                pivotReshapeWithEncoding
            ]),
            pieConfig,
            theme_theme,
            annotation_annotation
        ];
        const initPie = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed } = context;
            const { datasetReshapeInfo } = advancedVSeed;
            const { unfoldInfo, foldInfo } = datasetReshapeInfo[0];
            result.type = 'pie';
            result.outerRadius = 0.8;
            result.innerRadius = 0;
            result.valueField = foldInfo.measureValue;
            result.categoryField = unfoldInfo.encodingColorId;
            result.padding = 0;
            result.region = [
                {
                    clip: true
                }
            ];
            result.animation = true;
            return result;
        };
        const colorPieStyleFill = (stylePipe)=>(spec, context)=>{
                const result = stylePipe(spec, context);
                const { advancedVSeed, vseed } = context;
                const { datasetReshapeInfo } = advancedVSeed;
                const { unfoldInfo } = datasetReshapeInfo[0];
                if (isLinearColor(advancedVSeed, vseed)) {
                    if (result?.pie?.style) result.pie.style.fill = {
                        field: unfoldInfo.encodingColor,
                        scale: 'color'
                    };
                }
                return result;
            };
        const pieStyle = (spec, context)=>{
            const { advancedVSeed, vseed } = context;
            const { chartType } = vseed;
            const { dataset } = advancedVSeed;
            const showStroke = dataset.length <= 30;
            const config = advancedVSeed.config?.[chartType];
            const result = {
                ...spec,
                pie: {
                    style: {
                        stroke: config?.backgroundColor ?? '#ffffff',
                        lineWidth: showStroke ? 1 : 0
                    }
                }
            };
            if (spec.outerRadius) result.pie.state = {
                hover: {
                    outerRadius: 1.1 * spec.outerRadius
                }
            };
            if (config?.cornerRadius) result.pie.style.cornerRadius = config.cornerRadius;
            return result;
        };
        const labelPie = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed, vseed } = context;
            const { datasetReshapeInfo } = advancedVSeed;
            const { chartType, encoding } = advancedVSeed;
            const baseConfig = advancedVSeed.config[chartType];
            const foldInfo = datasetReshapeInfo[0].foldInfo;
            const { label } = baseConfig;
            result.label = buildLabel(label, vseed.measures, vseed.dimensions, advancedVSeed.dimensions, advancedVSeed.measures, encoding, [
                foldInfo
            ]);
            if (label.labelLayout) result.label.layout = {
                align: label.labelLayout
            };
            return result;
        };
        const pivotHideIndicatorName = (spec, context)=>{
            const { advancedVSeed } = context;
            const { datasetReshapeInfo } = advancedVSeed;
            return {
                ...spec,
                hideIndicatorName: datasetReshapeInfo.length <= 1
            };
        };
        const addRegionPadding = (spec)=>{
            const result = {
                ...spec
            };
            if (result.region && result.region.length > 0) result.region[0].padding = 10;
            return result;
        };
        const pie = [
            initPie,
            colorAdapter(color_color, linearColor),
            background_backgroundColor,
            datasetXY,
            progressive,
            colorPieStyleFill(pieStyle),
            colorAdapter(discreteLegend, colorLegend),
            labelPie,
            tooltip_tooltip,
            annotationPoint_annotationPoint,
            annotationVerticalLine_annotationVerticalLine,
            annotationHorizontalLine_annotationHorizontalLine,
            annotationArea_annotationArea
        ];
        const pivotPie = [
            initPivot,
            pivotGridStyle,
            pivotIndicatorsAsRow,
            pivotHideIndicatorName,
            datasetPivot,
            pivotIndicators_pivotIndicators([
                initPie,
                colorAdapter(color_color, linearColor),
                background_backgroundColor,
                datasetXY,
                progressive,
                colorPieStyleFill(pieStyle),
                labelPie,
                tooltip_tooltip,
                annotationPoint_annotationPoint,
                annotationVerticalLine_annotationVerticalLine,
                annotationHorizontalLine_annotationHorizontalLine,
                annotationArea_annotationArea,
                addRegionPadding
            ]),
            pivotRowDimensions,
            pivotColumnDimensions,
            pivotTitle,
            colorAdapter(pivotDiscreteLegend, pivotColorLegend)
        ];
        const pieSpecPipeline = [
            pivotAdapter_pivotAdapter(pie, pivotPie)
        ];
        const registerPie = ()=>{
            Builder._advancedPipelineMap.pie = pieAdvancedPipeline;
            Builder._specPipelineMap.pie = pieSpecPipeline;
        };
        const donutAdvancedPipeline = [
            initAdvancedVSeed_initAdvancedVSeed,
            default_defaultMeasures_defaultMeasures,
            defaultDimensions_defaultDimensions,
            defaultMeasureId_defaultMeasureId,
            encodingAdapter([
                buildMeasures,
                defaultEncodingForPie
            ], [
                buildMeasures,
                encodingForPie,
                pickMeasuresForReshape([
                    'tooltip',
                    'label',
                    'color'
                ]),
                pickDimensionsForReshape
            ]),
            pivotAdapter([
                reshapeWithEncoding
            ], [
                pivotReshapeWithEncoding
            ]),
            donutConfig,
            theme_theme,
            annotation_annotation
        ];
        const initDonut = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed } = context;
            const { datasetReshapeInfo } = advancedVSeed;
            const { foldInfo, unfoldInfo } = datasetReshapeInfo[0];
            result.type = 'pie';
            result.outerRadius = 0.8;
            result.innerRadius = 0.8 * result.outerRadius;
            result.valueField = foldInfo.measureValue;
            result.categoryField = unfoldInfo.encodingColorId;
            result.padding = 0;
            result.region = [
                {
                    clip: true
                }
            ];
            result.animation = true;
            return result;
        };
        const donut = [
            initDonut,
            colorAdapter(color_color, linearColor),
            background_backgroundColor,
            datasetXY,
            progressive,
            labelPie,
            colorPieStyleFill(pieStyle),
            colorAdapter(discreteLegend, colorLegend),
            tooltip_tooltip,
            annotationPoint_annotationPoint,
            annotationVerticalLine_annotationVerticalLine,
            annotationHorizontalLine_annotationHorizontalLine,
            annotationArea_annotationArea
        ];
        const pivotDonut = [
            initPivot,
            pivotGridStyle,
            pivotIndicatorsAsRow,
            pivotHideIndicatorName,
            datasetPivot,
            pivotIndicators_pivotIndicators([
                initDonut,
                addRegionPadding,
                colorAdapter(color_color, linearColor),
                background_backgroundColor,
                datasetXY,
                progressive,
                labelPie,
                colorPieStyleFill(pieStyle),
                tooltip_tooltip,
                annotationPoint_annotationPoint,
                annotationVerticalLine_annotationVerticalLine,
                annotationHorizontalLine_annotationHorizontalLine,
                annotationArea_annotationArea
            ]),
            pivotRowDimensions,
            pivotColumnDimensions,
            pivotTitle,
            colorAdapter(pivotDiscreteLegend, pivotColorLegend)
        ];
        const donutSpecPipeline = [
            pivotAdapter_pivotAdapter(donut, pivotDonut)
        ];
        const registerDonut = ()=>{
            Builder._advancedPipelineMap.donut = donutAdvancedPipeline;
            Builder._specPipelineMap.donut = donutSpecPipeline;
        };
        const defaultEncodingForRose = (advancedVSeed)=>{
            const { measures: vseedMeasures = [], dimensions = [] } = advancedVSeed;
            const measures = findAllMeasures(vseedMeasures);
            const encoding = {};
            rose_generateDefaultDimensionEncoding(dimensions, encoding);
            rose_generateDefaultMeasureEncoding(measures, encoding);
            return {
                ...advancedVSeed,
                encoding
            };
        };
        const encodingForRose = (advancedVSeed)=>{
            const { measures: vseedMeasures = [], dimensions = [] } = advancedVSeed;
            const measures = findAllMeasures(vseedMeasures);
            const hasDimensionEncoding = dimensions.some((item)=>item.encoding);
            const hasMeasureEncoding = measures.some((item)=>item.encoding);
            const encoding = {};
            if (hasDimensionEncoding) rose_generateDimensionEncoding(dimensions, encoding, measures.length > 1);
            else rose_generateDefaultDimensionEncoding(dimensions, encoding);
            if (hasMeasureEncoding) rose_generateMeasureEncoding(measures, encoding);
            else rose_generateDefaultMeasureEncoding(measures, encoding);
            return {
                ...advancedVSeed,
                encoding
            };
        };
        const rose_generateDefaultDimensionEncoding = (dimensions, encoding)=>{
            const onlyMeasureId = 1 === dimensions.length && dimensions.find((item)=>item.id === MeasureId);
            const uniqueDimIds = chunk_QJLMYOTX_i(dimensions.map((d)=>d.id));
            encoding.angle = uniqueDimIds.slice(0, 1);
            encoding.color = uniqueDimIds.slice(onlyMeasureId ? 0 : 1);
            encoding.detail = encoding.color;
            encoding.tooltip = uniqueDimIds.filter((d)=>d !== MeasureId);
            encoding.label = [];
            encoding.row = [];
            encoding.column = [];
        };
        const rose_generateDimensionEncoding = (dimensions, encoding, isMultiMeasure)=>{
            encoding.angle = chunk_QJLMYOTX_i(dimensions.filter((item)=>'angle' === item.encoding).map((item)=>item.id));
            if (0 === encoding.angle.length) encoding.angle = [
                dimensions[0].id
            ];
            addColorToEncoding(dimensions, encoding, isMultiMeasure);
            encoding.detail = chunk_QJLMYOTX_i(dimensions.filter((item)=>'detail' === item.encoding).map((item)=>item.id));
            if (0 === encoding.detail.length) encoding.detail = encoding.color;
            encoding.tooltip = chunk_QJLMYOTX_i(dimensions.map((item)=>item.id));
            encoding.tooltip = encoding.tooltip.filter((d)=>d !== MeasureId);
            encoding.label = chunk_QJLMYOTX_i(dimensions.filter((item)=>'label' === item.encoding).map((item)=>item.id));
            encoding.label = encoding.label.filter((d)=>d !== MeasureId);
        };
        const rose_generateDefaultMeasureEncoding = (measures, encoding)=>{
            encoding.radius = chunk_QJLMYOTX_i(measures.filter((item)=>'radius' === item.encoding || !item.encoding).map((item)=>item.id));
        };
        const rose_generateMeasureEncoding = (measures, encoding)=>{
            encoding.radius = chunk_QJLMYOTX_i(measures.filter((item)=>'radius' === item.encoding || !item.encoding).map((item)=>item.id));
            const color = chunk_QJLMYOTX_i(measures.filter((item)=>'color' === item.encoding).map((item)=>item.id));
            if (color.length > 0) encoding.color = color;
            const label = chunk_QJLMYOTX_i(measures.filter((item)=>'label' === item.encoding).map((item)=>item.id));
            encoding.label = chunk_QJLMYOTX_i([
                ...encoding.label || [],
                ...label
            ]);
            const tooltip = chunk_QJLMYOTX_i(measures.filter((item)=>'tooltip' === item.encoding).map((item)=>item.id));
            encoding.tooltip = chunk_QJLMYOTX_i([
                ...encoding.tooltip || [],
                ...label,
                ...tooltip
            ]);
        };
        const roseAdvancedPipeline = [
            initAdvancedVSeed_initAdvancedVSeed,
            default_defaultMeasures_defaultMeasures,
            defaultDimensions_defaultDimensions,
            defaultMeasureId_defaultMeasureId,
            encodingAdapter([
                defaultEncodingForRose,
                buildMeasures
            ], [
                encodingForRose,
                buildMeasures,
                pickMeasuresForReshape([
                    'tooltip',
                    'label',
                    'color'
                ]),
                pickDimensionsForReshape
            ]),
            pivotAdapter([
                reshapeWithEncoding
            ], [
                pivotReshapeWithEncoding
            ]),
            roseConfig,
            theme_theme,
            markStyle_markStyle,
            annotation_annotation
        ];
        const initRose = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed } = context;
            const { dataset, datasetReshapeInfo } = advancedVSeed;
            const { foldInfo, unfoldInfo } = datasetReshapeInfo[0];
            result.type = 'rose';
            result.angleField = unfoldInfo.encodingAngle;
            result.seriesField = unfoldInfo.encodingColorId;
            result.valueField = foldInfo.measureValue;
            result.padding = 0;
            result.outerRadius = 0.9;
            result.innerRadius = 0;
            const hasNegativeValue = dataset.flat().find((d)=>d[foldInfo.measureValue] < 0);
            if (hasNegativeValue) result.innerRadius = 0.05;
            result.region = [
                {
                    clip: true
                }
            ];
            result.animation = true;
            return result;
        };
        const radiusAxis = (spec)=>{
            const result = {
                ...spec
            };
            if (!result.axes) result.axes = [];
            result.axes.push({
                type: 'linear',
                orient: 'radius',
                visible: false,
                zero: true,
                nice: false
            });
            return result;
        };
        const colorRoseStyleFill = (stylePipe)=>(spec, context)=>{
                const result = stylePipe(spec, context);
                const { advancedVSeed, vseed } = context;
                const { datasetReshapeInfo } = advancedVSeed;
                const { unfoldInfo } = datasetReshapeInfo[0];
                if (isLinearColor(advancedVSeed, vseed)) {
                    if (result?.rose?.style) result.rose.style.fill = {
                        field: unfoldInfo.encodingColor,
                        scale: 'color'
                    };
                }
                return result;
            };
        const roseStyle = (spec, context)=>{
            const { advancedVSeed } = context;
            const { dataset } = advancedVSeed;
            const showStroke = dataset.length <= 30;
            const result = {
                ...spec,
                rose: {
                    style: {}
                }
            };
            return {
                ...result,
                rose: {
                    style: {
                        stroke: '#ffffff',
                        lineWidth: showStroke ? 1 : 0
                    },
                    state: {
                        hover: {
                            lineWidth: 1,
                            fillOpacity: 0.6
                        }
                    }
                }
            };
        };
        const rose = [
            initRose,
            stackCornerRadius_stackCornerRadius,
            stackInverse,
            colorAdapter(color_color, linearColor),
            background_backgroundColor,
            datasetXY,
            progressive,
            radiusAxis,
            verticalCrosshairRect,
            colorRoseStyleFill(roseStyle),
            colorAdapter(discreteLegend, colorLegend),
            labelPie,
            tooltip_tooltip
        ];
        const pivotRose = [
            initPivot,
            pivotGridStyle,
            pivotIndicatorsAsRow,
            pivotHideIndicatorName,
            datasetPivot,
            pivotIndicators_pivotIndicators([
                initRose,
                addRegionPadding,
                stackCornerRadius_stackCornerRadius,
                stackInverse,
                colorAdapter(color_color, linearColor),
                background_backgroundColor,
                datasetXY,
                progressive,
                radiusAxis,
                verticalCrosshairRect,
                colorRoseStyleFill(roseStyle),
                labelPie,
                tooltip_tooltip
            ]),
            pivotRowDimensions,
            pivotColumnDimensions,
            pivotTitle,
            colorAdapter(pivotDiscreteLegend, pivotColorLegend)
        ];
        const roseSpecPipeline = [
            pivotAdapter_pivotAdapter(rose, pivotRose)
        ];
        const registerRose = ()=>{
            Builder._advancedPipelineMap.rose = roseAdvancedPipeline;
            Builder._specPipelineMap.rose = roseSpecPipeline;
        };
        const roseParallelAdvancedPipeline = [
            initAdvancedVSeed_initAdvancedVSeed,
            default_defaultMeasures_defaultMeasures,
            defaultDimensions_defaultDimensions,
            defaultMeasureId_defaultMeasureId,
            encodingAdapter([
                defaultEncodingForRose,
                buildMeasures
            ], [
                encodingForRose,
                buildMeasures,
                pickMeasuresForReshape([
                    'tooltip',
                    'label',
                    'color'
                ]),
                pickDimensionsForReshape
            ]),
            pivotAdapter([
                reshapeWithEncoding
            ], [
                pivotReshapeWithEncoding
            ]),
            roseParallelConfig,
            theme_theme,
            markStyle_markStyle,
            annotation_annotation
        ];
        const initRoseParallel = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed } = context;
            const { datasetReshapeInfo, dataset, encoding } = advancedVSeed;
            const { unfoldInfo, foldInfo } = datasetReshapeInfo[0];
            const sameDimensionsMode = chunk_HGKLN5KY_k(encoding.angle, encoding.color);
            result.type = 'rose';
            result.angleField = [
                unfoldInfo.encodingAngle
            ];
            if (!sameDimensionsMode) {
                result.angleField.push(unfoldInfo.encodingDetail);
                if (encoding.detail?.[0] === MeasureId && encoding.radius?.length === 1) result.angleField.pop();
            }
            result.valueField = foldInfo.measureValue;
            result.seriesField = unfoldInfo.encodingColorId;
            result.padding = 0;
            result.outerRadius = 0.9;
            result.innerRadius = 0;
            const hasNegativeValue = dataset.flat().find((d)=>d[foldInfo.measureValue] < 0);
            if (hasNegativeValue) result.innerRadius = 0.05;
            result.rose = {
                style: {
                    stroke: '#ffffff',
                    lineWidth: 1
                },
                state: {
                    hover: {
                        lineWidth: 1,
                        fillOpacity: 0.6
                    }
                }
            };
            result.region = [
                {
                    clip: true
                }
            ];
            result.animation = true;
            return result;
        };
        const roseParallel = [
            initRoseParallel,
            stackCornerRadius_stackCornerRadius,
            colorAdapter(color_color, linearColor),
            background_backgroundColor,
            datasetXY,
            progressive,
            radiusAxis,
            colorRoseStyleFill(roseStyle),
            colorAdapter(discreteLegend, colorLegend),
            labelPie,
            tooltip_tooltip,
            verticalCrosshairRect,
            annotationPoint_annotationPoint,
            annotationVerticalLine_annotationVerticalLine,
            annotationHorizontalLine_annotationHorizontalLine,
            annotationAreaBand
        ];
        const pivotRoseParallel = [
            initPivot,
            pivotGridStyle,
            pivotIndicatorsAsRow,
            pivotHideIndicatorName,
            datasetPivot,
            pivotIndicators_pivotIndicators([
                initRoseParallel,
                addRegionPadding,
                stackCornerRadius_stackCornerRadius,
                colorAdapter(color_color, linearColor),
                background_backgroundColor,
                datasetXY,
                progressive,
                radiusAxis,
                verticalCrosshairRect,
                colorRoseStyleFill(roseStyle),
                labelPie,
                tooltip_tooltip,
                annotationPoint_annotationPoint,
                annotationVerticalLine_annotationVerticalLine,
                annotationHorizontalLine_annotationHorizontalLine,
                annotationAreaBand
            ]),
            pivotRowDimensions,
            pivotColumnDimensions,
            pivotTitle,
            colorAdapter(pivotDiscreteLegend, pivotColorLegend)
        ];
        const roseParallelSpecPipeline = [
            pivotAdapter_pivotAdapter(roseParallel, pivotRoseParallel)
        ];
        const registerRoseParallel = ()=>{
            Builder._advancedPipelineMap.roseParallel = roseParallelAdvancedPipeline;
            Builder._specPipelineMap.roseParallel = roseParallelSpecPipeline;
        };
        const defaultEncodingForRadar = (advancedVSeed)=>{
            const { measures: vseedMeasures = [], dimensions = [] } = advancedVSeed;
            const measures = findAllMeasures(vseedMeasures);
            const encoding = {};
            radar_generateDefaultDimensionEncoding(dimensions, encoding);
            radar_generateDefaultMeasureEncoding(measures, encoding);
            return {
                ...advancedVSeed,
                encoding
            };
        };
        const encodingForRadar = (advancedVSeed)=>{
            const { measures: vseedMeasures = [], dimensions = [] } = advancedVSeed;
            const measures = findAllMeasures(vseedMeasures);
            const hasDimensionEncoding = dimensions.some((item)=>item.encoding);
            const hasMeasureEncoding = measures.some((item)=>item.encoding);
            const encoding = {};
            if (hasDimensionEncoding) radar_generateDimensionEncoding(dimensions, encoding, measures.length > 1);
            else radar_generateDefaultDimensionEncoding(dimensions, encoding);
            if (hasMeasureEncoding) radar_generateMeasureEncoding(measures, encoding);
            else radar_generateDefaultMeasureEncoding(measures, encoding);
            return {
                ...advancedVSeed,
                encoding
            };
        };
        const radar_generateDefaultDimensionEncoding = (dimensions, encoding)=>{
            const uniqueDimIds = chunk_QJLMYOTX_i(dimensions.map((d)=>d.id));
            encoding.angle = uniqueDimIds.slice(0, 1);
            encoding.color = uniqueDimIds.slice(1);
            encoding.tooltip = uniqueDimIds.filter((d)=>d !== MeasureId);
            encoding.detail = [];
            encoding.label = [];
            encoding.row = [];
            encoding.column = [];
        };
        const radar_generateDimensionEncoding = (dimensions, encoding, isMultiMeasure)=>{
            encoding.angle = chunk_QJLMYOTX_i(dimensions.filter((item)=>'angle' === item.encoding).map((item)=>item.id));
            if (0 === encoding.angle.length) encoding.angle = [
                dimensions[0].id
            ];
            addColorToEncoding(dimensions, encoding, isMultiMeasure);
            encoding.detail = [];
            if (0 === encoding.detail.length) encoding.detail = [
                MeasureId
            ];
            encoding.tooltip = chunk_QJLMYOTX_i(dimensions.map((item)=>item.id));
            encoding.tooltip = encoding.tooltip.filter((d)=>d !== MeasureId);
            encoding.label = chunk_QJLMYOTX_i(dimensions.filter((item)=>'label' === item.encoding).map((item)=>item.id));
            encoding.label = encoding.label.filter((d)=>d !== MeasureId);
        };
        const radar_generateDefaultMeasureEncoding = (measures, encoding)=>{
            encoding.radius = chunk_QJLMYOTX_i(measures.filter((item)=>'radius' === item.encoding || !item.encoding).map((item)=>item.id));
        };
        const radar_generateMeasureEncoding = (measures, encoding)=>{
            encoding.radius = chunk_QJLMYOTX_i(measures.filter((item)=>'radius' === item.encoding || !item.encoding).map((item)=>item.id));
            const color = chunk_QJLMYOTX_i(measures.filter((item)=>'color' === item.encoding).map((item)=>item.id));
            if (color.length > 0) encoding.color = color;
            const label = chunk_QJLMYOTX_i(measures.filter((item)=>'label' === item.encoding).map((item)=>item.id));
            encoding.label = chunk_QJLMYOTX_i([
                ...encoding.label || [],
                ...label
            ]);
            const tooltip = chunk_QJLMYOTX_i(measures.filter((item)=>'tooltip' === item.encoding).map((item)=>item.id));
            encoding.tooltip = chunk_QJLMYOTX_i([
                ...encoding.tooltip || [],
                ...label,
                ...tooltip
            ]);
        };
        const radarAdvancedPipeline = [
            initAdvancedVSeed_initAdvancedVSeed,
            default_defaultMeasures_defaultMeasures,
            defaultDimensions_defaultDimensions,
            defaultMeasureId_defaultMeasureId,
            encodingAdapter([
                defaultEncodingForRadar,
                buildMeasures
            ], [
                encodingForRadar,
                buildMeasures,
                pickMeasuresForReshape([
                    'tooltip',
                    'label',
                    'color'
                ]),
                pickDimensionsForReshape
            ]),
            pivotAdapter([
                reshapeWithEncoding
            ], [
                pivotReshapeWithEncoding
            ]),
            sortLegend_sortLegend,
            radarConfig,
            theme_theme,
            markStyle_markStyle,
            annotation_annotation
        ];
        const initRadar = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed, vseed } = context;
            const { datasetReshapeInfo } = advancedVSeed;
            const { unfoldInfo, foldInfo } = datasetReshapeInfo[0];
            result.type = 'radar';
            result.angleField = unfoldInfo.encodingAngle;
            result.radiusField = foldInfo.measureValue;
            result.seriesField = isLinearColor(advancedVSeed, vseed) ? unfoldInfo.encodingDetail : unfoldInfo.encodingColorId;
            result.padding = 0;
            result.region = [
                {
                    clip: true
                }
            ];
            result.animation = true;
            return result;
        };
        const radarAngleAxis = (spec)=>{
            const result = {
                ...spec
            };
            if (!result.axes) result.axes = [];
            result.axes.push({
                orient: 'angle',
                visible: true,
                zero: true,
                nice: true,
                grid: {
                    visible: true
                },
                domainLine: {
                    visible: true
                },
                tick: {
                    visible: true
                }
            });
            return result;
        };
        const radarRadiusAxis = (spec)=>{
            const result = {
                ...spec
            };
            if (!result.axes) result.axes = [];
            result.axes.push({
                orient: 'radius',
                visible: true,
                zero: true,
                nice: true,
                grid: {
                    visible: true
                },
                tick: {
                    visible: true
                },
                label: {
                    visible: true
                },
                domainLine: {
                    visible: true
                }
            });
            return result;
        };
        const radar = [
            initRadar,
            colorAdapter(color_color, linearColor),
            background_backgroundColor,
            datasetXY,
            progressive,
            radarAngleAxis,
            radarRadiusAxis,
            label_label,
            tooltip_tooltip,
            colorAdapter(discreteLegend, colorLegend),
            verticalCrosshairLine,
            colorPointStyleFill(pointStyle_pointStyle),
            pointStateDimensionHover,
            colorLineStyleFill(lineStyle_lineStyle),
            colorAreaStyleFill(areaStyle_areaStyle)
        ];
        const pivotRadar = [
            initPivot,
            pivotGridStyle,
            pivotIndicatorsAsRow,
            pivotHideIndicatorName,
            datasetPivot,
            pivotIndicators_pivotIndicators([
                initRadar,
                addRegionPadding,
                colorAdapter(color_color, linearColor),
                background_backgroundColor,
                datasetXY,
                progressive,
                radarAngleAxis,
                radarRadiusAxis,
                label_label,
                tooltip_tooltip,
                verticalCrosshairLine,
                colorPointStyleFill(pointStyle_pointStyle),
                pointStateDimensionHover,
                colorLineStyleFill(lineStyle_lineStyle),
                colorAreaStyleFill(areaStyle_areaStyle)
            ]),
            pivotRowDimensions,
            pivotColumnDimensions,
            pivotTitle,
            colorAdapter(pivotDiscreteLegend, pivotColorLegend)
        ];
        const radarSpecPipeline = [
            pivotAdapter_pivotAdapter(radar, pivotRadar)
        ];
        const registerRadar = ()=>{
            Builder._advancedPipelineMap.radar = radarAdvancedPipeline;
            Builder._specPipelineMap.radar = radarSpecPipeline;
        };
        const defaultEncodingForFunnel = (advancedVSeed)=>{
            const { measures: vseedMeasures = [], dimensions = [] } = advancedVSeed;
            const measures = findAllMeasures(vseedMeasures);
            const encoding = {};
            funnel_generateDefaultDimensionEncoding(dimensions, encoding);
            funnel_generateDefaultMeasureEncoding(measures, encoding);
            return {
                ...advancedVSeed,
                encoding
            };
        };
        const encodingForFunnel = (advancedVSeed)=>{
            const { measures: vseedMeasures = [], dimensions = [] } = advancedVSeed;
            const measures = findAllMeasures(vseedMeasures);
            const hasDimensionEncoding = dimensions.some((item)=>item.encoding);
            const hasMeasureEncoding = measures.some((item)=>item.encoding);
            const encoding = {};
            if (hasDimensionEncoding) funnel_generateDimensionEncoding(dimensions, encoding, measures.length > 1);
            else funnel_generateDefaultDimensionEncoding(dimensions, encoding);
            if (hasMeasureEncoding) funnel_generateMeasureEncoding(measures, encoding);
            else funnel_generateDefaultMeasureEncoding(measures, encoding);
            return {
                ...advancedVSeed,
                encoding
            };
        };
        const funnel_generateDefaultDimensionEncoding = (dimensions, encoding)=>{
            const uniqueDimIds = chunk_QJLMYOTX_i(dimensions.map((d)=>d.id));
            encoding.color = uniqueDimIds.slice(0);
            encoding.detail = encoding.color;
            encoding.tooltip = uniqueDimIds.filter((d)=>d !== MeasureId);
            encoding.label = [];
            encoding.row = [];
            encoding.column = [];
        };
        const funnel_generateDimensionEncoding = (dimensions, encoding, isMultiMeasure)=>{
            addColorToEncoding(dimensions, encoding, isMultiMeasure);
            encoding.detail = chunk_QJLMYOTX_i(dimensions.filter((item)=>'detail' === item.encoding).map((item)=>item.id));
            if (0 === encoding.detail.length) encoding.detail = [
                MeasureId
            ];
            encoding.tooltip = chunk_QJLMYOTX_i(dimensions.map((item)=>item.id));
            encoding.tooltip = encoding.tooltip.filter((d)=>d !== MeasureId);
            encoding.label = chunk_QJLMYOTX_i(dimensions.filter((item)=>'label' === item.encoding).map((item)=>item.id));
            encoding.label = encoding.label.filter((d)=>d !== MeasureId);
        };
        const funnel_generateDefaultMeasureEncoding = (measures, encoding)=>{
            encoding.size = chunk_QJLMYOTX_i(measures.filter((item)=>'size' === item.encoding || !item.encoding).map((item)=>item.id));
        };
        const funnel_generateMeasureEncoding = (measures, encoding)=>{
            encoding.size = chunk_QJLMYOTX_i(measures.filter((item)=>'size' === item.encoding || !item.encoding).map((item)=>item.id));
            const color = chunk_QJLMYOTX_i(measures.filter((item)=>'color' === item.encoding).map((item)=>item.id));
            if (color.length > 0) encoding.color = [
                color[0]
            ];
            const label = chunk_QJLMYOTX_i(measures.filter((item)=>'label' === item.encoding).map((item)=>item.id));
            encoding.label = chunk_QJLMYOTX_i([
                ...encoding.label || [],
                ...label
            ]);
            const tooltip = chunk_QJLMYOTX_i(measures.filter((item)=>'tooltip' === item.encoding).map((item)=>item.id));
            encoding.tooltip = chunk_QJLMYOTX_i([
                ...encoding.tooltip || [],
                ...label,
                ...tooltip
            ]);
        };
        const funnelAdvancedPipeline = [
            initAdvancedVSeed_initAdvancedVSeed,
            default_defaultMeasures_defaultMeasures,
            defaultDimensions_defaultDimensions,
            defaultMeasureId_defaultMeasureId,
            encodingAdapter([
                defaultEncodingForFunnel,
                buildMeasures
            ], [
                encodingForFunnel,
                buildMeasures,
                pickMeasuresForReshape([
                    'tooltip',
                    'label',
                    'color'
                ]),
                pickDimensionsForReshape
            ]),
            pivotAdapter([
                reshapeWithEncoding
            ], [
                pivotReshapeWithEncoding
            ]),
            funnelConfig,
            theme_theme,
            annotation_annotation
        ];
        const initFunnel = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed } = context;
            const { datasetReshapeInfo } = advancedVSeed;
            const { foldInfo, unfoldInfo } = datasetReshapeInfo[0];
            result.type = 'funnel';
            result.valueField = foldInfo.measureValue;
            result.categoryField = unfoldInfo.encodingColorId;
            result.padding = 0;
            result.isTransform = true;
            result.shape = 'rect';
            result.maxSize = '75%';
            result.minSize = '10%';
            result.region = [
                {
                    clip: true
                }
            ];
            result.animation = true;
            return result;
        };
        const colorFunnelStyleFill = (stylePipe)=>(spec, context)=>{
                const result = stylePipe(spec, context);
                const { advancedVSeed, vseed } = context;
                const { datasetReshapeInfo } = advancedVSeed;
                const { unfoldInfo } = datasetReshapeInfo[0];
                if (isLinearColor(advancedVSeed, vseed)) {
                    if (result?.funnel?.style) result.funnel.style.fill = {
                        field: unfoldInfo.encodingColor,
                        scale: 'color'
                    };
                }
                return result;
            };
        const funnelStyle = (spec)=>{
            const result = {
                ...spec,
                funnel: {
                    style: {}
                }
            };
            return {
                ...result,
                funnel: {
                    style: {
                        cornerRadius: 0
                    },
                    state: {
                        hover: {
                            fillOpacity: 0.6
                        }
                    }
                }
            };
        };
        const funnelTransformStyle = (spec, context)=>{
            const { advancedVSeed, vseed } = context;
            const { chartType } = vseed;
            const config = advancedVSeed.config?.[chartType]?.transform;
            return {
                ...spec,
                transform: {
                    style: {
                        fill: config?.backgroundColor
                    }
                },
                transformLabel: {
                    visible: true,
                    style: {
                        fill: config?.textColor
                    }
                }
            };
        };
        const funnel = [
            initFunnel,
            background_backgroundColor,
            datasetXY,
            colorAdapter(color_color, linearColor),
            label_label,
            colorAdapter(discreteLegend, colorLegend),
            colorFunnelStyleFill(funnelStyle),
            funnelTransformStyle,
            tooltip_tooltip,
            annotationPoint_annotationPoint,
            annotationVerticalLine_annotationVerticalLine,
            annotationHorizontalLine_annotationHorizontalLine,
            annotationArea_annotationArea
        ];
        const pivotFunnel = [
            initPivot,
            pivotGridStyle,
            pivotIndicatorsAsRow,
            pivotHideIndicatorName,
            datasetPivot,
            pivotIndicators_pivotIndicators([
                initFunnel,
                background_backgroundColor,
                datasetXY,
                colorAdapter(color_color, linearColor),
                label_label,
                tooltip_tooltip,
                colorFunnelStyleFill(funnelStyle),
                funnelTransformStyle,
                annotationPoint_annotationPoint,
                annotationVerticalLine_annotationVerticalLine,
                annotationHorizontalLine_annotationHorizontalLine,
                annotationArea_annotationArea
            ]),
            pivotRowDimensions,
            pivotColumnDimensions,
            pivotTitle,
            colorAdapter(pivotDiscreteLegend, pivotColorLegend)
        ];
        const funnelSpecPipeline = [
            pivotAdapter_pivotAdapter(funnel, pivotFunnel)
        ];
        const registerFunnel = ()=>{
            Builder._advancedPipelineMap.funnel = funnelAdvancedPipeline;
            Builder._specPipelineMap.funnel = funnelSpecPipeline;
        };
        const defaultEncodingForHeatmap = (advancedVSeed)=>{
            const { measures: vseedMeasures = [], dimensions = [] } = advancedVSeed;
            const measures = findAllMeasures(vseedMeasures);
            const encoding = {};
            heatmap_generateDefaultDimensionEncoding(dimensions, encoding);
            heatmap_generateDefaultMeasureEncoding(measures, encoding);
            return {
                ...advancedVSeed,
                encoding
            };
        };
        const encodingForHeatmap = (advancedVSeed)=>{
            const { measures: vseedMeasures = [], dimensions = [] } = advancedVSeed;
            const measures = findAllMeasures(vseedMeasures);
            const hasDimensionEncoding = dimensions.some((item)=>item.encoding);
            const hasMeasureEncoding = measures.some((item)=>item.encoding);
            const encoding = {};
            if (hasDimensionEncoding) heatmap_generateDimensionEncoding(dimensions, encoding, measures.length > 1);
            else heatmap_generateDefaultDimensionEncoding(dimensions, encoding);
            if (hasMeasureEncoding) heatmap_generateMeasureEncoding(measures, encoding);
            else heatmap_generateDefaultMeasureEncoding(measures, encoding);
            return {
                ...advancedVSeed,
                encoding
            };
        };
        const heatmap_generateDefaultDimensionEncoding = (dimensions, encoding)=>{
            const onlyMeasureId = 1 === dimensions.length && dimensions.find((item)=>item.id === MeasureId);
            const uniqueDimIds = chunk_QJLMYOTX_i(dimensions.map((d)=>d.id));
            encoding.x = uniqueDimIds.slice(0, 1);
            encoding.y = uniqueDimIds.slice(onlyMeasureId ? 0 : 1);
            encoding.color = uniqueDimIds.slice(onlyMeasureId ? 0 : 1);
            encoding.detail = encoding.color;
            encoding.tooltip = uniqueDimIds.filter((d)=>d !== MeasureId);
            encoding.label = [];
            encoding.row = [];
            encoding.column = [];
        };
        const heatmap_generateDimensionEncoding = (dimensions, encoding, isMultiMeasure)=>{
            encoding.x = chunk_QJLMYOTX_i(dimensions.filter((item)=>'xAxis' === item.encoding).map((item)=>item.id));
            if (0 === encoding.x.length) encoding.x = [
                dimensions[0].id
            ];
            encoding.y = chunk_QJLMYOTX_i(dimensions.filter((item)=>'yAxis' === item.encoding).map((item)=>item.id));
            if (0 === encoding.y.length) if (dimensions.length > 1) encoding.y = dimensions.slice(1).map((item)=>item.id);
            else encoding.y = dimensions.slice(0).map((item)=>item.id);
            addColorToEncoding(dimensions, encoding, isMultiMeasure);
            encoding.detail = chunk_QJLMYOTX_i(dimensions.filter((item)=>'detail' === item.encoding).map((item)=>item.id));
            if (0 === encoding.detail.length) encoding.detail = encoding.color;
            encoding.tooltip = chunk_QJLMYOTX_i(dimensions.map((item)=>item.id));
            encoding.tooltip = encoding.tooltip.filter((d)=>d !== MeasureId);
            encoding.label = chunk_QJLMYOTX_i(dimensions.filter((item)=>'label' === item.encoding).map((item)=>item.id));
            encoding.label = encoding.label.filter((d)=>d !== MeasureId);
        };
        const heatmap_generateDefaultMeasureEncoding = (measures, encoding)=>{
            const colorDims = chunk_QJLMYOTX_i(measures.filter((item)=>'color' === item.encoding || !item.encoding).map((item)=>item.id));
            if (colorDims.length > 0) encoding.color = [
                colorDims[0]
            ];
        };
        const heatmap_generateMeasureEncoding = (measures, encoding)=>{
            const color = chunk_QJLMYOTX_i(measures.filter((item)=>'color' === item.encoding).map((item)=>item.id));
            if (color.length > 0) encoding.color = [
                color[0]
            ];
            const label = chunk_QJLMYOTX_i(measures.filter((item)=>'label' === item.encoding).map((item)=>item.id));
            encoding.label = chunk_QJLMYOTX_i([
                ...encoding.label || [],
                ...label
            ]);
            const tooltip = chunk_QJLMYOTX_i(measures.filter((item)=>'tooltip' === item.encoding).map((item)=>item.id));
            encoding.tooltip = chunk_QJLMYOTX_i([
                ...encoding.tooltip || [],
                ...label,
                ...tooltip
            ]);
        };
        const heatmapAdvancedPipeline = [
            initAdvancedVSeed_initAdvancedVSeed,
            default_defaultMeasures_defaultMeasures,
            defaultDimensions_defaultDimensions,
            defaultMeasureId_defaultMeasureId,
            encodingAdapter([
                defaultEncodingForHeatmap,
                buildMeasures
            ], [
                encodingForHeatmap,
                buildMeasures,
                pickMeasuresForReshape([
                    'tooltip',
                    'label'
                ]),
                pickDimensionsForReshape
            ]),
            pivotAdapter([
                reshapeWithEncoding
            ], [
                pivotReshapeWithEncoding
            ]),
            sortXBandAxis,
            heatmapConfig,
            theme_theme,
            markStyle_markStyle,
            annotation_annotation
        ];
        const heatmapColorLegend = (spec, context)=>{
            const result = colorLegend(spec, context);
            if (result.legends) result.legends.customFilter = (data, range, key)=>{
                const min = Math.min(range[0], range[1]);
                const max = Math.max(range[0], range[1]);
                return (data ?? []).map((entry)=>{
                    const val = entry[key];
                    const isHide = val - min < -0.000001 || val - max > 1e-6;
                    entry[DATUM_HIDE_KEY] = isHide;
                    return entry;
                });
            };
            return result;
        };
        const colorCellStyleFill = (stylePipe)=>(spec, context)=>{
                const result = stylePipe(spec, context);
                const { advancedVSeed, vseed } = context;
                const { datasetReshapeInfo } = advancedVSeed;
                const { unfoldInfo } = datasetReshapeInfo[0];
                if (isLinearColor(advancedVSeed, vseed)) {
                    if (result?.cell?.style) result.cell.style.fill = {
                        field: unfoldInfo.encodingColor,
                        scale: 'color'
                    };
                }
                return result;
            };
        const markStyle_cellStyle_cellStyle = (spec, context)=>{
            const result = {
                ...spec,
                cell: {
                    style: {}
                }
            };
            const { advancedVSeed, vseed } = context;
            const { chartType } = vseed;
            const cell = advancedVSeed.config?.[chartType]?.cell;
            return {
                ...result,
                cell: {
                    style: {
                        visible: (datum)=>datum?.[DATUM_HIDE_KEY] !== true,
                        shape: 'rect',
                        stroke: cell?.stroke,
                        lineWidth: cell?.lineWidth ?? 1
                    }
                }
            };
        };
        const tooltipHeatmap = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed, vseed } = context;
            const { datasetReshapeInfo, chartType, locale, dimensions, encoding } = advancedVSeed;
            const baseConfig = advancedVSeed.config[chartType];
            const { tooltip = {
                enable: true
            } } = baseConfig;
            const { enable } = tooltip;
            const { foldInfo } = datasetReshapeInfo[0];
            result.tooltip = {
                style: getTooltipStyle(tooltip),
                visible: enable,
                mark: {
                    title: {
                        visible: false
                    },
                    content: tooltipHeatmap_createMarkContent(encoding.tooltip || [], dimensions, findAllMeasures(vseed.measures), locale, foldInfo)
                },
                dimension: {
                    visible: false
                }
            };
            return result;
        };
        const tooltipHeatmap_createMarkContent = (tooltip, dimensions, measures, locale, foldInfo)=>{
            const dims = T(dimensions.filter((item)=>tooltip.includes(item.id)), (item)=>item.id);
            const meas = T(measures.filter((item)=>tooltip.includes(item.id)), (item)=>item.id);
            const dimContent = dims.map((item)=>({
                    visible: true,
                    hasShape: true,
                    shapeType: 'rectRound',
                    key: (v)=>{
                        const datum = v;
                        if (item.alias || item.id) return item.alias || item.id;
                        return datum && datum[item.id];
                    },
                    value: (v)=>{
                        const datum = v;
                        return datum && datum[item.id];
                    }
                }));
            const meaContent = meas.map((item)=>({
                    visible: true,
                    hasShape: true,
                    shapeType: 'rectRound',
                    key: item.alias || item.id,
                    value: (v)=>{
                        const datum = v;
                        if (!datum) return '';
                        const id = item.id;
                        if (!datum || !datum[ORIGINAL_DATA] || !datum[ORIGINAL_DATA]) return '';
                        const originalData = datum[ORIGINAL_DATA];
                        const value = originalData[id];
                        const measure = findMeasureById(measures, id);
                        const formatter = createFormatterByMeasure(measure);
                        return formatter(value);
                    }
                }));
            const foldMeaContent = [
                foldInfo
            ].map((foldInfo)=>({
                    visible: true,
                    hasShape: true,
                    shapeType: 'rectRound',
                    key: (v)=>{
                        const { measureId, foldMap } = foldInfo;
                        const datum = v;
                        const id = datum[measureId];
                        return foldMap[id] || id;
                    },
                    value: (v)=>{
                        const { measureId, measureValue } = foldInfo;
                        const datum = v;
                        if (!datum) return '';
                        const value = datum[measureValue];
                        const id = datum[measureId];
                        const measure = findMeasureById(measures, id);
                        const formatter = createFormatterByMeasure(measure);
                        return formatter(value);
                    }
                }));
            return [
                ...dimContent,
                ...foldMeaContent,
                ...meaContent
            ];
        };
        const initHeatmap = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed } = context;
            const { datasetReshapeInfo } = advancedVSeed;
            const { unfoldInfo, foldInfo } = datasetReshapeInfo[0];
            result.type = 'heatmap';
            result.direction = 'vertical';
            result.xField = unfoldInfo.encodingX;
            result.yField = unfoldInfo.encodingY;
            result.seriesField = unfoldInfo.encodingColorId;
            result.valueField = foldInfo.measureValue;
            result.padding = 0;
            result.axes = [
                {
                    type: 'band',
                    orient: 'left',
                    bandPadding: 0
                },
                {
                    type: 'band',
                    orient: 'bottom',
                    bandPadding: 0
                }
            ];
            result.region = [
                {
                    clip: true
                }
            ];
            result.animation = true;
            return result;
        };
        const heatmap = [
            initHeatmap,
            background_backgroundColor,
            datasetXY,
            colorAdapter(color_color, linearColor),
            label_label,
            colorAdapter(discreteLegend, heatmapColorLegend),
            colorCellStyleFill(markStyle_cellStyle_cellStyle),
            tooltipHeatmap,
            annotationPoint_annotationPoint,
            annotationVerticalLine_annotationVerticalLine,
            annotationHorizontalLine_annotationHorizontalLine,
            annotationArea_annotationArea
        ];
        const pivotHeatmap = [
            initPivot,
            pivotGridStyle,
            pivotIndicatorsAsRow,
            datasetPivot,
            pivotIndicators_pivotIndicators([
                pivotAxisStyle(initHeatmap),
                background_backgroundColor,
                datasetXY,
                colorAdapter(color_color, linearColor),
                label_label,
                tooltipHeatmap,
                colorCellStyleFill(markStyle_cellStyle_cellStyle),
                annotationPoint_annotationPoint,
                annotationVerticalLine_annotationVerticalLine,
                annotationHorizontalLine_annotationHorizontalLine,
                annotationArea_annotationArea
            ]),
            pivotRowDimensions,
            pivotColumnDimensions,
            pivotTitle,
            colorAdapter(pivotDiscreteLegend, pivotColorLegend)
        ];
        const heatmapSpecPipeline = [
            pivotAdapter_pivotAdapter(heatmap, pivotHeatmap)
        ];
        const registerHeatmap = ()=>{
            Builder._advancedPipelineMap.heatmap = heatmapAdvancedPipeline;
            Builder._specPipelineMap.heatmap = heatmapSpecPipeline;
        };
        const boxplotConfig = (advancedVSeed, context)=>{
            const { vseed } = context;
            const { chartType } = vseed;
            const result = {
                ...advancedVSeed
            };
            const pickedConfig = chunk_2T7K3PFL_i(vseed, [
                'backgroundColor',
                'color',
                'label',
                'legend',
                'tooltip',
                'xAxis',
                'yAxis',
                'crosshairRect',
                'whiskers',
                'boxMaxWidth',
                'boxGapInGroup',
                'dimensionLinkage'
            ]);
            const config = replaceNullToUndefined(pickedConfig);
            result.config = {
                ...result.config || {},
                [chartType]: {
                    ...config
                }
            };
            return result;
        };
        const defaultEncodingForBoxplot = (advancedVSeed)=>{
            const { measures: vseedMeasures = [], dimensions = [] } = advancedVSeed;
            const measures = findAllMeasures(vseedMeasures);
            const encoding = {};
            boxplot_generateDefaultDimensionEncoding(dimensions, encoding);
            boxplot_generateDefaultMeasureEncoding(measures, encoding);
            return {
                ...advancedVSeed,
                encoding
            };
        };
        const encodingForBoxplot = (advancedVSeed)=>{
            const { measures: vseedMeasures = [], dimensions = [] } = advancedVSeed;
            const measures = findAllMeasures(vseedMeasures);
            const hasDimensionEncoding = dimensions.some((item)=>item.encoding);
            const hasMeasureEncoding = measures.some((item)=>item.encoding);
            const encoding = {};
            if (hasDimensionEncoding) boxplot_generateDimensionEncoding(dimensions, encoding, measures.length > 1);
            else boxplot_generateDefaultDimensionEncoding(dimensions, encoding);
            if (hasMeasureEncoding) boxplot_generateMeasureEncoding(measures, encoding);
            else boxplot_generateDefaultMeasureEncoding(measures, encoding);
            if ((!encoding.value || encoding.value.length <= 1) && encoding.color && encoding.color.length > 1) encoding.color = encoding.color.filter((c)=>c !== MeasureId);
            return {
                ...advancedVSeed,
                encoding
            };
        };
        const boxplot_generateDefaultDimensionEncoding = (dimensions, encoding)=>{
            const onlyMeasureId = 1 === dimensions.length && dimensions.find((item)=>item.id === MeasureId);
            const uniqueDimIds = chunk_QJLMYOTX_i(dimensions.map((d)=>d.id));
            encoding.x = uniqueDimIds.slice(0, 1);
            encoding.color = uniqueDimIds.slice(onlyMeasureId ? 0 : 1);
            encoding.tooltip = uniqueDimIds.filter((d)=>d !== MeasureId);
            encoding.label = [];
            encoding.row = [];
            encoding.column = [];
        };
        const boxplot_generateDimensionEncoding = (dimensions, encoding, isMultiMeasure)=>{
            encoding.x = chunk_QJLMYOTX_i(dimensions.filter((item)=>'xAxis' === item.encoding).map((item)=>item.id));
            if (0 === encoding.x.length) encoding.x = [
                dimensions[0].id
            ];
            addColorToEncoding(dimensions, encoding, isMultiMeasure);
            encoding.tooltip = chunk_QJLMYOTX_i(dimensions.map((item)=>item.id));
            encoding.tooltip = encoding.tooltip.filter((d)=>d !== MeasureId);
            encoding.label = chunk_QJLMYOTX_i(dimensions.filter((item)=>'label' === item.encoding).map((item)=>item.id));
            encoding.label = encoding.label.filter((d)=>d !== MeasureId);
        };
        const boxplot_generateDefaultMeasureEncoding = (measures, encoding)=>{
            encoding.value = chunk_QJLMYOTX_i(measures.filter((item)=>'value' === item.encoding || !item.encoding).map((item)=>item.id));
        };
        const boxplot_generateMeasureEncoding = (measures, encoding)=>{
            encoding.value = chunk_QJLMYOTX_i(measures.filter((item)=>'value' === item.encoding || !item.encoding).map((item)=>item.id));
            encoding.q1 = chunk_QJLMYOTX_i(measures.filter((item)=>'q1' === item.encoding).map((item)=>item.id));
            encoding.median = chunk_QJLMYOTX_i(measures.filter((item)=>'median' === item.encoding).map((item)=>item.id));
            encoding.q3 = chunk_QJLMYOTX_i(measures.filter((item)=>'q3' === item.encoding).map((item)=>item.id));
            encoding.min = chunk_QJLMYOTX_i(measures.filter((item)=>'min' === item.encoding).map((item)=>item.id));
            encoding.max = chunk_QJLMYOTX_i(measures.filter((item)=>'max' === item.encoding).map((item)=>item.id));
            encoding.outliers = chunk_QJLMYOTX_i(measures.filter((item)=>'outliers' === item.encoding).map((item)=>item.id));
            const color = chunk_QJLMYOTX_i(measures.filter((item)=>'color' === item.encoding).map((item)=>item.id));
            if (color.length > 0) encoding.color = color;
            const label = chunk_QJLMYOTX_i(measures.filter((item)=>'label' === item.encoding).map((item)=>item.id));
            encoding.label = chunk_QJLMYOTX_i([
                ...encoding.label || [],
                ...label
            ]);
            const tooltip = chunk_QJLMYOTX_i(measures.filter((item)=>'tooltip' === item.encoding).map((item)=>item.id));
            encoding.tooltip = chunk_QJLMYOTX_i([
                ...encoding.tooltip || [],
                ...label,
                ...tooltip
            ]);
        };
        function toNumber(a) {
            return Number(a);
        }
        function quantileSorted(values, percent, valueof = toNumber) {
            const n = values.length;
            if (!n) return;
            if (percent <= 0 || n < 2) return valueof(values[0], 0, values);
            if (percent >= 1) return valueof(values[n - 1], n - 1, values);
            const i = (n - 1) * percent, i0 = Math.floor(i), value0 = valueof(values[i0], i0, values);
            return value0 + (valueof(values[i0 + 1], i0 + 1, values) - value0) * (i - i0);
        }
        const boxplot = (data, options)=>{
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
            const field = null == options ? void 0 : options.field;
            if (!field) return [];
            const groupField = null == options ? void 0 : options.groupField;
            let whiskers = null != (_a = null == options ? void 0 : options.whiskers) ? _a : 1.5;
            const includeValues = !!(null == options ? void 0 : options.includeValues), names = null != (_b = null == options ? void 0 : options.outputNames) ? _b : {}, keyName = null != (_c = names.key) ? _c : common_isArray(groupField) ? null : null != (_d = groupField) ? _d : "key", countName = null != (_e = names.count) ? _e : "count", meanName = null != (_f = names.mean) ? _f : "mean", q1Name = null != (_g = names.q1) ? _g : "q1", medianName = null != (_h = names.median) ? _h : "median", q3Name = null != (_j = names.q3) ? _j : "q3", iqrName = null != (_k = names.iqr) ? _k : "iqr", minName = null != (_l = names.min) ? _l : "min", maxName = null != (_m = names.max) ? _m : "max", lowerWhiskerName = null != (_o = names.lowerWhisker) ? _o : "lowerWhisker", upperWhiskerName = null != (_p = names.upperWhisker) ? _p : "upperWhisker", outliersName = null != (_q = names.outliers) ? _q : "outliers", valuesName = null != (_r = names.values) ? _r : "values", groups = new Map, rawValues = new Map, keyToGroup = new Map, n = data.length;
            for(let i = 0; i < n; i++){
                const d = data[i], v = d[field];
                if (common_isNil(v)) continue;
                const num = +v;
                if (!Number.isFinite(num)) continue;
                let key;
                key = common_isArray(groupField) ? groupField.map((f)=>String(d[f])).join("||") : groupField ? String(d[groupField]) : "___all", groups.has(key) || (groups.set(key, []), includeValues && rawValues.set(key, []), common_isArray(groupField) ? keyToGroup.set(key, Object.fromEntries(groupField.map((f)=>[
                        f,
                        d[f]
                    ]))) : keyToGroup.set(key, groupField ? d[groupField] : null));
                const arr = groups.get(key);
                if (arr && arr.push(num), includeValues) {
                    const rv = rawValues.get(key);
                    rv && rv.push(d);
                }
            }
            if (common_isArray(whiskers)) whiskers = [
                common_clamp(Math.min.apply(null, whiskers), 0, 1),
                common_clamp(Math.max.apply(null, whiskers), 0, 1)
            ];
            const out = [];
            for (const [key, vals] of groups){
                if (!vals || 0 === vals.length) continue;
                const sorted = vals.slice().sort((a, b)=>a - b), count = sorted.length, dataMin = sorted[0], dataMax = sorted[sorted.length - 1];
                let sum = 0;
                for(let i = 0; i < sorted.length; i++)sum += sorted[i];
                const mean = sum / count, q1 = quantileSorted(sorted, .25), median = quantileSorted(sorted, .5), q3 = quantileSorted(sorted, .75), iqr = q3 - q1, lowerBound = common_isArray(whiskers) ? quantileSorted(sorted, whiskers[0]) : q1 - whiskers * iqr, upperBound = common_isArray(whiskers) ? quantileSorted(sorted, whiskers[1]) : q3 + whiskers * iqr, outliers = [];
                for(let i = 0; i < sorted.length; i++)(sorted[i] < lowerBound || sorted[i] > upperBound) && outliers.push(sorted[i]);
                const obj = {}, representative = keyToGroup.get(key);
                if (null !== keyName) obj[keyName] = representative;
                else if (common_isArray(groupField)) {
                    const groupObj = representative || {};
                    for (const f of groupField)obj[f] = groupObj[f];
                }
                obj[countName] = count, obj[meanName] = mean, obj[q1Name] = q1, obj[medianName] = median, obj[q3Name] = q3, obj[iqrName] = iqr, obj[minName] = dataMin, obj[maxName] = dataMax, obj[lowerWhiskerName] = lowerBound, obj[upperWhiskerName] = upperBound, obj[outliersName] = outliers, includeValues && (obj[valuesName] = rawValues.get(key) || []), out.push(obj);
            }
            return out;
        };
        const reshapeWithBoxplotEncoding = (advancedVSeed, context)=>{
            const result = {
                ...advancedVSeed
            };
            const { vseed } = context;
            const { dataset, chartType } = vseed;
            const { encoding = {}, config } = advancedVSeed;
            const measures = advancedVSeed.reshapeMeasures ?? advancedVSeed.measures ?? [];
            const dimensions = advancedVSeed.reshapeDimensions ?? advancedVSeed.dimensions ?? [];
            const uniqDims = T(dimensions, (item)=>item.id);
            const whiskers = config?.[chartType]?.whiskers;
            let newDatasets = [];
            let foldInfo = {};
            let unfoldInfo = {};
            const allMeasures = findAllMeasures(measures);
            if (encoding.value?.length) {
                const boxPlotDataList = [];
                encoding.value.forEach((f)=>{
                    const m = allMeasures.find((m)=>m.id === f);
                    const boxPlotData = boxplot(dataset, {
                        field: f,
                        groupField: [
                            ...encoding.x ?? [],
                            ...encoding.color ?? []
                        ],
                        whiskers,
                        outputNames: {
                            q1: "__Q1__",
                            q3: "__Q3__",
                            lowerWhisker: LowerWhisker,
                            upperWhisker: UpperWhisker,
                            median: MedianMeasureId,
                            outliers: OutliersMeasureId
                        }
                    });
                    boxPlotData.forEach((datum)=>{
                        datum[FoldMeasureId] = f;
                        datum[FoldMeasureName] = m?.alias ?? f;
                    });
                    boxPlotDataList.push(...boxPlotData);
                });
                const res = unfoldDimensions(boxPlotDataList, uniqDims, encoding, {
                    foldMeasureId: FoldMeasureId,
                    separator: "-",
                    colorItemAsId: false
                });
                res.dataset.forEach((d)=>{
                    newDatasets.push(d);
                });
                unfoldInfo = res.unfoldInfo;
            } else if (encoding.q1?.length && encoding.q3?.length && encoding.min?.length && encoding.max?.length && encoding.median?.length) {
                const res = unfoldDimensions(dataset, uniqDims, encoding, {
                    foldMeasureId: FoldMeasureId,
                    separator: "-",
                    colorItemAsId: false
                });
                res.dataset.forEach((datum)=>{
                    datum[UpperWhisker] = datum[encoding.max[0]];
                    datum[LowerWhisker] = datum[encoding.min[0]];
                    datum["__Q1__"] = datum[encoding.q1[0]];
                    datum["__Q3__"] = datum[encoding.q3[0]];
                    datum[MedianMeasureId] = datum[encoding.median[0]];
                });
                newDatasets = res.dataset;
                foldInfo = {};
                unfoldInfo = res.unfoldInfo;
            }
            return {
                ...result,
                dataset: newDatasets,
                datasetReshapeInfo: [
                    {
                        id: String(chartType),
                        index: 0,
                        foldInfo,
                        unfoldInfo
                    }
                ],
                dimensions,
                measures
            };
        };
        const pivotReshapeWithBoxplotEncoding = (advancedVSeed, context)=>{
            const result = {
                ...advancedVSeed
            };
            const { vseed } = context;
            const { dataset, chartType } = vseed;
            const { encoding = {}, config } = advancedVSeed;
            const measures = advancedVSeed.reshapeMeasures ?? advancedVSeed.measures ?? [];
            const dimensions = advancedVSeed.reshapeDimensions ?? advancedVSeed.dimensions ?? [];
            const uniqDims = T(dimensions, (item)=>item.id);
            const chartConfig = config?.[chartType];
            const whiskers = chartConfig?.whiskers;
            const measureGroups = [];
            if (measures) measures.forEach((measure)=>{
                if (measure.children && measure.children.length > 0) measureGroups.push(measure);
            });
            const rowColumnFields = T(dimensions.filter((dim)=>'row' === dim.encoding || 'column' === dim.encoding), (item)=>item.id);
            const datasets = [];
            const datasetReshapeInfo = [];
            measureGroups.forEach((measureGroup, index)=>{
                const subMeasures = measureGroup.children;
                if (!subMeasures) return;
                const groupId = measureGroup.id;
                let newDatasets = [];
                let foldInfo = {};
                let unfoldInfo = {};
                const validEncodingIds = (encoding.value || []).filter((id)=>subMeasures.find((field)=>field.id === id));
                if (validEncodingIds.length) {
                    const boxPlotDataList = [];
                    validEncodingIds.forEach((f)=>{
                        const m = subMeasures.find((m)=>m.id === f);
                        const boxPlotData = boxplot(dataset, {
                            field: f,
                            groupField: [
                                ...encoding.x ?? [],
                                ...encoding.color ?? [],
                                ...rowColumnFields.map((item)=>item.id)
                            ],
                            whiskers,
                            outputNames: {
                                q1: "__Q1__",
                                q3: "__Q3__",
                                lowerWhisker: LowerWhisker,
                                upperWhisker: UpperWhisker,
                                median: MedianMeasureId,
                                outliers: OutliersMeasureId
                            }
                        });
                        boxPlotData.forEach((datum)=>{
                            datum[FoldMeasureId] = f;
                            datum[FoldMeasureName] = m?.alias ?? f;
                        });
                        boxPlotDataList.push(...boxPlotData);
                    });
                    const res = unfoldDimensions(boxPlotDataList, uniqDims, encoding, {
                        foldMeasureId: FoldMeasureId,
                        separator: "-",
                        colorItemAsId: false
                    });
                    res.dataset.forEach((d)=>{
                        newDatasets.push(d);
                    });
                    unfoldInfo = res.unfoldInfo;
                } else if (encoding.q1?.length && encoding.q3?.length && encoding.min?.length && encoding.max?.length && encoding.median?.length) {
                    const res = unfoldDimensions(dataset, uniqDims, encoding, {
                        foldMeasureId: FoldMeasureId,
                        separator: "-",
                        colorItemAsId: false
                    });
                    res.dataset.forEach((datum)=>{
                        datum[UpperWhisker] = datum[encoding.max[0]];
                        datum[LowerWhisker] = datum[encoding.min[0]];
                        datum["__Q1__"] = datum[encoding.q1[0]];
                        datum["__Q3__"] = datum[encoding.q3[0]];
                        datum[MedianMeasureId] = datum[encoding.median[0]];
                    });
                    newDatasets = res.dataset;
                    foldInfo = {};
                    unfoldInfo = res.unfoldInfo;
                }
                const reshapeInfo = {
                    id: `${groupId}`,
                    index,
                    foldInfo,
                    unfoldInfo
                };
                datasets.push(newDatasets);
                datasetReshapeInfo.push(reshapeInfo);
            });
            return {
                ...result,
                dataset: datasets,
                datasetReshapeInfo: datasetReshapeInfo
            };
        };
        const boxplotAdvancedPipeline = [
            initAdvancedVSeed_initAdvancedVSeed,
            default_defaultMeasures_defaultMeasures,
            defaultDimensions_defaultDimensions,
            defaultMeasureId_defaultMeasureId,
            boxplotConfig,
            encodingAdapter([
                defaultEncodingForBoxplot,
                buildMeasures
            ], [
                encodingForBoxplot,
                buildMeasures,
                pickMeasuresForReshape([
                    'tooltip',
                    'label',
                    'color'
                ]),
                pickDimensionsForReshape
            ]),
            pivotAdapter([
                reshapeWithBoxplotEncoding
            ], [
                pivotReshapeWithBoxplotEncoding
            ]),
            sortLegend_sortLegend,
            theme_theme,
            markStyle_markStyle,
            annotation_annotation
        ];
        const initBoxplot = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed } = context;
            const { datasetReshapeInfo, encoding } = advancedVSeed;
            const { unfoldInfo } = datasetReshapeInfo[0];
            result.type = 'boxPlot';
            result.minField = LowerWhisker;
            result.maxField = UpperWhisker;
            result.q1Field = "__Q1__";
            result.medianField = MedianMeasureId;
            result.q3Field = "__Q3__";
            result.outliersField = OutliersMeasureId;
            result.xField = [
                unfoldInfo.encodingX
            ];
            result.seriesField = unfoldInfo.encodingColorId;
            const sameDimensionsMode = chunk_HGKLN5KY_k(encoding.x, encoding.color);
            if (!sameDimensionsMode) {
                result.xField.push(unfoldInfo.encodingColor);
                if (encoding.color?.[0] === MeasureId && encoding.value?.length === 1) result.xField.pop();
            }
            result.padding = 0;
            result.region = [
                {
                    clip: true
                }
            ];
            result.animation = true;
            return result;
        };
        const boxMaxWidth_boxMaxWidth = (spec, context)=>{
            const { advancedVSeed, vseed } = context;
            const { chartType } = vseed;
            const boxMaxWidth = advancedVSeed.config?.[chartType]?.boxMaxWidth;
            if (!chunk_JK3VNB42_n(boxMaxWidth)) return {
                ...spec,
                boxMaxWidth
            };
            return spec;
        };
        const boxGapInGroup_boxGapInGroup = (spec, context)=>{
            const { advancedVSeed, vseed } = context;
            const { chartType } = vseed;
            const boxGapInGroup = advancedVSeed.config?.[chartType]?.boxGapInGroup;
            if (!chunk_JK3VNB42_n(boxGapInGroup)) return {
                ...spec,
                boxGapInGroup
            };
            return spec;
        };
        const datasetBoxplot = (spec, context)=>{
            const { advancedVSeed, vseed } = context;
            const { datasetReshapeInfo } = advancedVSeed;
            const { id } = datasetReshapeInfo[0];
            const fields = {};
            return {
                ...spec,
                data: {
                    id,
                    values: isPivotChart(vseed) ? void 0 : advancedVSeed.dataset.flat(),
                    fields: fields
                }
            };
        };
        const boxPlotMeasureKeys = [
            UpperWhisker,
            "__Q3__",
            MedianMeasureId,
            "__Q1__",
            LowerWhisker
        ];
        const VCHART_OUTLIER_KEY = '__VCHART_BOX_PLOT_OUTLIER_VALUE';
        const tooltipBoxplot = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed, vseed } = context;
            const { chartType, dimensions, encoding } = advancedVSeed;
            const baseConfig = advancedVSeed.config[chartType];
            const { tooltip = {
                enable: true
            } } = baseConfig;
            const { enable } = tooltip;
            const meas = findAllMeasures(vseed.measures);
            const valueMeasure = meas.find((item)=>'value' === item.encoding || chunk_JK3VNB42_n(item.encoding));
            const defaultFormatter = valueMeasure ? createFormatterByMeasure(valueMeasure) : (v)=>v;
            const measureAliasMapping = {
                [OutliersMeasureId]: intl.i18n`异常点`,
                [UpperWhisker]: intl.i18n`上边界`,
                ["__Q3__"]: intl.i18n`上四分位数`,
                [MedianMeasureId]: intl.i18n`中位数`,
                ["__Q1__"]: intl.i18n`下四分位数`,
                [LowerWhisker]: intl.i18n`下边界`
            };
            result.tooltip = {
                visible: enable,
                style: getTooltipStyle(tooltip),
                mark: {
                    title: {
                        visible: false
                    },
                    content: tooltipBoxplot_createMarkContent(encoding.tooltip || [], dimensions, encoding),
                    updateContent: (prev, data)=>{
                        const datum = data?.[0]?.datum?.[0];
                        if (!chunk_JK3VNB42_n(datum?.[VCHART_OUTLIER_KEY])) {
                            const tooltipItems = (prev ?? []).filter((item)=>!boxPlotMeasureKeys.includes(item.key));
                            const outerlierMeasure = meas.find((item)=>item.id === OutliersMeasureId);
                            const formatter = outerlierMeasure ? createFormatterByMeasure(outerlierMeasure) : defaultFormatter;
                            tooltipItems.push({
                                ...tooltipItems[0],
                                key: outerlierMeasure?.alias ?? measureAliasMapping[OutliersMeasureId],
                                value: formatter(datum?.[VCHART_OUTLIER_KEY])
                            });
                            return tooltipItems;
                        }
                        return (prev ?? []).map((entry)=>{
                            if (boxPlotMeasureKeys.includes(entry.key)) {
                                const mea = meas.find((item)=>item.id === entry.key);
                                const formatter = mea ? createFormatterByMeasure(mea) : defaultFormatter;
                                return {
                                    ...entry,
                                    value: formatter(datum?.[entry.key]),
                                    key: mea?.alias ?? measureAliasMapping[entry?.key] ?? entry.key
                                };
                            }
                            return entry;
                        });
                    }
                },
                dimension: {
                    visible: false
                }
            };
            return result;
        };
        const tooltipBoxplot_createMarkContent = (tooltip, dimensions, encoding)=>{
            const dims = C(dimensions.filter((item)=>tooltip.includes(item.id)), T((item)=>item.id), T((item)=>item.alias));
            const dimContent = dims.map((item)=>({
                    visible: true,
                    hasShape: true,
                    shapeType: 'rectRound',
                    key: item.alias ?? item.id,
                    value: (datum)=>{
                        if (!chunk_JK3VNB42_n(datum?.[VCHART_OUTLIER_KEY])) {
                            if (encoding.color?.includes(item.id)) return datum?.[ColorEncoding];
                            if (encoding.x?.includes(item.id)) return datum?.[XEncoding];
                        }
                        return datum?.[item.id];
                    }
                }));
            const defaultContent = boxPlotMeasureKeys.map((key)=>({
                    visible: true,
                    hasShape: true,
                    shapeType: 'rectRound',
                    key,
                    value: (datum)=>{
                        if (!datum) return '';
                        return datum[key];
                    }
                }));
            return [
                ...dimContent,
                defaultContent
            ];
        };
        const colorBoxPlotStyleFill = (stylePipe)=>(spec, context)=>{
                const result = stylePipe(spec, context);
                const { advancedVSeed, vseed } = context;
                const { datasetReshapeInfo } = advancedVSeed;
                const { unfoldInfo } = datasetReshapeInfo[0];
                if (isLinearColor(advancedVSeed, vseed)) {
                    if (result?.boxPlot?.style) result.boxPlot.style.fill = {
                        field: unfoldInfo.encodingColor,
                        scale: 'color'
                    };
                }
                return result;
            };
        const boxPlotStyle_boxPlotStyle = (spec, context)=>{
            const { advancedVSeed, vseed } = context;
            const { markStyle, config } = advancedVSeed;
            const { boxPlotStyle } = markStyle;
            const theme = config?.[vseed.chartType]?.boxPlotStyle;
            const result = {
                ...spec,
                boxPlot: {
                    style: {
                        shaftShape: 'filled-line',
                        visible: true,
                        shaftWidth: '50%',
                        stroke: theme?.boxBorderColor
                    }
                }
            };
            if (chunk_JK3VNB42_n(boxPlotStyle) || chunk_VCYTMP4D_n(boxPlotStyle)) return result;
            const boxPlotStyles = Array.isArray(boxPlotStyle) ? boxPlotStyle : [
                boxPlotStyle
            ];
            const customMap = boxPlotStyles.reduce((result, style, index)=>{
                const { boxColor, boxColorOpacity, boxBorderColor, boxBorderWidth = 1, boxVisible = true, boxBorderOpacity } = style;
                return {
                    ...result,
                    [`custom${index + 1}`]: {
                        level: index + 1,
                        filter: (datum)=>{
                            if (selector_selector(datum, style.selector)) return true;
                            return false;
                        },
                        style: {
                            visible: boxVisible,
                            fill: boxColor,
                            fillOpacity: boxColorOpacity,
                            lineWidth: boxBorderWidth,
                            stroke: boxBorderColor,
                            strokeOpacity: boxBorderOpacity
                        }
                    }
                };
            }, {});
            result.boxPlot.state = {
                ...result.boxPlot.state,
                ...customMap
            };
            return result;
        };
        const outlierStyle_outlierStyle = (spec, context)=>{
            const { advancedVSeed, vseed } = context;
            const { markStyle, config } = advancedVSeed;
            const { outlierStyle } = markStyle;
            const theme = config?.[vseed.chartType]?.outlierStyle;
            const result = {
                ...spec,
                outlier: {
                    style: {
                        fill: theme?.pointColor
                    }
                }
            };
            if (chunk_JK3VNB42_n(outlierStyle) || chunk_VCYTMP4D_n(outlierStyle)) return result;
            const outlierStyles = Array.isArray(outlierStyle) ? outlierStyle : [
                outlierStyle
            ];
            const customMap = outlierStyles.reduce((result, style, index)=>{
                const { pointBorderColor, pointBorderStyle, pointBorderWidth = 1, pointColor, pointColorOpacity, pointSize, pointVisible = true } = style;
                const lineDash = 'dashed' === pointBorderStyle ? [
                    5,
                    2
                ] : 'dotted' === pointBorderStyle ? [
                    2,
                    5
                ] : [
                    0,
                    0
                ];
                return {
                    ...result,
                    [`custom${index + 1}`]: {
                        level: index + 1,
                        filter: (datum)=>{
                            if (selector_selector(datum, style.selector)) return true;
                            return false;
                        },
                        style: {
                            visible: pointVisible,
                            size: pointSize,
                            fill: pointColor,
                            fillOpacity: pointColorOpacity,
                            innerBorder: {
                                stroke: pointBorderColor,
                                lineWidth: pointBorderWidth,
                                distance: (pointBorderWidth || 0) / 2,
                                lineDash: lineDash
                            }
                        }
                    }
                };
            }, {});
            return {
                ...result,
                outlier: {
                    ...result.outlier,
                    state: {
                        ...customMap
                    }
                }
            };
        };
        const boxplot_boxplot = [
            initBoxplot,
            stackCornerRadius_stackCornerRadius,
            boxMaxWidth_boxMaxWidth,
            boxGapInGroup_boxGapInGroup,
            colorAdapter(color_color, linearColor),
            background_backgroundColor,
            datasetBoxplot,
            progressive,
            xBand,
            yLinear,
            label_label,
            tooltipBoxplot,
            colorAdapter(discreteLegend, colorLegend),
            verticalCrosshairRect,
            colorBoxPlotStyleFill(boxPlotStyle_boxPlotStyle),
            outlierStyle_outlierStyle,
            annotationPoint_annotationPoint,
            annotationVerticalLine_annotationVerticalLine,
            annotationHorizontalLine_annotationHorizontalLine,
            annotationAreaBand
        ];
        const pivotBoxplot = [
            initPivot,
            pivotGridStyle,
            datasetPivot,
            pivotIndicators_pivotIndicators([
                initBoxplot,
                stackCornerRadius_stackCornerRadius,
                boxMaxWidth_boxMaxWidth,
                boxGapInGroup_boxGapInGroup,
                colorAdapter(color_color, linearColor),
                background_backgroundColor,
                datasetBoxplot,
                progressive,
                xBand,
                pivotAxisStyle(yLinear),
                label_label,
                tooltipBoxplot,
                colorBoxPlotStyleFill(boxPlotStyle_boxPlotStyle),
                outlierStyle_outlierStyle,
                verticalCrosshairRect,
                annotationPoint_annotationPoint,
                annotationVerticalLine_annotationVerticalLine,
                annotationHorizontalLine_annotationHorizontalLine,
                annotationAreaBand
            ]),
            pivotRowDimensions,
            pivotColumnDimensions,
            pivotTitle,
            colorAdapter(pivotDiscreteLegend, pivotColorLegend),
            dimensionLinkage
        ];
        const boxplotSpecPipeline = [
            pivotAdapter_pivotAdapter(boxplot_boxplot, pivotBoxplot)
        ];
        const registerBoxPlot = ()=>{
            Builder._advancedPipelineMap.boxPlot = boxplotAdvancedPipeline;
            Builder._specPipelineMap.boxPlot = boxplotSpecPipeline;
        };
        const isArrayLike_isArrayLike = function(value) {
            return null !== value && "function" != typeof value && Number.isFinite(value.length);
        };
        const common_isArrayLike = isArrayLike_isArrayLike;
        function baseMerge(target, source, shallowArray = !1, skipTargetArray = !1) {
            if (source) {
                if (target === source) return;
                if (common_isValid(source) && "object" == typeof source) {
                    const iterable = Object(source), props = [];
                    for(const key in iterable)props.push(key);
                    let { length: length } = props, propIndex = -1;
                    for(; length--;){
                        const key = props[++propIndex];
                        !common_isValid(iterable[key]) || "object" != typeof iterable[key] || skipTargetArray && common_isArray(target[key]) ? assignMergeValue(target, key, iterable[key]) : baseMergeDeep(target, source, key, shallowArray, skipTargetArray);
                    }
                }
            }
        }
        function baseMergeDeep(target, source, key, shallowArray = !1, skipTargetArray = !1) {
            const objValue = target[key], srcValue = source[key];
            let newValue = source[key], isCommon = !0;
            if (common_isArray(srcValue)) {
                if (shallowArray) newValue = [];
                else if (common_isArray(objValue)) newValue = objValue;
                else if (common_isArrayLike(objValue)) {
                    newValue = new Array(objValue.length);
                    let index = -1;
                    const length = objValue.length;
                    for(; ++index < length;)newValue[index] = objValue[index];
                }
            } else common_isPlainObject(srcValue) ? (newValue = null != objValue ? objValue : {}, "function" != typeof objValue && "object" == typeof objValue || (newValue = {})) : isCommon = !1;
            isCommon && baseMerge(newValue, srcValue, shallowArray, skipTargetArray), assignMergeValue(target, key, newValue);
        }
        function assignMergeValue(target, key, value) {
            (void 0 === value || eq(target[key], value)) && (void 0 !== value || key in target) || (target[key] = value);
        }
        function eq(value, other) {
            return value === other || Number.isNaN(value) && Number.isNaN(other);
        }
        function merge(target, ...sources) {
            let sourceIndex = -1;
            const length = sources.length;
            for(; ++sourceIndex < length;)baseMerge(target, sources[sourceIndex], !0);
            return target;
        }
        const histogramConfig = (advancedVSeed, context)=>{
            const { vseed } = context;
            const { chartType } = vseed;
            const result = {
                ...advancedVSeed
            };
            const hasColorEncoding = (advancedVSeed?.dimensions || []).find((field)=>field?.encoding === 'color');
            const pickedConfig = chunk_2T7K3PFL_i(vseed, [
                'backgroundColor',
                'color',
                'label',
                'legend',
                'tooltip',
                'xAxis',
                'yAxis',
                'crosshairRect',
                'binCount',
                'binStep',
                'binValueType',
                'dimensionLinkage'
            ]);
            let config = replaceNullToUndefined(pickedConfig);
            if (pickedConfig?.binValueType === 'percentage') config = merge({}, {
                yAxis: {
                    autoFomat: false,
                    numFormat: {
                        type: 'percent',
                        fractionDigits: 1
                    }
                },
                label: {
                    autoFormat: false,
                    numFormat: {
                        type: 'percent',
                        fractionDigits: 1
                    }
                }
            }, config);
            if (!hasColorEncoding && !config?.legend?.enable) config = {
                ...config,
                legend: {
                    ...config?.legend,
                    enable: false
                }
            };
            result.config = {
                ...result.config || {},
                [chartType]: {
                    ...config
                }
            };
            return result;
        };
        const histogramXAxisConfig = (advancedVSeed, context)=>{
            const { vseed } = context;
            const { chartType } = vseed;
            const result = {
                ...advancedVSeed
            };
            const { dataset = [] } = advancedVSeed;
            const flattenDatasert = dataset.flat();
            const minValue = Math.min(...flattenDatasert.map((v)=>+v[BinStartMeasureId]));
            const maxValue = Math.max(...flattenDatasert.map((v)=>+v[BinEndMeasureId]));
            const chartConfig = result.config?.[chartType];
            result.config = {
                ...result.config || {},
                [chartType]: {
                    ...chartConfig,
                    xAxis: {
                        min: Number.isNaN(minValue) ? void 0 : minValue,
                        max: Number.isNaN(maxValue) ? void 0 : maxValue,
                        ...chartConfig?.xAxis || {}
                    }
                }
            };
            return result;
        };
        const defaultEncodingForHistogram = (advancedVSeed)=>{
            const { measures: vseedMeasures = [], dimensions = [] } = advancedVSeed;
            const measures = findAllMeasures(vseedMeasures);
            const encoding = {};
            histogram_generateDefaultDimensionEncoding(dimensions, encoding);
            histogram_generateDefaultMeasureEncoding(measures, encoding);
            return {
                ...advancedVSeed,
                encoding
            };
        };
        const encodingForHistogram = (advancedVSeed)=>{
            const { measures: vseedMeasures = [], dimensions = [] } = advancedVSeed;
            const measures = findAllMeasures(vseedMeasures);
            const hasDimensionEncoding = dimensions.some((item)=>item.encoding);
            const hasMeasureEncoding = measures.some((item)=>item.encoding);
            const encoding = {};
            if (hasDimensionEncoding) histogram_generateDimensionEncoding(dimensions, encoding, false);
            else histogram_generateDefaultDimensionEncoding(dimensions, encoding);
            if (hasMeasureEncoding) histogram_generateMeasureEncoding(measures, encoding);
            else histogram_generateDefaultMeasureEncoding(measures, encoding);
            return {
                ...advancedVSeed,
                encoding
            };
        };
        const histogram_generateDefaultDimensionEncoding = (dimensions, encoding)=>{
            const dimensionsWithoutMeasureId = dimensions.filter((item)=>item.id !== MeasureId);
            const uniqueDimIds = chunk_QJLMYOTX_i(dimensionsWithoutMeasureId.map((d)=>d.id));
            encoding.detail = encoding.color;
            encoding.tooltip = uniqueDimIds.filter((d)=>d !== MeasureId);
            encoding.label = [];
            encoding.row = [];
            encoding.column = [];
        };
        const histogram_generateDimensionEncoding = (dimensions, encoding, isMultiMeasure)=>{
            addColorToEncoding(dimensions, encoding, isMultiMeasure);
            encoding.detail = chunk_QJLMYOTX_i(dimensions.filter((item)=>'detail' === item.encoding).map((item)=>item.id));
            if (encoding.detail?.length === 0) encoding.detail = encoding.color;
            encoding.tooltip = chunk_QJLMYOTX_i(dimensions.map((item)=>item.id));
            encoding.tooltip = encoding.tooltip?.filter((d)=>d !== MeasureId);
            encoding.label = chunk_QJLMYOTX_i(dimensions.filter((item)=>'label' === item.encoding).map((item)=>item.id));
            encoding.label = encoding.label?.filter((d)=>d !== MeasureId);
        };
        const histogram_generateDefaultMeasureEncoding = (measures, encoding)=>{
            encoding.value = chunk_QJLMYOTX_i(measures.filter((item)=>'value' === item.encoding || !item.encoding).map((item)=>item.id));
            encoding.x0 = chunk_QJLMYOTX_i(measures.filter((item)=>'x0' === item.encoding).map((item)=>item.id));
            encoding.x1 = chunk_QJLMYOTX_i(measures.filter((item)=>'x1' === item.encoding).map((item)=>item.id));
            encoding.y = chunk_QJLMYOTX_i(measures.filter((item)=>'yAxis' === item.encoding).map((item)=>item.id));
        };
        const histogram_generateMeasureEncoding = (measures, encoding)=>{
            encoding.value = chunk_QJLMYOTX_i(measures.filter((item)=>'value' === item.encoding || !item.encoding).map((item)=>item.id));
            encoding.x0 = chunk_QJLMYOTX_i(measures.filter((item)=>'x0' === item.encoding).map((item)=>item.id));
            encoding.x1 = chunk_QJLMYOTX_i(measures.filter((item)=>'x1' === item.encoding).map((item)=>item.id));
            encoding.y = chunk_QJLMYOTX_i(measures.filter((item)=>'yAxis' === item.encoding).map((item)=>item.id));
            const color = chunk_QJLMYOTX_i(measures.filter((item)=>'color' === item.encoding).map((item)=>item.id));
            if (color.length > 0) encoding.color = [
                color[0]
            ];
            const label = chunk_QJLMYOTX_i(measures.filter((item)=>'label' === item.encoding).map((item)=>item.id));
            encoding.label = chunk_QJLMYOTX_i([
                ...encoding.label || [],
                ...label
            ]);
            const tooltip = chunk_QJLMYOTX_i(measures.filter((item)=>'tooltip' === item.encoding).map((item)=>item.id));
            encoding.tooltip = chunk_QJLMYOTX_i([
                ...encoding.tooltip || [],
                ...label,
                ...tooltip
            ]);
        };
        const subBin = (data, options)=>{
            var _a, _b, _c, _d;
            const { numBins: numBins, thresholds: thresholds, countName: countName, percentageName: percentageName, valuesName: valuesName, countField: countField, field: field, n: n, x0Name: x0Name, x1Name: x1Name } = options, groupField = options.groupField, usingGroup = Array.isArray(groupField) ? groupField.length > 0 : !!groupField, out = [];
            if (!usingGroup) for(let i = 0; i < numBins; i++){
                const rec = {
                    [x0Name]: thresholds[i],
                    [x1Name]: thresholds[i + 1],
                    [countName]: 0
                };
                options.includeValues && (rec[valuesName] = []), out.push(rec);
            }
            const binGroupCounts = usingGroup ? new Array(numBins).fill(0).map(()=>new Map) : [], binGroupValues = usingGroup ? new Array(numBins).fill(0).map(()=>new Map) : [], groupKeyOrder = [], groupKeySet = new Set, groupRepr = new Map;
            for(let i = 0; i < n; i++){
                const v = data[i][field];
                if (null == v) continue;
                const num = +v;
                if (Number.isFinite(num)) for(let j = 0; j < numBins; j++){
                    const left = thresholds[j], right = thresholds[j + 1];
                    if (num >= left && num < right || j === numBins - 1 && num <= right) {
                        const datumCount = null != (_a = data[i][countField]) ? _a : 1;
                        if (usingGroup) {
                            let gk;
                            gk = common_isArray(groupField) ? groupField.map((f)=>String(data[i][f])).join("||") : String(data[i][groupField]);
                            const m = binGroupCounts[j], prev = null != (_b = m.get(gk)) ? _b : 0;
                            if (m.set(gk, prev + datumCount), groupKeySet.has(gk) || (groupKeySet.add(gk), groupKeyOrder.push(gk), common_isArray(groupField) ? groupRepr.set(gk, Object.fromEntries(groupField.map((f)=>[
                                    f,
                                    data[i][f]
                                ]))) : groupRepr.set(gk, data[i][groupField])), options && options.includeValues) {
                                const vv = binGroupValues[j];
                                vv.has(gk) || vv.set(gk, []);
                                const arr = vv.get(gk);
                                arr && arr.push(data[i]);
                            }
                        } else out[j][countName] += datumCount;
                        options && options.includeValues && !usingGroup && out[j][valuesName].push(data[i]);
                        break;
                    }
                }
            }
            let totalCount = 0;
            const finalOut = [];
            if (usingGroup) {
                for(let j = 0; j < numBins; j++)for (const gk of groupKeyOrder){
                    const sum = null != (_c = binGroupCounts[j].get(gk)) ? _c : 0, rec = {
                        [x0Name]: thresholds[j],
                        [x1Name]: thresholds[j + 1],
                        [countName]: sum
                    }, repr = null != (_d = groupRepr.get(gk)) ? _d : {};
                    if (common_isArray(groupField)) for (const f of groupField)rec[f] = repr[f];
                    else groupField && (rec[groupField] = repr);
                    options && options.includeValues && (rec[valuesName] = binGroupValues[j].get(gk) || []), finalOut.push(rec), totalCount += sum;
                }
                const denominator = totalCount;
                for (const r of finalOut)r[percentageName] = denominator > 0 ? r[countName] / denominator : 0;
            } else {
                for(let i = 0, len = out.length; i < len; i++)totalCount += out[i][countName];
                for(let i = 0, len = out.length; i < len; i++)out[i][percentageName] = totalCount > 0 ? out[i][countName] / totalCount : 0, finalOut.push(out[i]);
            }
            return finalOut;
        };
        const bin = (data, options)=>{
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            const field = null == options ? void 0 : options.field;
            if (!field) return [];
            const countField = options.countField, n = data.length;
            let thresholds, min = 1 / 0, max = -1 / 0;
            if (options.extent) min = options.extent[0], max = options.extent[1];
            else for(let i = 0; i < n; i++){
                const v = data[i][field];
                if (common_isNil(v)) continue;
                const num = +v;
                Number.isFinite(num) && (num < min && (min = num), num > max && (max = num));
            }
            if (!Number.isFinite(min) || !Number.isFinite(max) || 0 === n) return [];
            if (options.thresholds && options.thresholds.length) thresholds = options.thresholds.slice(), thresholds.sort((a, b)=>a - b);
            else if ("number" == typeof options.step && options.step > 0) {
                const stepSize = options.step;
                let startMin = min;
                for(options.extent || (startMin = Math.floor(min / stepSize) * stepSize), thresholds = [
                    startMin
                ]; startMin <= max;)startMin += stepSize, thresholds.push(startMin);
            } else {
                const bins = options.bins && options.bins > 0 ? Math.floor(options.bins) : 10;
                if (max - min > 1) {
                    const start = Math.floor(min), stepSizeInt = Math.ceil((max - start) / bins);
                    thresholds = new Array(bins + 1);
                    for(let i = 0; i <= bins; i++)thresholds[i] = start + stepSizeInt * i;
                } else {
                    const stepSize = (max - min) / bins;
                    thresholds = new Array(bins + 1);
                    for(let i = 0; i <= bins; i++)thresholds[i] = min + stepSize * i;
                }
            }
            const numBins = Math.max(0, thresholds.length - 1);
            if (0 === numBins) return [];
            const x0Name = null != (_b = null == (_a = options.outputNames) ? void 0 : _a.x0) ? _b : "x0", x1Name = null != (_d = null == (_c = options.outputNames) ? void 0 : _c.x1) ? _d : "x1", countName = null != (_f = null == (_e = options.outputNames) ? void 0 : _e.count) ? _f : "count", valuesName = null != (_h = null == (_g = options.outputNames) ? void 0 : _g.values) ? _h : "values", percentageName = null != (_k = null == (_j = options.outputNames) ? void 0 : _j.percentage) ? _k : "percentage", facetField = common_isArray(null == options ? void 0 : options.facetField) ? null == options ? void 0 : options.facetField : (null == options ? void 0 : options.facetField) ? [
                options.facetField
            ] : [], groupField = common_isArray(null == options ? void 0 : options.groupField) ? null == options ? void 0 : options.groupField : (null == options ? void 0 : options.groupField) ? [
                options.groupField
            ] : [], normalizedGroupField = groupField.length ? groupField : void 0, subViewOptions = Object.assign(Object.assign({}, options), {
                numBins: numBins,
                thresholds: thresholds,
                countName: countName,
                percentageName: percentageName,
                valuesName: valuesName,
                countField: countField,
                field: field,
                n: n,
                x0Name: x0Name,
                x1Name: x1Name,
                groupField: normalizedGroupField
            });
            if (!facetField.length) return subBin(data, subViewOptions);
            const subViewMap = {};
            return data.forEach((dataItem)=>{
                const subViewKey = facetField.map((field)=>null == dataItem ? void 0 : dataItem[field]).join("-&&-");
                subViewMap[subViewKey] ? subViewMap[subViewKey].push(dataItem) : subViewMap[subViewKey] = [
                    dataItem
                ];
            }), Object.values(subViewMap).map((subDataset)=>{
                const combinedGroupField = [
                    ...groupField,
                    ...facetField
                ];
                return subBin(subDataset, Object.assign(Object.assign({}, subViewOptions), {
                    groupField: combinedGroupField.length ? combinedGroupField : void 0,
                    n: subDataset.length
                }));
            }).flat();
        };
        const reshapeWithHistogramEncoding = (advancedVSeed, context)=>{
            const result = {
                ...advancedVSeed
            };
            const { vseed } = context;
            const { dataset, chartType } = vseed;
            const { encoding = {}, config } = advancedVSeed;
            const measures = advancedVSeed.reshapeMeasures ?? advancedVSeed.measures ?? [];
            const dimensions = advancedVSeed.reshapeDimensions ?? advancedVSeed.dimensions ?? [];
            const uniqDims = T(dimensions, (item)=>item.id);
            const chartConfig = config?.[chartType];
            const binCount = chartConfig?.binCount;
            const binStep = chartConfig?.binStep;
            const binValueType = chartConfig?.binValueType;
            let newDatasets = [];
            let foldInfo = {
                foldMap: {},
                measureId: FoldMeasureId,
                measureName: FoldMeasureName,
                measureValue: FoldMeasureValue,
                statistics: {
                    max: -1 / 0,
                    min: 1 / 0,
                    sum: 0,
                    count: 0,
                    colorMin: 1 / 0,
                    colorMax: -1 / 0
                }
            };
            let unfoldInfo = {};
            const colorMeasureId = getColorMeasureId(advancedVSeed, vseed);
            const allMeasures = findAllMeasures(measures);
            if (encoding.value?.length) {
                const valueField = encoding.value[0];
                const m = allMeasures.find((m)=>m.id === valueField);
                const binData = bin(dataset, {
                    field: valueField,
                    groupField: [
                        ...encoding.x ?? [],
                        ...encoding.color ?? []
                    ],
                    bins: binCount,
                    step: binStep,
                    outputNames: {
                        x0: BinStartMeasureId,
                        x1: BinEndMeasureId,
                        count: BinCountMeasureId,
                        percentage: BinPercentageMeasureId
                    }
                });
                binData.forEach((datum)=>{
                    datum[FoldMeasureId] = valueField;
                    datum[FoldMeasureName] = m?.alias ?? valueField;
                    const valueNumber = 'percentage' === binValueType ? +datum[BinPercentageMeasureId] : +datum[BinCountMeasureId];
                    datum[FoldMeasureValue] = valueNumber;
                    datum[valueField] = valueNumber;
                    foldInfo.statistics.min = Math.min(foldInfo.statistics.min, valueNumber);
                    foldInfo.statistics.max = Math.max(foldInfo.statistics.max, valueNumber);
                    foldInfo.statistics.sum += valueNumber;
                    foldInfo.statistics.count++;
                });
                if (m?.id) foldInfo.foldMap[m?.id] = m?.alias;
                const res = unfoldDimensions(binData, uniqDims, encoding, {
                    foldMeasureId: FoldMeasureId,
                    separator: "-",
                    colorItemAsId: false
                });
                res.dataset.forEach((d)=>{
                    newDatasets.push(d);
                });
                unfoldInfo = res.unfoldInfo;
            } else if (encoding.x0?.length && encoding.x1?.length && encoding.y?.length) {
                const res = dataReshapeByEncoding(dataset, T(dimensions, (item)=>item.id), findAllMeasures(measures).filter((item)=>encoding.y?.includes(item.id)).slice(0, 1), encoding, {
                    colorItemAsId: false,
                    colorMeasureId
                });
                res.dataset.forEach((datum)=>{
                    datum[BinStartMeasureId] = datum[encoding.x0[0]];
                    datum[BinEndMeasureId] = datum[encoding.x1[0]];
                });
                newDatasets = res.dataset;
                foldInfo = res.foldInfo;
                unfoldInfo = res.unfoldInfo;
            }
            return {
                ...result,
                dataset: newDatasets,
                datasetReshapeInfo: [
                    {
                        id: String(chartType),
                        index: 0,
                        foldInfo,
                        unfoldInfo
                    }
                ],
                dimensions,
                measures
            };
        };
        const pivotReshapeWithHistogramEncoding = (advancedVSeed, context)=>{
            const result = {
                ...advancedVSeed
            };
            const { vseed } = context;
            const { dataset, chartType } = vseed;
            const { encoding = {}, config } = advancedVSeed;
            const measures = advancedVSeed.reshapeMeasures ?? advancedVSeed.measures ?? [];
            const dimensions = advancedVSeed.reshapeDimensions ?? advancedVSeed.dimensions ?? [];
            const colorMeasureId = getColorMeasureId(advancedVSeed, vseed);
            const uniqDims = T(dimensions, (item)=>item.id);
            const chartConfig = config?.[chartType];
            const binCount = chartConfig?.binCount;
            const binStep = chartConfig?.binStep;
            const binValueType = chartConfig?.binValueType;
            const measureGroups = [];
            if (measures) measures.forEach((measure)=>{
                if (measure.children && measure.children.length > 0) measureGroups.push(measure);
            });
            const rowColumnFields = T(dimensions.filter((dim)=>'row' === dim.encoding || 'column' === dim.encoding), (item)=>item.id);
            const datasets = [];
            const datasetReshapeInfo = [];
            measureGroups.forEach((measureGroup, index)=>{
                const subMeasures = measureGroup.children;
                if (!subMeasures) return;
                const groupId = measureGroup.id;
                let newDatasets = [];
                let foldInfo = {
                    foldMap: {},
                    measureId: FoldMeasureId,
                    measureName: FoldMeasureName,
                    measureValue: FoldMeasureValue,
                    statistics: {
                        max: -1 / 0,
                        min: 1 / 0,
                        sum: 0,
                        count: 0,
                        colorMin: 1 / 0,
                        colorMax: -1 / 0
                    }
                };
                let unfoldInfo = {};
                if (encoding.value?.length) {
                    const valueField = encoding.value[0];
                    const m = subMeasures.find((m)=>m.id === valueField);
                    const binData = bin(dataset, {
                        field: valueField,
                        groupField: [
                            ...encoding.x ?? [],
                            ...encoding.color ?? []
                        ],
                        facetField: rowColumnFields.map((item)=>item.id),
                        bins: binCount,
                        step: binStep,
                        outputNames: {
                            x0: BinStartMeasureId,
                            x1: BinEndMeasureId,
                            count: BinCountMeasureId,
                            percentage: BinPercentageMeasureId
                        }
                    });
                    binData.forEach((datum)=>{
                        datum[FoldMeasureId] = valueField;
                        datum[FoldMeasureName] = m?.alias ?? valueField;
                        const valueNumber = 'percentage' === binValueType ? +datum[BinPercentageMeasureId] : +datum[BinCountMeasureId];
                        datum[FoldMeasureValue] = valueNumber;
                        datum[valueField] = valueNumber;
                        foldInfo.statistics.min = Math.min(foldInfo.statistics.min, valueNumber);
                        foldInfo.statistics.max = Math.max(foldInfo.statistics.max, valueNumber);
                        foldInfo.statistics.sum += valueNumber;
                        foldInfo.statistics.count++;
                    });
                    if (m?.id) foldInfo.foldMap[m?.id] = m?.alias;
                    const res = unfoldDimensions(binData, uniqDims, encoding, {
                        foldMeasureId: FoldMeasureId,
                        separator: "-",
                        colorItemAsId: false
                    });
                    res.dataset.forEach((d)=>{
                        newDatasets.push(d);
                    });
                    unfoldInfo = res.unfoldInfo;
                } else if (encoding.x0?.length && encoding.x1?.length && encoding.y?.length) {
                    const res = dataReshapeByEncoding(dataset, T(dimensions, (item)=>item.id), subMeasures.filter((item)=>encoding.y?.includes(item.id)).slice(0, 1), encoding, {
                        colorItemAsId: false,
                        colorMeasureId
                    });
                    res.dataset.forEach((datum)=>{
                        datum[BinStartMeasureId] = datum[encoding.x0[0]];
                        datum[BinEndMeasureId] = datum[encoding.x1[0]];
                        datum[FoldMeasureId] = datum[encoding.y[0]];
                    });
                    newDatasets = res.dataset;
                    foldInfo = res.foldInfo;
                    unfoldInfo = res.unfoldInfo;
                }
                const reshapeInfo = {
                    id: `${groupId}`,
                    index,
                    foldInfo,
                    unfoldInfo
                };
                datasets.push(newDatasets);
                datasetReshapeInfo.push(reshapeInfo);
            });
            return {
                ...result,
                dataset: datasets,
                datasetReshapeInfo: datasetReshapeInfo
            };
        };
        const histogramAdvancedPipeline = [
            initAdvancedVSeed_initAdvancedVSeed,
            default_defaultMeasures_defaultMeasures,
            defaultDimensions_defaultDimensions,
            histogramConfig,
            encodingAdapter([
                defaultEncodingForHistogram,
                buildMeasures
            ], [
                encodingForHistogram,
                buildMeasures,
                pickMeasuresForReshape([
                    'tooltip',
                    'label',
                    'color'
                ]),
                pickDimensionsForReshape
            ]),
            pivotAdapter([
                reshapeWithHistogramEncoding
            ], [
                pivotReshapeWithHistogramEncoding
            ]),
            histogramXAxisConfig,
            sortLegend_sortLegend,
            theme_theme,
            markStyle_markStyle,
            annotation_annotation,
            regressionLine_regressionLine
        ];
        const initHistogram = (spec)=>{
            const result = {
                ...spec
            };
            result.type = 'histogram';
            result.xField = BinStartMeasureId;
            result.x2Field = BinEndMeasureId;
            result.yField = FoldMeasureValue;
            result.padding = 0;
            result.region = [
                {
                    clip: true
                }
            ];
            result.legends = {
                visible: false
            };
            result.barGap = 2;
            result.animation = true;
            return result;
        };
        const datasetHistogram = (spec, context)=>{
            const { advancedVSeed, vseed } = context;
            const { datasetReshapeInfo } = advancedVSeed;
            const { id } = datasetReshapeInfo[0];
            const fields = {};
            return {
                ...spec,
                data: {
                    id,
                    values: isPivotChart(vseed) ? void 0 : advancedVSeed.dataset.flat(),
                    fields: fields
                }
            };
        };
        const getDefaultXFormatterOfHistogram = (advancedVSeed)=>{
            const { chartType, config } = advancedVSeed;
            const xConfig = config?.[chartType]?.xAxis;
            const { autoFormat = true, numFormat = {} } = xConfig;
            const formatter = createNumFormatter(numFormat);
            return (value)=>createLinearFormat(value, autoFormat, numFormat, formatter);
        };
        const getDefaultValueFormatterOfHistogram = (binValueType = 'count')=>'percentage' === binValueType ? createNumFormatter({
                type: 'percent',
                fractionDigits: 1
            }) : (value)=>autoFormatter(value);
        const tooltipHistogram_VCHART_OUTLIER_KEY = '__VCHART_BOX_PLOT_OUTLIER_VALUE';
        const tooltipHistogram = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed } = context;
            const { chartType, dimensions, encoding } = advancedVSeed;
            const baseConfig = advancedVSeed.config[chartType];
            const { binValueType, tooltip = {
                enable: true
            } } = baseConfig;
            const { enable } = tooltip;
            const defaultXFormatter = getDefaultXFormatterOfHistogram(advancedVSeed);
            const defaultValueFormatter = getDefaultValueFormatterOfHistogram(binValueType);
            result.tooltip = {
                style: getTooltipStyle(tooltip),
                visible: enable,
                mark: {
                    title: {
                        visible: false
                    },
                    content: tooltipHistogram_createMarkContent(encoding.tooltip || [], dimensions, encoding, defaultXFormatter, defaultValueFormatter)
                },
                dimension: {
                    title: {
                        visible: false
                    },
                    content: tooltipHistogram_createMarkContent(encoding.tooltip || [], dimensions, encoding, defaultXFormatter, defaultValueFormatter)
                }
            };
            return result;
        };
        const tooltipHistogram_createMarkContent = (tooltip, dimensions, encoding, dimFormatter, defaultValueFormatter)=>{
            const dims = C(dimensions.filter((item)=>tooltip.includes(item.id)), T((item)=>item.id), T((item)=>item.alias));
            const dimContent = dims.map((item)=>({
                    visible: true,
                    hasShape: true,
                    shapeType: 'rectRound',
                    key: item.alias ?? item.id,
                    value: (datum)=>{
                        if (!chunk_JK3VNB42_n(datum?.[tooltipHistogram_VCHART_OUTLIER_KEY])) {
                            if (encoding.color?.includes(item.id)) return datum?.[ColorEncoding];
                            if (encoding.x?.includes(item.id)) return datum?.[XEncoding];
                        }
                        return defaultValueFormatter(datum?.[item.id]);
                    }
                }));
            const defaultContent = [
                {
                    visible: true,
                    hasShape: true,
                    shapeType: 'rectRound',
                    key: (datum)=>{
                        if (!datum) return '';
                        return `[${dimFormatter(+datum[BinStartMeasureId])}, ${dimFormatter(+datum[BinEndMeasureId])})`;
                    },
                    value: (datum)=>{
                        if (!datum) return '';
                        return defaultValueFormatter(datum[FoldMeasureValue]);
                    }
                }
            ];
            return [
                ...dimContent,
                defaultContent
            ];
        };
        const histogramVerticalCrosshairRect = (spec, context)=>{
            const result = verticalCrosshairRect(spec, context);
            if (!result.crosshair) return result;
            const crosshair = result.crosshair;
            if (!crosshair.xField) return result;
            const defaultXFormatter = getDefaultXFormatterOfHistogram(context.advancedVSeed);
            crosshair.xField = {
                ...crosshair.xField || {},
                label: {
                    ...crosshair.xField?.label || {},
                    formatMethod: (text)=>{
                        if (common_isArray(text)) return text;
                        const binRange = `${text}`.split('~');
                        const binStart = defaultXFormatter(+binRange[0]);
                        const binEnd = defaultXFormatter(+binRange[1]);
                        return 1 === binRange.length ? binStart : `[${binStart}, ${binEnd})`;
                    }
                }
            };
            return result;
        };
        const annotationPointOfHistogram = generateAnnotationPointPipe({
            generateMarkPoint: (datum, spec)=>{
                const histogramSpec = spec;
                const xField = histogramSpec.xField;
                const x2Field = histogramSpec.x2Field;
                return [
                    {
                        coordinate: (data)=>{
                            const d = data.find((item)=>isSubset(datum, item));
                            return d ? {
                                ...d,
                                [xField]: (d[xField] + d[x2Field]) / 2
                            } : void 0;
                        }
                    }
                ];
            }
        });
        const gaussian = (u)=>1 / Math.sqrt(2 * Math.PI) * Math.exp(-0.5 * u * u);
        function scott(n, std, dim = 1) {
            return n <= 0 || 0 === std ? 0 : std * Math.pow(n, -1 / (dim + 4));
        }
        function silverman(n, std, dim = 1) {
            if (n <= 0 || 0 === std) return 0;
            return Math.pow(4 / (dim + 2), 1 / (dim + 4)) * std * Math.pow(n, -1 / (dim + 4));
        }
        function kde_std(values) {
            const n = values.length;
            if (0 === n) return 0;
            let mean = 0;
            for(let i = 0; i < n; i++)mean += values[i];
            mean /= n;
            let s = 0;
            for(let i = 0; i < n; i++){
                const d = values[i] - mean;
                s += d * d;
            }
            return Math.sqrt(s / n);
        }
        function kde(data, options = {}) {
            const n = data.length, kernel = options.kernel || gaussian;
            let h = options.bandwidth;
            if (!h || h <= 0) {
                const sd = kde_std(data) || 0, method = options.bandwidthMethod || "scott";
                h = "silverman" === method ? silverman(n, sd, 1) : scott(n, sd, 1);
            }
            if (!h || h <= 0) return {
                bandwidth: 0,
                kernel: kernel,
                evaluate: (x)=>{
                    if (Array.isArray(x)) {
                        const out = [];
                        for(let i = 0; i < x.length; i++)out.push(0);
                        return out;
                    }
                    return 0;
                },
                evaluateGrid: (N)=>{
                    const out = [];
                    if (N <= 0) return out;
                    let min = 1 / 0, max = -1 / 0;
                    for(let j = 0; j < n; j++){
                        const v = data[j];
                        v < min && (min = v), v > max && (max = v);
                    }
                    if (min === 1 / 0 || max === -1 / 0) {
                        for(let i = 0; i < N; i++)out.push({
                            x: 0,
                            y: 0
                        });
                        return out;
                    }
                    for(let i = 0; i < N; i++)out.push({
                        x: min,
                        y: 0
                    });
                    return out;
                }
            };
            const invNh = 1 / (n * h);
            function evalPoint(x) {
                let sum = 0;
                for(let j = 0; j < n; j++)sum += kernel((x - data[j]) / h);
                return sum * invNh;
            }
            return {
                bandwidth: h,
                kernel: kernel,
                evaluate: function(x) {
                    if (Array.isArray(x)) {
                        const out = [];
                        for(let i = 0; i < x.length; i++)out.push(evalPoint(x[i]));
                        return out;
                    }
                    return evalPoint(x);
                },
                evaluateGrid (N) {
                    const out = [];
                    if (N <= 0) return out;
                    let min = 1 / 0, max = -1 / 0;
                    for(let i = 0; i < n; i++){
                        const v = data[i];
                        v < min && (min = v), v > max && (max = v);
                    }
                    if (min === 1 / 0 || max === -1 / 0) return out;
                    if (min === max) {
                        for(let i = 0; i < N; i++)out.push({
                            x: min,
                            y: evalPoint(min)
                        });
                        return out;
                    }
                    const step = (max - min) / (N - 1);
                    for(let i = 0; i < N; i++){
                        const x = i === N - 1 ? max : min + step * i;
                        out.push({
                            x: x,
                            y: evalPoint(x)
                        });
                    }
                    return out;
                }
            };
        }
        const kdeRegressionLine = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed, vseed } = context;
            const { chartType, encoding = {}, dimensions, regressionLine } = advancedVSeed;
            const { dataset } = vseed;
            const lineTheme = advancedVSeed.config[chartType]?.regressionLine;
            const binValueType = advancedVSeed.config[chartType]?.binValueType;
            if (!regressionLine || !regressionLine.kdeRegressionLine) return result;
            const rowColumnFields = T(dimensions.filter((dim)=>'row' === dim.encoding || 'column' === dim.encoding), (item)=>item.id);
            const lineList = array_array(regressionLine.kdeRegressionLine).filter((kdeLine)=>false !== kdeLine.enable);
            if (!result.extensionMark) result.extensionMark = [];
            lineList.forEach((line, lineIndex)=>{
                if (false === line.enable) return;
                const theme = lineTheme.kdeRegressionLine ?? {};
                const { color, lineWidth, lineDash, text, textColor, textFontSize, textFontWeight } = line;
                const childrenMarks = [];
                result.extensionMark.push({
                    type: 'group',
                    interactive: false,
                    zIndex: 500,
                    name: `kdeRegressionLine-${lineIndex}`,
                    dataId: spec.data?.id,
                    style: {
                        data: (datum, ctx)=>{
                            const vchart = ctx.vchart;
                            const chart = vchart.getChart();
                            const series = chart.getAllSeries().filter((s)=>'bar' === s.type);
                            if (series && series.length) {
                                const s = series[0];
                                const fieldX = s.fieldX?.[0];
                                const scaleY = s.getYAxisHelper().getScale?.(0);
                                const viewData = s.getViewData()?.latestData;
                                if (!dataset || !dataset.length || !viewData || !viewData.length || !scaleY) return null;
                                const simpleData = dataset.filter((entry)=>rowColumnFields.length ? rowColumnFields.every((dim)=>entry[dim.id] === viewData[0][dim.id]) : true).map((d)=>+d[encoding.value?.[0]]);
                                const res = kde(simpleData, {
                                    bandwidth: Math.abs(viewData[0][BinEndMeasureId] - viewData[0][BinStartMeasureId])
                                });
                                const N = Math.max(3, Math.floor(simpleData.length / 4));
                                const lineData = res.evaluateGrid(N);
                                const scaleR = (k)=>{
                                    if ('percentage' === binValueType) return scaleY.scale(k * res.bandwidth);
                                    return scaleY.scale(k * simpleData.length * res.bandwidth);
                                };
                                const linePoints = lineData.map((ld)=>{
                                    const d = {
                                        [fieldX]: ld.x
                                    };
                                    return {
                                        x: s.dataToPositionX(d),
                                        y: scaleR(ld.y)
                                    };
                                });
                                return {
                                    linePoints,
                                    color: color ?? s.getOption().globalScale.getScale('color')?.scale(s.getSeriesKeys()[0])
                                };
                            }
                            return null;
                        }
                    },
                    children: childrenMarks
                });
                childrenMarks.push({
                    type: 'line',
                    interactive: false,
                    zIndex: 500,
                    dataId: spec.data?.id,
                    style: {
                        lineWidth: lineWidth ?? theme.lineWidth,
                        lineDash: lineDash ?? theme.lineDash,
                        stroke: color ?? defaultRegressionLineColor,
                        points: (datum, ctx, opt)=>{
                            const parentNode = opt.mark?._product?.parent;
                            if (parentNode?.attribute?.data) return parentNode.attribute.data.linePoints;
                            return [];
                        }
                    }
                });
                if (!chunk_JK3VNB42_n(text)) childrenMarks.push({
                    type: 'text',
                    interactive: false,
                    zIndex: 500,
                    dataId: spec.data?.id,
                    dataKey: ()=>`kdeRegressionLine-label-${lineIndex}`,
                    style: {
                        textAlign: 'end',
                        fill: textColor ?? theme.textColor,
                        fontSize: textFontSize ?? theme.textFontSize,
                        fontWeight: textFontWeight ?? theme.textFontWeight,
                        text: text,
                        x: defaultRegressionLineLabelX,
                        y: defaultRegressionLineLabelY
                    }
                });
            });
            return result;
        };
        function ecdf(data) {
            const n = data.length, sorted = data.slice().sort((a, b)=>a - b);
            function evaluateSingle(x) {
                if (0 === n) return 0;
                let lo = 0, hi = n;
                for(; lo < hi;){
                    const mid = lo + hi >>> 1;
                    sorted[mid] <= x ? lo = mid + 1 : hi = mid;
                }
                return lo / n;
            }
            return {
                evaluate: function(x) {
                    if (Array.isArray(x)) {
                        const out = [];
                        for(let i = 0; i < x.length; i++)out.push(evaluateSingle(x[i]));
                        return out;
                    }
                    return evaluateSingle(x);
                },
                evaluateGrid: function(N) {
                    const out = [];
                    if (N <= 0) return out;
                    if (0 === n) return out;
                    const min = sorted[0], max = sorted[n - 1];
                    if (min === max) {
                        for(let i = 0; i < N; i++)out.push({
                            x: min,
                            y: 1
                        });
                        return out;
                    }
                    const step = (max - min) / (N - 1);
                    for(let i = 0; i < N; i++){
                        const x = i === N - 1 ? max : min + step * i;
                        out.push({
                            x: x,
                            y: evaluateSingle(x)
                        });
                    }
                    return out;
                },
                n: n
            };
        }
        const ecdfRegressionLine = (spec, context)=>{
            const result = {
                ...spec
            };
            const { advancedVSeed, vseed } = context;
            const { chartType, encoding = {}, dimensions, regressionLine } = advancedVSeed;
            const { dataset } = vseed;
            const lineTheme = advancedVSeed.config[chartType]?.regressionLine;
            if (!regressionLine || !regressionLine.ecdfRegressionLine) return result;
            const rowColumnFields = T(dimensions.filter((dim)=>'row' === dim.encoding || 'column' === dim.encoding), (item)=>item.id);
            const lineList = array_array(regressionLine.ecdfRegressionLine).filter((ecdfLine)=>false !== ecdfLine.enable);
            if (!result.extensionMark) result.extensionMark = [];
            lineList.forEach((line, lineIndex)=>{
                if (false === line.enable) return;
                const theme = lineTheme?.ecdfRegressionLine ?? {};
                const { color, lineWidth, lineDash, text, textColor, textFontSize, textFontWeight } = line;
                const childrenMarks = [];
                result.extensionMark.push({
                    type: 'group',
                    interactive: false,
                    zIndex: 500,
                    name: `ecdfRegressionLine-${lineIndex}`,
                    dataId: spec.data?.id,
                    style: {
                        data: (datum, ctx)=>{
                            const vchart = ctx.vchart;
                            const chart = vchart.getChart();
                            const series = chart.getAllSeries().filter((s)=>'bar' === s.type);
                            if (series && series.length) {
                                const s = series[0];
                                const fieldX = s.fieldX?.[0];
                                const scaleY = s.getYAxisHelper().getScale?.(0);
                                const viewData = s.getViewData()?.latestData;
                                if (!dataset || !dataset.length || !viewData || !viewData.length || !scaleY) return null;
                                const simpleData = dataset.filter((entry)=>rowColumnFields.length ? rowColumnFields.every((dim)=>entry[dim.id] === viewData[0][dim.id]) : true).map((d)=>+d[encoding.value?.[0]]);
                                const res = ecdf(simpleData);
                                const N = Math.max(3, Math.floor(simpleData.length / 4));
                                const lineData = res.evaluateGrid(N);
                                const yRange = scaleY.range();
                                const y0 = yRange[0];
                                const y1 = yRange[yRange.length - 1];
                                const scaleR = (e)=>y0 + (y1 - y0) * e;
                                const linePoints = lineData.map((ld)=>{
                                    const d = {
                                        [fieldX]: ld.x
                                    };
                                    return {
                                        x: s.dataToPositionX(d),
                                        y: scaleR(ld.y)
                                    };
                                });
                                return {
                                    linePoints,
                                    color: color ?? s.getOption().globalScale.getScale('color')?.scale(s.getSeriesKeys()[0])
                                };
                            }
                            return null;
                        }
                    },
                    children: childrenMarks
                });
                childrenMarks.push({
                    type: 'line',
                    interactive: false,
                    zIndex: 500,
                    dataId: spec.data?.id,
                    style: {
                        lineWidth: lineWidth ?? theme.lineWidth,
                        lineDash: lineDash ?? theme.lineDash,
                        stroke: color ?? defaultRegressionLineColor,
                        points: (datum, ctx, opt)=>{
                            const parentNode = opt.mark?._product?.parent;
                            if (parentNode?.attribute?.data) return parentNode.attribute.data.linePoints;
                            return [];
                        }
                    }
                });
                if (!chunk_JK3VNB42_n(text)) childrenMarks.push({
                    type: 'text',
                    interactive: false,
                    zIndex: 500,
                    dataId: spec.data?.id,
                    dataKey: ()=>`ecdfRegressionLine-label-${lineIndex}`,
                    style: {
                        textAlign: 'end',
                        fill: textColor ?? theme.textColor,
                        fontSize: textFontSize ?? theme.textFontSize,
                        fontWeight: textFontWeight ?? theme.textFontWeight,
                        text: text,
                        x: defaultRegressionLineLabelX,
                        y: defaultRegressionLineLabelY
                    }
                });
            });
            const leftAxis = result.axes?.find((v)=>'left' === v.orient);
            if (leftAxis && lineList.length) result.axes?.push({
                visible: true,
                orient: 'right',
                type: 'linear',
                base: 10,
                min: 0,
                max: 1,
                domainLine: {
                    ...leftAxis.domainLine
                },
                grid: {
                    visible: false
                },
                tick: {
                    ...leftAxis.tick
                },
                title: {
                    ...leftAxis.title,
                    visible: false
                },
                label: {
                    ...leftAxis.label,
                    visible: true,
                    formatMethod: (v)=>{
                        const text = common_isArray(v) ? v[0] : v;
                        return `${(100 * text).toFixed(1)}%`;
                    }
                }
            });
            return result;
        };
        const histogram = [
            initHistogram,
            colorAdapter(color_color, linearColor),
            background_backgroundColor,
            datasetHistogram,
            progressive,
            xLinear,
            yLinear,
            label_label,
            tooltipHistogram,
            colorAdapter(discreteLegend, colorLegend),
            histogramVerticalCrosshairRect,
            colorBarStyleFill(barStyle_barStyle),
            annotationPointOfHistogram,
            annotationVerticalLine_annotationVerticalLine,
            annotationHorizontalLine_annotationHorizontalLine,
            annotationAreaBand,
            kdeRegressionLine,
            ecdfRegressionLine
        ];
        const pivotHistogram = [
            initPivot,
            pivotGridStyle,
            datasetPivot,
            pivotIndicators_pivotIndicators([
                initHistogram,
                colorAdapter(color_color, linearColor),
                background_backgroundColor,
                datasetHistogram,
                progressive,
                xLinear,
                pivotAxisStyle(yLinear),
                label_label,
                tooltipHistogram,
                colorBarStyleFill(barStyle_barStyle),
                histogramVerticalCrosshairRect,
                annotationPointOfHistogram,
                annotationVerticalLine_annotationVerticalLine,
                annotationHorizontalLine_annotationHorizontalLine,
                annotationAreaBand,
                kdeRegressionLine,
                ecdfRegressionLine
            ]),
            pivotRowDimensions,
            pivotColumnDimensions,
            pivotTitle,
            colorAdapter(pivotDiscreteLegend, pivotColorLegend),
            dimensionLinkage
        ];
        const histogramSpecPipeline = [
            pivotAdapter_pivotAdapter(histogram, pivotHistogram)
        ];
        const registerHistogram = ()=>{
            Builder._advancedPipelineMap.histogram = histogramAdvancedPipeline;
            Builder._specPipelineMap.histogram = histogramSpecPipeline;
        };
        const getDarkCrosshairLine = ()=>({
                visible: true,
                labelVisible: true,
                labelColor: '#ffffff',
                labelBackgroundColor: '#404349',
                lineColor: '#55595F'
            });
        const getDarkCrosshairRect = ()=>({
                visible: true,
                labelVisible: true,
                labelColor: '#ffffff',
                labelBackgroundColor: '#404349',
                rectColor: '#4B4F54'
            });
        const getLightCrosshairLine = ()=>({
                visible: true,
                labelVisible: true,
                labelColor: '#ffffff',
                labelBackgroundColor: '#21252C',
                lineColor: '#21252C'
            });
        const getLightCrosshairRect = ()=>({
                visible: true,
                labelVisible: true,
                labelColor: '#ffffff',
                labelBackgroundColor: '#364159',
                rectColor: '#D9DDE4'
            });
        const getLightColorScheme = ()=>[
                '#8D72F6',
                '#5766EC',
                '#66A3FE',
                '#51D5E6',
                '#4EC0B3',
                '#F9DF90',
                '#F9AD71',
                '#ED8888',
                '#E9A0C3',
                '#D77DD3'
            ];
        const getDarkColorScheme = ()=>[
                '#2E62F1',
                '#4DC36A',
                '#FF8406',
                '#FFCC00',
                '#4F44CF',
                '#5AC8FA',
                '#003A8C',
                '#B08AE2',
                '#FF6341',
                '#98DD62'
            ];
        const getLightLinearColorScheme = ()=>[
                '#C2CEFF',
                '#5766EC'
            ];
        const getDarkLinearColorScheme = ()=>[
                '#A0CEFF',
                '#2E62F1'
            ];
        const getLightColor = ()=>({
                linearColorScheme: getLightLinearColorScheme(),
                colorScheme: getLightColorScheme(),
                positiveColor: '#7E5DFF',
                negativeColor: '#EB3373'
            });
        const getDarkColor = ()=>({
                linearColorScheme: getDarkLinearColorScheme(),
                colorScheme: getDarkColorScheme(),
                positiveColor: '#7E5DFF',
                negativeColor: '#EB3373'
            });
        const getDefaultLabel = ()=>({
                enable: true,
                wrap: true,
                showValue: true,
                showValuePercent: false,
                labelColorSmartInvert: false,
                labelOverlap: true
            });
        const getDarkLabel = ()=>({
                ...getDefaultLabel(),
                labelStroke: '#21252C'
            });
        const getLightLabel = ()=>({
                ...getDefaultLabel(),
                labelStroke: '#fff'
            });
        const getDefaultLegend = ()=>({
                enable: true,
                border: true,
                maxSize: 1,
                shapeType: 'rectRound',
                position: 'rt',
                labelFontSize: 12,
                labelFontWeight: 400
            });
        const getDarkLegend = ()=>({
                ...getDefaultLegend(),
                labelColor: '#BBBDC3',
                pagerIconColor: '#89909D',
                pagerIconDisableColor: '#2A2D33'
            });
        const getLightLegend = ()=>({
                ...getDefaultLegend(),
                labelColor: '#606773',
                pagerIconColor: '#89909D',
                pagerIconDisableColor: '#F1F2F5'
            });
        const getDefaultTableConfig = ()=>({
                bodyFontSize: 12,
                bodyBackgroundColor: 'transparent',
                headerFontSize: 12
            });
        const getLightTableConfig = ()=>({
                ...getDefaultTableConfig(),
                borderColor: '#e3e5eb',
                bodyFontColor: '#141414',
                headerFontColor: '#21252c',
                headerBackgroundColor: '#f6f7f9',
                hoverBodyBackgroundColor: '#bedaff',
                hoverBodyInlineBackgroundColor: '#bedaff33',
                hoverHeaderBackgroundColor: '#D9DDE4',
                hoverHeaderInlineBackgroundColor: '#D9DDE455',
                selectedBorderColor: '#4080ff',
                selectedBackgroundColor: '#bedaff33',
                backgroundColor: 'transparent'
            });
        const getDarkTableConfig = ()=>({
                ...getDefaultTableConfig(),
                borderColor: '#4b4e53',
                bodyFontColor: '#fdfdfd',
                headerFontColor: '#fdfdfd',
                headerBackgroundColor: '#36393e',
                hoverBodyBackgroundColor: '#4284ff66',
                hoverBodyInlineBackgroundColor: '#4284ff10',
                hoverHeaderBackgroundColor: '#6f7984cc',
                hoverHeaderInlineBackgroundColor: '#4b4f54',
                selectedBorderColor: '#3073f2',
                selectedBackgroundColor: '#4284ff33'
            });
        const pickPivotChartGridConfig = (tableConfig)=>({
                outlineBorderLineWidth: 0,
                frameCornerRadius: 0,
                borderColor: tableConfig.borderColor,
                bodyFontColor: tableConfig.bodyFontColor,
                headerFontColor: tableConfig.headerFontColor,
                headerBackgroundColor: 'transparent',
                hoverHeaderBackgroundColor: tableConfig.hoverHeaderBackgroundColor,
                hoverHeaderInlineBackgroundColor: tableConfig.hoverHeaderInlineBackgroundColor,
                titleFontColor: tableConfig.headerFontColor,
                titleFontSize: tableConfig.headerFontSize,
                titleFontWeight: 'bold'
            });
        const getLightPivotChartGridConfig = ()=>{
            const res = pickPivotChartGridConfig(getLightTableConfig());
            res.hoverHeaderInlineBackgroundColor = '#D9DDE446';
            res.chartGridColor = '#F0F1F6';
            res.axisLabelColor = '#BCC1CB';
            return res;
        };
        const getDarkPivotChartGridConfig = ()=>{
            const res = pickPivotChartGridConfig(getDarkTableConfig());
            res.hoverHeaderInlineBackgroundColor = '#4b4f5446';
            return res;
        };
        const getDefaultTooltip = ()=>({
                enable: true,
                borderRadius: 12,
                borderWidth: 1,
                padding: 7,
                lineHeight: 12,
                fontSize: 12,
                lineSpace: 6
            });
        const getLightTooltip = ()=>({
                ...getDefaultTooltip(),
                borderColor: '#e3e5e8',
                backgroundColor: '#fff',
                keyColor: '#606773',
                valueColor: '#21252c',
                titleColor: '#21252c'
            });
        const getDarkTooltip = ()=>({
                ...getDefaultTooltip(),
                borderColor: '#3c3f44',
                backgroundColor: '#2b2d30',
                keyColor: '#89909D',
                valueColor: '#E2E3E6',
                titleColor: '#E2E3E6'
            });
        const getLightLinearAxis = ()=>({
                nice: true,
                zero: true,
                inverse: false,
                label: {
                    visible: true,
                    labelAngle: 0,
                    labelColor: '#8F959E',
                    labelFontSize: 12,
                    labelFontWeight: 400
                },
                title: {
                    visible: false,
                    titleText: '',
                    titleColor: '#606773',
                    titleFontSize: 12,
                    titleFontWeight: 400
                },
                grid: {
                    visible: true,
                    gridColor: '#E3E5EB',
                    gridWidth: 0.5,
                    gridLineDash: [
                        4,
                        2
                    ]
                },
                tick: {
                    visible: false,
                    tickInside: false,
                    tickSize: 4,
                    tickColor: '#E3E5EB'
                },
                line: {
                    visible: false,
                    lineColor: '#E3E5EB',
                    lineWidth: 1
                }
            });
        const getLightBandAxis = ()=>({
                labelAutoHide: true,
                labelAutoHideGap: 4,
                labelAutoLimit: true,
                labelAutoLimitLength: 80,
                labelAutoRotate: false,
                labelAutoRotateAngleRange: [
                    0,
                    -45,
                    -90
                ],
                label: {
                    visible: true,
                    labelAngle: 0,
                    labelColor: '#8F959E',
                    labelFontSize: 12,
                    labelFontWeight: 400
                },
                title: {
                    visible: false,
                    titleText: '',
                    titleColor: '#606773',
                    titleFontSize: 12,
                    titleFontWeight: 400
                },
                grid: {
                    visible: false,
                    gridColor: '#E3E5EB',
                    gridWidth: 0.5,
                    gridLineDash: [
                        4,
                        2
                    ]
                },
                tick: {
                    visible: false,
                    tickInside: false,
                    tickSize: 4,
                    tickColor: '#E3E5EB'
                },
                line: {
                    visible: true,
                    lineColor: '#E3E5EB',
                    lineWidth: 1
                }
            });
        const getDarkLinearAxis = ()=>({
                nice: true,
                zero: true,
                label: {
                    visible: true,
                    labelAngle: 0,
                    labelColor: '#888C93',
                    labelFontSize: 12,
                    labelFontWeight: 400
                },
                title: {
                    visible: false,
                    titleText: '',
                    titleColor: '#BBBDC3',
                    titleFontSize: 12,
                    titleFontWeight: 400
                },
                grid: {
                    visible: true,
                    gridColor: '#303339',
                    gridWidth: 0.5,
                    gridLineDash: [
                        4,
                        2
                    ]
                },
                tick: {
                    visible: false,
                    tickInside: false,
                    tickSize: 4,
                    tickColor: '#303339'
                },
                line: {
                    visible: false,
                    lineColor: '#303339',
                    lineWidth: 1
                }
            });
        const getDarkBandAxis = ()=>({
                labelAutoHide: true,
                labelAutoHideGap: 4,
                labelAutoLimit: true,
                labelAutoLimitLength: 80,
                labelAutoRotate: false,
                labelAutoRotateAngleRange: [
                    0,
                    -45,
                    -90
                ],
                label: {
                    visible: true,
                    labelAngle: 0,
                    labelColor: '#888C93',
                    labelFontSize: 12,
                    labelFontWeight: 400
                },
                title: {
                    visible: false,
                    titleText: '',
                    titleColor: '#BBBDC3',
                    titleFontSize: 12,
                    titleFontWeight: 400
                },
                grid: {
                    visible: false,
                    gridColor: '#303339',
                    gridWidth: 0.5,
                    gridLineDash: [
                        4,
                        2
                    ]
                },
                tick: {
                    visible: false,
                    tickInside: false,
                    tickSize: 4,
                    tickColor: '#303339'
                },
                line: {
                    visible: true,
                    lineColor: '#303339',
                    lineWidth: 1
                }
            });
        const getDefaultAnnotationPoint = ()=>({
                textBackgroundVisible: true,
                textFontSize: 12,
                textFontWeight: 400,
                textBackgroundBorderRadius: 0,
                textBackgroundBorderWidth: 1,
                textBackgroundPadding: 2
            });
        const getLightAnnotationPoint = ()=>({
                ...getDefaultAnnotationPoint(),
                textColor: '#ffffff',
                textBackgroundColor: '#BCC1CB',
                textBackgroundBorderColor: '#BCC1CB'
            });
        const getDefaultAnnotationLine = ()=>({
                lineVisible: true,
                lineWidth: 1,
                lineStyle: 'solid',
                textFontSize: 12,
                textFontWeight: 400,
                startSymbolVisible: true,
                endSymbolVisible: false,
                textBackgroundVisible: true,
                textBackgroundBorderWidth: 1,
                textBackgroundBorderRadius: 0,
                textBackgroundPadding: 2
            });
        const getLightAnnotationHorizontalLine = ()=>({
                ...getDefaultAnnotationLine(),
                lineColor: '#BCC1CB',
                textColor: '#ffffff',
                textBackgroundColor: '#BCC1CB',
                textBackgroundBorderColor: '#BCC1CB'
            });
        const getLightAnnotationVerticalLine = ()=>getLightAnnotationHorizontalLine();
        const getDefaultAnnotationArea = ()=>({
                textFontSize: 12,
                textFontWeight: 400,
                textBackgroundVisible: true,
                textBackgroundBorderWidth: 1,
                textBackgroundBorderRadius: 0,
                textBackgroundPadding: 2,
                areaBorderWidth: 0,
                areaBorderRadius: 0,
                areaLineDash: [
                    2,
                    2
                ],
                outerPadding: 4
            });
        const getLightAnnotationArea = ()=>({
                ...getDefaultAnnotationArea(),
                textColor: '#ffffff',
                textBackgroundColor: '#BCC1CB',
                textBackgroundBorderColor: '#BCC1CB',
                areaColor: '#BCC1CB',
                areaColorOpacity: 0.12,
                areaBorderColor: '#BCC1CB'
            });
        const getLightAnnotation = ()=>({
                annotationPoint: getLightAnnotationPoint(),
                annotationHorizontalLine: getLightAnnotationHorizontalLine(),
                annotationVerticalLine: getLightAnnotationVerticalLine(),
                annotationArea: getLightAnnotationArea()
            });
        const getDarkAnnotationPoint = ()=>({
                ...getDefaultAnnotationPoint(),
                textColor: '#E2E3E6',
                textBackgroundColor: '#55595F',
                textBackgroundBorderColor: '#55595F'
            });
        const getDarkAnnotationHorizontalLine = ()=>({
                ...getDefaultAnnotationLine(),
                lineColor: '#55595F',
                textColor: '#E2E3E6',
                textBackgroundColor: '#55595F',
                textBackgroundBorderColor: '#55595F'
            });
        const getDarkAnnotationVerticalLine = ()=>getDarkAnnotationHorizontalLine();
        const getDarkAnnotationArea = ()=>({
                ...getDefaultAnnotationArea(),
                textColor: '#E2E3E6',
                textBackgroundColor: '#55595F',
                textBackgroundBorderColor: '#55595F',
                areaColor: '#E2E3E6',
                areaColorOpacity: 0.15,
                areaBorderColor: '#E2E3E6'
            });
        const getDarkAnnotation = ()=>({
                annotationPoint: getDarkAnnotationPoint(),
                annotationHorizontalLine: getDarkAnnotationHorizontalLine(),
                annotationVerticalLine: getDarkAnnotationVerticalLine(),
                annotationArea: getDarkAnnotationArea()
            });
        const getLightFunnelTransformTheme = ()=>({
                backgroundColor: '#F6F7F9',
                textColor: '#737880'
            });
        const getDarkFunnelTransformTheme = ()=>({
                backgroundColor: '#2A2D33',
                textColor: '#888C93'
            });
        const getLightHeatmapCellTheme = ()=>({
                stroke: '#fff'
            });
        const getDarkHeatmapCellTheme = ()=>({
                stroke: '#404349'
            });
        const getDefaultRegressionLine = ()=>({
                lineWidth: 2,
                textFontSize: 12,
                textFontWeight: 400
            });
        const getLightRegressionLine = ()=>({
                kdeRegressionLine: {
                    ...getDefaultRegressionLine(),
                    textColor: '#364159'
                },
                ecdfRegressionLine: {
                    ...getDefaultRegressionLine(),
                    textColor: '#364159'
                },
                linearRegressionLine: {
                    ...getDefaultRegressionLine(),
                    textColor: '#364159',
                    confidenceIntervalOpacity: 0.2
                },
                lowessRegressionLine: {
                    ...getDefaultRegressionLine(),
                    textColor: '#364159',
                    confidenceIntervalOpacity: 0.2
                },
                polynomialRegressionLine: {
                    ...getDefaultRegressionLine(),
                    textColor: '#364159',
                    confidenceIntervalOpacity: 0.2
                },
                logisticRegressionLine: {
                    ...getDefaultRegressionLine(),
                    textColor: '#364159',
                    confidenceIntervalOpacity: 0.2
                }
            });
        const getDarkRegressionLine = ()=>({
                kdeRegressionLine: {
                    ...getDefaultRegressionLine(),
                    textColor: '#FFFFFF'
                },
                ecdfRegressionLine: {
                    ...getDefaultRegressionLine(),
                    textColor: '#FFFFFF'
                },
                linearRegressionLine: {
                    ...getDefaultRegressionLine(),
                    textColor: '#FFFFFF',
                    confidenceIntervalOpacity: 0.2
                },
                lowessRegressionLine: {
                    ...getDefaultRegressionLine(),
                    textColor: '#FFFFFF',
                    confidenceIntervalOpacity: 0.2
                },
                polynomialRegressionLine: {
                    ...getDefaultRegressionLine(),
                    textColor: '#FFFFFF',
                    confidenceIntervalOpacity: 0.2
                },
                logisticRegressionLine: {
                    ...getDefaultRegressionLine(),
                    textColor: '#FFFFFF',
                    confidenceIntervalOpacity: 0.2
                }
            });
        const getLightBoxPlotStyle = ()=>({
                boxBorderColor: '#e3e5eb'
            });
        const getDarkBoxPlotStyle = ()=>({
                boxBorderColor: '#4b4e53'
            });
        const getLightOutlierStyle = ()=>({
                pointColor: '#8F959E'
            });
        const getDarkOutlierStyle = ()=>({
                pointColor: '#36393e'
            });
        const lightTheme = ()=>{
            const linearAxis = getLightLinearAxis();
            const bandAxis = getLightBandAxis();
            const barBandAxis = {
                ...bandAxis,
                labelAutoHide: false,
                labelAutoHideGap: 1,
                labelAutoLimit: false,
                labelAutoLimitLength: void 0,
                labelAutoRotate: false,
                labelAutoRotateAngleRange: [
                    0,
                    -45,
                    -90
                ]
            };
            const crosshairLine = getLightCrosshairLine();
            const crosshairRect = getLightCrosshairRect();
            const baseConfig = {
                backgroundColor: 'transparent',
                color: getLightColor(),
                label: getLightLabel(),
                legend: getLightLegend(),
                tooltip: getLightTooltip()
            };
            const tableConfig = getLightTableConfig();
            return {
                config: {
                    table: tableConfig,
                    pivotTable: tableConfig,
                    line: {
                        ...baseConfig,
                        xAxis: bandAxis,
                        yAxis: linearAxis,
                        crosshairLine,
                        pivotGrid: getLightPivotChartGridConfig(),
                        annotation: getLightAnnotation()
                    },
                    column: {
                        ...baseConfig,
                        xAxis: bandAxis,
                        yAxis: linearAxis,
                        crosshairRect,
                        stackCornerRadius: [
                            4,
                            4,
                            0,
                            0
                        ],
                        pivotGrid: getLightPivotChartGridConfig(),
                        annotation: getLightAnnotation(),
                        regressionLine: getLightRegressionLine()
                    },
                    columnParallel: {
                        ...baseConfig,
                        xAxis: bandAxis,
                        yAxis: linearAxis,
                        crosshairRect,
                        stackCornerRadius: [
                            4,
                            4,
                            0,
                            0
                        ],
                        pivotGrid: getLightPivotChartGridConfig(),
                        annotation: getLightAnnotation()
                    },
                    columnPercent: {
                        ...baseConfig,
                        xAxis: bandAxis,
                        yAxis: {
                            ...linearAxis
                        },
                        crosshairRect,
                        stackCornerRadius: [
                            4,
                            4,
                            0,
                            0
                        ],
                        pivotGrid: getLightPivotChartGridConfig(),
                        annotation: getLightAnnotation()
                    },
                    bar: {
                        ...baseConfig,
                        xAxis: linearAxis,
                        yAxis: barBandAxis,
                        crosshairRect,
                        stackCornerRadius: [
                            0,
                            4,
                            4,
                            0
                        ],
                        pivotGrid: getLightPivotChartGridConfig(),
                        annotation: getLightAnnotation()
                    },
                    barParallel: {
                        ...baseConfig,
                        xAxis: linearAxis,
                        yAxis: barBandAxis,
                        crosshairRect,
                        stackCornerRadius: [
                            0,
                            4,
                            4,
                            0
                        ],
                        pivotGrid: getLightPivotChartGridConfig(),
                        annotation: getLightAnnotation()
                    },
                    barPercent: {
                        ...baseConfig,
                        xAxis: {
                            ...linearAxis
                        },
                        yAxis: barBandAxis,
                        crosshairRect,
                        stackCornerRadius: [
                            0,
                            4,
                            4,
                            0
                        ],
                        pivotGrid: getLightPivotChartGridConfig(),
                        annotation: getLightAnnotation()
                    },
                    area: {
                        ...baseConfig,
                        xAxis: bandAxis,
                        yAxis: linearAxis,
                        crosshairLine,
                        pivotGrid: getLightPivotChartGridConfig(),
                        annotation: getLightAnnotation()
                    },
                    areaPercent: {
                        ...baseConfig,
                        xAxis: bandAxis,
                        yAxis: {
                            ...linearAxis
                        },
                        crosshairLine,
                        pivotGrid: getLightPivotChartGridConfig(),
                        annotation: getLightAnnotation()
                    },
                    scatter: {
                        ...baseConfig,
                        crosshairLine,
                        sizeRange: [
                            8,
                            24
                        ],
                        xAxis: {
                            ...linearAxis,
                            line: {
                                ...linearAxis.line,
                                visible: true
                            }
                        },
                        yAxis: {
                            ...linearAxis,
                            line: {
                                ...linearAxis.line,
                                visible: true
                            }
                        },
                        label: {
                            ...baseConfig.label,
                            showValue: false,
                            showValuePercent: false
                        },
                        pivotGrid: getLightPivotChartGridConfig(),
                        annotation: getLightAnnotation(),
                        regressionLine: getLightRegressionLine()
                    },
                    dualAxis: {
                        ...baseConfig,
                        xAxis: bandAxis,
                        primaryYAxis: linearAxis,
                        secondaryYAxis: {
                            ...linearAxis,
                            grid: {
                                visible: false
                            }
                        },
                        dualChartType: {
                            primary: 'column',
                            secondary: 'line'
                        },
                        crosshairRect,
                        pivotGrid: getLightPivotChartGridConfig(),
                        annotation: getLightAnnotation()
                    },
                    pie: {
                        ...baseConfig,
                        label: {
                            ...baseConfig.label,
                            showValuePercent: true,
                            labelLayout: 'arc',
                            showDimension: true
                        },
                        pivotGrid: getLightPivotChartGridConfig()
                    },
                    donut: {
                        ...baseConfig,
                        label: {
                            ...baseConfig.label,
                            showValuePercent: true,
                            labelLayout: 'arc',
                            showDimension: true
                        },
                        pivotGrid: getLightPivotChartGridConfig()
                    },
                    radar: {
                        ...baseConfig,
                        pivotGrid: getLightPivotChartGridConfig()
                    },
                    rose: {
                        ...baseConfig,
                        label: {
                            ...baseConfig.label,
                            showValuePercent: true,
                            showDimension: true
                        },
                        pivotGrid: getLightPivotChartGridConfig()
                    },
                    roseParallel: {
                        ...baseConfig,
                        label: {
                            ...baseConfig.label,
                            showValuePercent: true,
                            showDimension: true
                        },
                        pivotGrid: getLightPivotChartGridConfig()
                    },
                    funnel: {
                        ...baseConfig,
                        transform: getLightFunnelTransformTheme(),
                        pivotGrid: getLightPivotChartGridConfig()
                    },
                    heatmap: {
                        ...baseConfig,
                        label: {
                            ...baseConfig.label,
                            labelColorSmartInvert: true
                        },
                        cell: getLightHeatmapCellTheme(),
                        pivotGrid: getLightPivotChartGridConfig()
                    },
                    histogram: {
                        ...baseConfig,
                        xAxis: linearAxis,
                        yAxis: linearAxis,
                        crosshairRect,
                        pivotGrid: getLightPivotChartGridConfig(),
                        annotation: getLightAnnotation(),
                        regressionLine: getLightRegressionLine()
                    },
                    boxPlot: {
                        ...baseConfig,
                        xAxis: linearAxis,
                        yAxis: linearAxis,
                        crosshairRect,
                        pivotGrid: getLightPivotChartGridConfig(),
                        annotation: getLightAnnotation(),
                        boxPlotStyle: getLightBoxPlotStyle(),
                        outlierStyle: getLightOutlierStyle()
                    }
                }
            };
        };
        const darkTheme = ()=>{
            const linearAxis = getDarkLinearAxis();
            const bandAxis = getDarkBandAxis();
            const barBandAxis = {
                ...bandAxis,
                labelAutoHide: false,
                labelAutoHideGap: 1,
                labelAutoLimit: false,
                labelAutoLimitLength: void 0,
                labelAutoRotate: false,
                labelAutoRotateAngleRange: [
                    0,
                    -45,
                    -90
                ]
            };
            const crosshairLine = getDarkCrosshairLine();
            const crosshairRect = getDarkCrosshairRect();
            const baseConfig = {
                backgroundColor: 'transparent',
                color: getDarkColor(),
                label: getDarkLabel(),
                legend: getDarkLegend(),
                tooltip: getDarkTooltip()
            };
            const tableConfig = getDarkTableConfig();
            return {
                config: {
                    table: tableConfig,
                    pivotTable: tableConfig,
                    line: {
                        ...baseConfig,
                        xAxis: bandAxis,
                        yAxis: linearAxis,
                        crosshairLine: crosshairLine,
                        pivotGrid: getDarkPivotChartGridConfig(),
                        annotation: getDarkAnnotation()
                    },
                    column: {
                        ...baseConfig,
                        xAxis: bandAxis,
                        yAxis: linearAxis,
                        crosshairRect: crosshairRect,
                        stackCornerRadius: [
                            4,
                            4,
                            0,
                            0
                        ],
                        pivotGrid: getDarkPivotChartGridConfig(),
                        annotation: getDarkAnnotation(),
                        regressionLine: getDarkRegressionLine()
                    },
                    columnParallel: {
                        ...baseConfig,
                        xAxis: bandAxis,
                        yAxis: linearAxis,
                        crosshairRect: crosshairRect,
                        stackCornerRadius: [
                            4,
                            4,
                            0,
                            0
                        ],
                        pivotGrid: getDarkPivotChartGridConfig(),
                        annotation: getDarkAnnotation()
                    },
                    columnPercent: {
                        ...baseConfig,
                        xAxis: bandAxis,
                        yAxis: linearAxis,
                        crosshairRect: crosshairRect,
                        stackCornerRadius: [
                            4,
                            4,
                            0,
                            0
                        ],
                        pivotGrid: getDarkPivotChartGridConfig(),
                        annotation: getDarkAnnotation()
                    },
                    bar: {
                        ...baseConfig,
                        xAxis: linearAxis,
                        yAxis: barBandAxis,
                        crosshairRect: crosshairRect,
                        stackCornerRadius: [
                            0,
                            4,
                            4,
                            0
                        ],
                        pivotGrid: getDarkPivotChartGridConfig(),
                        annotation: getDarkAnnotation()
                    },
                    barParallel: {
                        ...baseConfig,
                        xAxis: linearAxis,
                        yAxis: barBandAxis,
                        crosshairRect: crosshairRect,
                        stackCornerRadius: [
                            0,
                            4,
                            4,
                            0
                        ],
                        pivotGrid: getDarkPivotChartGridConfig(),
                        annotation: getDarkAnnotation()
                    },
                    barPercent: {
                        ...baseConfig,
                        xAxis: linearAxis,
                        yAxis: barBandAxis,
                        crosshairRect: crosshairRect,
                        stackCornerRadius: [
                            0,
                            4,
                            4,
                            0
                        ],
                        pivotGrid: getDarkPivotChartGridConfig(),
                        annotation: getDarkAnnotation()
                    },
                    area: {
                        ...baseConfig,
                        xAxis: bandAxis,
                        yAxis: linearAxis,
                        crosshairLine: crosshairLine,
                        pivotGrid: getDarkPivotChartGridConfig(),
                        annotation: getDarkAnnotation()
                    },
                    areaPercent: {
                        ...baseConfig,
                        xAxis: bandAxis,
                        yAxis: linearAxis,
                        crosshairLine: crosshairLine,
                        pivotGrid: getDarkPivotChartGridConfig(),
                        annotation: getDarkAnnotation()
                    },
                    scatter: {
                        ...baseConfig,
                        crosshairLine,
                        sizeRange: [
                            8,
                            24
                        ],
                        xAxis: {
                            ...linearAxis,
                            line: {
                                ...linearAxis.line,
                                visible: true
                            }
                        },
                        yAxis: {
                            ...linearAxis,
                            line: {
                                ...linearAxis.line,
                                visible: true
                            }
                        },
                        label: {
                            ...baseConfig.label,
                            showValue: false,
                            showValuePercent: false
                        },
                        pivotGrid: getDarkPivotChartGridConfig(),
                        annotation: getDarkAnnotation(),
                        regressionLine: getDarkRegressionLine()
                    },
                    dualAxis: {
                        ...baseConfig,
                        xAxis: bandAxis,
                        primaryYAxis: linearAxis,
                        secondaryYAxis: {
                            ...linearAxis,
                            grid: {
                                visible: false
                            }
                        },
                        dualChartType: {
                            primary: 'column',
                            secondary: 'line'
                        },
                        crosshairRect,
                        pivotGrid: getDarkPivotChartGridConfig(),
                        annotation: getDarkAnnotation()
                    },
                    pie: {
                        ...baseConfig,
                        label: {
                            ...baseConfig.label,
                            showValuePercent: true,
                            labelLayout: 'arc',
                            showDimension: true
                        },
                        pivotGrid: getDarkPivotChartGridConfig()
                    },
                    donut: {
                        ...baseConfig,
                        label: {
                            ...baseConfig.label,
                            showValuePercent: true,
                            labelLayout: 'arc',
                            showDimension: true
                        },
                        pivotGrid: getDarkPivotChartGridConfig()
                    },
                    radar: {
                        ...baseConfig,
                        pivotGrid: getDarkPivotChartGridConfig()
                    },
                    rose: {
                        ...baseConfig,
                        label: {
                            ...baseConfig.label,
                            showValuePercent: true,
                            showDimension: true
                        },
                        pivotGrid: getDarkPivotChartGridConfig()
                    },
                    roseParallel: {
                        ...baseConfig,
                        label: {
                            ...baseConfig.label,
                            showValuePercent: true,
                            showDimension: true
                        },
                        pivotGrid: getDarkPivotChartGridConfig()
                    },
                    funnel: {
                        ...baseConfig,
                        transform: getDarkFunnelTransformTheme(),
                        pivotGrid: getDarkPivotChartGridConfig()
                    },
                    heatmap: {
                        ...baseConfig,
                        label: {
                            ...baseConfig.label,
                            labelColorSmartInvert: true
                        },
                        cell: getDarkHeatmapCellTheme(),
                        pivotGrid: getDarkPivotChartGridConfig()
                    },
                    histogram: {
                        ...baseConfig,
                        xAxis: linearAxis,
                        yAxis: linearAxis,
                        crosshairRect: crosshairRect,
                        pivotGrid: getDarkPivotChartGridConfig(),
                        annotation: getDarkAnnotation(),
                        regressionLine: getDarkRegressionLine()
                    },
                    boxPlot: {
                        ...baseConfig,
                        xAxis: bandAxis,
                        yAxis: linearAxis,
                        crosshairRect: crosshairRect,
                        pivotGrid: getDarkPivotChartGridConfig(),
                        annotation: getDarkAnnotation(),
                        boxPlotStyle: getDarkBoxPlotStyle(),
                        outlierStyle: getDarkOutlierStyle()
                    }
                }
            };
        };
        const registerCustomTheme = (key, themeConfig)=>{
            const customTheme = 'function' == typeof themeConfig ? themeConfig({
                lightTheme: lightTheme(),
                darkTheme: darkTheme()
            }) : themeConfig;
            Builder._themeMap[key] = customTheme;
        };
        const registerLightTheme = ()=>{
            registerCustomTheme('light', lightTheme());
        };
        const registerDarkTheme = ()=>{
            registerCustomTheme('dark', darkTheme());
        };
        const registerAll = ()=>{
            registerTable();
            registerPivotTable();
            registerLine();
            registerColumn();
            registerColumnParallel();
            registerColumnPercent();
            registerBar();
            registerBarParallel();
            registerBarPercent();
            registerArea();
            registerAreaPercent();
            registerScatter();
            registerDualAxis();
            registerPie();
            registerDonut();
            registerRose();
            registerRoseParallel();
            registerRadar();
            registerFunnel();
            registerHeatmap();
            registerBoxPlot();
            registerHistogram();
            registerLightTheme();
            registerDarkTheme();
        };
        const updateAdvanced = (chartType, advancedPipe)=>{
            Builder._customAdvancedPipe[chartType] = advancedPipe;
        };
        const updateSpec = (chartType, specPipe)=>{
            Builder._customSpecPipe[chartType] = specPipe;
        };
        Object.freeze({
            status: "aborted"
        });
        function $constructor(name, initializer, params) {
            function init(inst, def) {
                var _a;
                Object.defineProperty(inst, "_zod", {
                    value: inst._zod ?? {},
                    enumerable: false
                });
                (_a = inst._zod).traits ?? (_a.traits = new Set());
                inst._zod.traits.add(name);
                initializer(inst, def);
                for(const k in _.prototype)if (!(k in inst)) Object.defineProperty(inst, k, {
                    value: _.prototype[k].bind(inst)
                });
                inst._zod.constr = _;
                inst._zod.def = def;
            }
            const Parent = params?.Parent ?? Object;
            class Definition extends Parent {
            }
            Object.defineProperty(Definition, "name", {
                value: name
            });
            function _(def) {
                var _a;
                const inst = params?.Parent ? new Definition() : this;
                init(inst, def);
                (_a = inst._zod).deferred ?? (_a.deferred = []);
                for (const fn of inst._zod.deferred)fn();
                return inst;
            }
            Object.defineProperty(_, "init", {
                value: init
            });
            Object.defineProperty(_, Symbol.hasInstance, {
                value: (inst)=>{
                    if (params?.Parent && inst instanceof params.Parent) return true;
                    return inst?._zod?.traits?.has(name);
                }
            });
            Object.defineProperty(_, "name", {
                value: name
            });
            return _;
        }
        Symbol("zod_brand");
        class $ZodAsyncError extends Error {
            constructor(){
                super("Encountered Promise during synchronous parse. Use .parseAsync() instead.");
            }
        }
        const globalConfig = {};
        function core_config(newConfig) {
            if (newConfig) Object.assign(globalConfig, newConfig);
            return globalConfig;
        }
        const cuid = /^[cC][^\s-]{8,}$/;
        const cuid2 = /^[0-9a-z]+$/;
        const ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
        const xid = /^[0-9a-vA-V]{20}$/;
        const ksuid = /^[A-Za-z0-9]{27}$/;
        const nanoid = /^[a-zA-Z0-9_-]{21}$/;
        const duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
        const guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
        const uuid = (version)=>{
            if (!version) return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/;
            return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
        };
        const email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
        const _emoji = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
        function emoji() {
            return new RegExp(_emoji, "u");
        }
        const ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
        const ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/;
        const cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
        const cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
        const regexes_base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
        const base64url = /^[A-Za-z0-9_-]*$/;
        const hostname = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
        const e164 = /^\+(?:[0-9]){6,14}[0-9]$/;
        const dateSource = "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))";
        const date = /*@__PURE__*/ new RegExp(`^${dateSource}$`);
        function timeSource(args) {
            const hhmm = "(?:[01]\\d|2[0-3]):[0-5]\\d";
            const regex = "number" == typeof args.precision ? -1 === args.precision ? `${hhmm}` : 0 === args.precision ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
            return regex;
        }
        function regexes_time(args) {
            return new RegExp(`^${timeSource(args)}$`);
        }
        function datetime(args) {
            const time = timeSource({
                precision: args.precision
            });
            const opts = [
                "Z"
            ];
            if (args.local) opts.push("");
            if (args.offset) opts.push("([+-](?:[01]\\d|2[0-3]):[0-5]\\d)");
            const timeRegex = `${time}(?:${opts.join("|")})`;
            return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
        }
        const string = (params)=>{
            const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : "[\\s\\S]*";
            return new RegExp(`^${regex}$`);
        };
        const integer = /^\d+$/;
        const number = /^-?\d+(?:\.\d+)?/i;
        const regexes_boolean = /true|false/i;
        const _undefined = /undefined/i;
        const lowercase = /^[^A-Z]*$/;
        const uppercase = /^[^a-z]*$/;
        function getEnumValues(entries) {
            const numericValues = Object.values(entries).filter((v)=>"number" == typeof v);
            const values = Object.entries(entries).filter(([k, _])=>-1 === numericValues.indexOf(+k)).map(([_, v])=>v);
            return values;
        }
        function jsonStringifyReplacer(_, value) {
            if ("bigint" == typeof value) return value.toString();
            return value;
        }
        function cached(getter) {
            const set = false;
            return {
                get value () {
                    if (!set) {
                        const value = getter();
                        Object.defineProperty(this, "value", {
                            value
                        });
                        return value;
                    }
                    throw new Error("cached value already set");
                }
            };
        }
        function nullish(input) {
            return null == input;
        }
        function cleanRegex(source) {
            const start = source.startsWith("^") ? 1 : 0;
            const end = source.endsWith("$") ? source.length - 1 : source.length;
            return source.slice(start, end);
        }
        function floatSafeRemainder(val, step) {
            const valDecCount = (val.toString().split(".")[1] || "").length;
            const stepString = step.toString();
            let stepDecCount = (stepString.split(".")[1] || "").length;
            if (0 === stepDecCount && /\d?e-\d?/.test(stepString)) {
                const match = stepString.match(/\d?e-(\d?)/);
                if (match?.[1]) stepDecCount = Number.parseInt(match[1]);
            }
            const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
            const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
            const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
            return valInt % stepInt / 10 ** decCount;
        }
        const EVALUATING = Symbol("evaluating");
        function defineLazy(object, key, getter) {
            let value;
            Object.defineProperty(object, key, {
                get () {
                    if (value === EVALUATING) return;
                    if (void 0 === value) {
                        value = EVALUATING;
                        value = getter();
                    }
                    return value;
                },
                set (v) {
                    Object.defineProperty(object, key, {
                        value: v
                    });
                },
                configurable: true
            });
        }
        function assignProp(target, prop, value) {
            Object.defineProperty(target, prop, {
                value,
                writable: true,
                enumerable: true,
                configurable: true
            });
        }
        function mergeDefs(...defs) {
            const mergedDescriptors = {};
            for (const def of defs){
                const descriptors = Object.getOwnPropertyDescriptors(def);
                Object.assign(mergedDescriptors, descriptors);
            }
            return Object.defineProperties({}, mergedDescriptors);
        }
        function esc(str) {
            return JSON.stringify(str);
        }
        const captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args)=>{};
        function util_isObject(data) {
            return "object" == typeof data && null !== data && !Array.isArray(data);
        }
        const util_allowsEval = cached(()=>{
            if ("undefined" != typeof navigator && navigator?.userAgent?.includes("Cloudflare")) return false;
            try {
                const F = Function;
                new F("");
                return true;
            } catch (_) {
                return false;
            }
        });
        function util_isPlainObject(o) {
            if (false === util_isObject(o)) return false;
            const ctor = o.constructor;
            if (void 0 === ctor) return true;
            const prot = ctor.prototype;
            if (false === util_isObject(prot)) return false;
            if (false === Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf")) return false;
            return true;
        }
        const propertyKeyTypes = new Set([
            "string",
            "number",
            "symbol"
        ]);
        new Set([
            "string",
            "number",
            "bigint",
            "boolean",
            "symbol",
            "undefined"
        ]);
        function escapeRegex(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        }
        function clone(inst, def, params) {
            const cl = new inst._zod.constr(def ?? inst._zod.def);
            if (!def || params?.parent) cl._zod.parent = inst;
            return cl;
        }
        function normalizeParams(_params) {
            const params = _params;
            if (!params) return {};
            if ("string" == typeof params) return {
                error: ()=>params
            };
            if (params?.message !== void 0) {
                if (params?.error !== void 0) throw new Error("Cannot specify both `message` and `error` params");
                params.error = params.message;
            }
            delete params.message;
            if ("string" == typeof params.error) return {
                ...params,
                error: ()=>params.error
            };
            return params;
        }
        function optionalKeys(shape) {
            return Object.keys(shape).filter((k)=>"optional" === shape[k]._zod.optin && "optional" === shape[k]._zod.optout);
        }
        const NUMBER_FORMAT_RANGES = {
            safeint: [
                Number.MIN_SAFE_INTEGER,
                Number.MAX_SAFE_INTEGER
            ],
            int32: [
                -2147483648,
                2147483647
            ],
            uint32: [
                0,
                4294967295
            ],
            float32: [
                -3.4028234663852886e+38,
                3.4028234663852886e38
            ],
            float64: [
                -Number.MAX_VALUE,
                Number.MAX_VALUE
            ]
        };
        function pick(schema, mask) {
            const currDef = schema._zod.def;
            const def = mergeDefs(schema._zod.def, {
                get shape () {
                    const newShape = {};
                    for(const key in mask){
                        if (!(key in currDef.shape)) throw new Error(`Unrecognized key: "${key}"`);
                        if (mask[key]) newShape[key] = currDef.shape[key];
                    }
                    assignProp(this, "shape", newShape);
                    return newShape;
                },
                checks: []
            });
            return clone(schema, def);
        }
        function omit(schema, mask) {
            const currDef = schema._zod.def;
            const def = mergeDefs(schema._zod.def, {
                get shape () {
                    const newShape = {
                        ...schema._zod.def.shape
                    };
                    for(const key in mask){
                        if (!(key in currDef.shape)) throw new Error(`Unrecognized key: "${key}"`);
                        if (mask[key]) delete newShape[key];
                    }
                    assignProp(this, "shape", newShape);
                    return newShape;
                },
                checks: []
            });
            return clone(schema, def);
        }
        function extend(schema, shape) {
            if (!util_isPlainObject(shape)) throw new Error("Invalid input to extend: expected a plain object");
            const def = mergeDefs(schema._zod.def, {
                get shape () {
                    const _shape = {
                        ...schema._zod.def.shape,
                        ...shape
                    };
                    assignProp(this, "shape", _shape);
                    return _shape;
                },
                checks: []
            });
            return clone(schema, def);
        }
        function util_merge(a, b) {
            const def = mergeDefs(a._zod.def, {
                get shape () {
                    const _shape = {
                        ...a._zod.def.shape,
                        ...b._zod.def.shape
                    };
                    assignProp(this, "shape", _shape);
                    return _shape;
                },
                get catchall () {
                    return b._zod.def.catchall;
                },
                checks: []
            });
            return clone(a, def);
        }
        function partial(Class, schema, mask) {
            const def = mergeDefs(schema._zod.def, {
                get shape () {
                    const oldShape = schema._zod.def.shape;
                    const shape = {
                        ...oldShape
                    };
                    if (mask) for(const key in mask){
                        if (!(key in oldShape)) throw new Error(`Unrecognized key: "${key}"`);
                        if (mask[key]) shape[key] = Class ? new Class({
                            type: "optional",
                            innerType: oldShape[key]
                        }) : oldShape[key];
                    }
                    else for(const key in oldShape)shape[key] = Class ? new Class({
                        type: "optional",
                        innerType: oldShape[key]
                    }) : oldShape[key];
                    assignProp(this, "shape", shape);
                    return shape;
                },
                checks: []
            });
            return clone(schema, def);
        }
        function required(Class, schema, mask) {
            const def = mergeDefs(schema._zod.def, {
                get shape () {
                    const oldShape = schema._zod.def.shape;
                    const shape = {
                        ...oldShape
                    };
                    if (mask) for(const key in mask){
                        if (!(key in shape)) throw new Error(`Unrecognized key: "${key}"`);
                        if (mask[key]) shape[key] = new Class({
                            type: "nonoptional",
                            innerType: oldShape[key]
                        });
                    }
                    else for(const key in oldShape)shape[key] = new Class({
                        type: "nonoptional",
                        innerType: oldShape[key]
                    });
                    assignProp(this, "shape", shape);
                    return shape;
                },
                checks: []
            });
            return clone(schema, def);
        }
        function aborted(x, startIndex = 0) {
            for(let i = startIndex; i < x.issues.length; i++)if (x.issues[i]?.continue !== true) return true;
            return false;
        }
        function prefixIssues(path, issues) {
            return issues.map((iss)=>{
                var _a;
                (_a = iss).path ?? (_a.path = []);
                iss.path.unshift(path);
                return iss;
            });
        }
        function unwrapMessage(message) {
            return "string" == typeof message ? message : message?.message;
        }
        function finalizeIssue(iss, ctx, config) {
            const full = {
                ...iss,
                path: iss.path ?? []
            };
            if (!iss.message) {
                const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config.customError?.(iss)) ?? unwrapMessage(config.localeError?.(iss)) ?? "Invalid input";
                full.message = message;
            }
            delete full.inst;
            delete full.continue;
            if (!ctx?.reportInput) delete full.input;
            return full;
        }
        function getLengthableOrigin(input) {
            if (Array.isArray(input)) return "array";
            if ("string" == typeof input) return "string";
            return "unknown";
        }
        function util_issue(...args) {
            const [iss, input, inst] = args;
            if ("string" == typeof iss) return {
                message: iss,
                code: "custom",
                input,
                inst
            };
            return {
                ...iss
            };
        }
        const $ZodCheck = /*@__PURE__*/ $constructor("$ZodCheck", (inst, def)=>{
            var _a;
            inst._zod ?? (inst._zod = {});
            inst._zod.def = def;
            (_a = inst._zod).onattach ?? (_a.onattach = []);
        });
        const numericOriginMap = {
            number: "number",
            bigint: "bigint",
            object: "date"
        };
        const $ZodCheckLessThan = /*@__PURE__*/ $constructor("$ZodCheckLessThan", (inst, def)=>{
            $ZodCheck.init(inst, def);
            const origin = numericOriginMap[typeof def.value];
            inst._zod.onattach.push((inst)=>{
                const bag = inst._zod.bag;
                const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? 1 / 0;
                if (def.value < curr) if (def.inclusive) bag.maximum = def.value;
                else bag.exclusiveMaximum = def.value;
            });
            inst._zod.check = (payload)=>{
                if (def.inclusive ? payload.value <= def.value : payload.value < def.value) return;
                payload.issues.push({
                    origin,
                    code: "too_big",
                    maximum: def.value,
                    input: payload.value,
                    inclusive: def.inclusive,
                    inst,
                    continue: !def.abort
                });
            };
        });
        const $ZodCheckGreaterThan = /*@__PURE__*/ $constructor("$ZodCheckGreaterThan", (inst, def)=>{
            $ZodCheck.init(inst, def);
            const origin = numericOriginMap[typeof def.value];
            inst._zod.onattach.push((inst)=>{
                const bag = inst._zod.bag;
                const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? -1 / 0;
                if (def.value > curr) if (def.inclusive) bag.minimum = def.value;
                else bag.exclusiveMinimum = def.value;
            });
            inst._zod.check = (payload)=>{
                if (def.inclusive ? payload.value >= def.value : payload.value > def.value) return;
                payload.issues.push({
                    origin,
                    code: "too_small",
                    minimum: def.value,
                    input: payload.value,
                    inclusive: def.inclusive,
                    inst,
                    continue: !def.abort
                });
            };
        });
        const $ZodCheckMultipleOf = /*@__PURE__*/ $constructor("$ZodCheckMultipleOf", (inst, def)=>{
            $ZodCheck.init(inst, def);
            inst._zod.onattach.push((inst)=>{
                var _a;
                (_a = inst._zod.bag).multipleOf ?? (_a.multipleOf = def.value);
            });
            inst._zod.check = (payload)=>{
                if (typeof payload.value !== typeof def.value) throw new Error("Cannot mix number and bigint in multiple_of check.");
                const isMultiple = "bigint" == typeof payload.value ? payload.value % def.value === BigInt(0) : 0 === floatSafeRemainder(payload.value, def.value);
                if (isMultiple) return;
                payload.issues.push({
                    origin: typeof payload.value,
                    code: "not_multiple_of",
                    divisor: def.value,
                    input: payload.value,
                    inst,
                    continue: !def.abort
                });
            };
        });
        const $ZodCheckNumberFormat = /*@__PURE__*/ $constructor("$ZodCheckNumberFormat", (inst, def)=>{
            $ZodCheck.init(inst, def);
            def.format = def.format || "float64";
            const isInt = def.format?.includes("int");
            const origin = isInt ? "int" : "number";
            const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
            inst._zod.onattach.push((inst)=>{
                const bag = inst._zod.bag;
                bag.format = def.format;
                bag.minimum = minimum;
                bag.maximum = maximum;
                if (isInt) bag.pattern = integer;
            });
            inst._zod.check = (payload)=>{
                const input = payload.value;
                if (isInt) {
                    if (!Number.isInteger(input)) return void payload.issues.push({
                        expected: origin,
                        format: def.format,
                        code: "invalid_type",
                        continue: false,
                        input,
                        inst
                    });
                    if (!Number.isSafeInteger(input)) {
                        if (input > 0) payload.issues.push({
                            input,
                            code: "too_big",
                            maximum: Number.MAX_SAFE_INTEGER,
                            note: "Integers must be within the safe integer range.",
                            inst,
                            origin,
                            continue: !def.abort
                        });
                        else payload.issues.push({
                            input,
                            code: "too_small",
                            minimum: Number.MIN_SAFE_INTEGER,
                            note: "Integers must be within the safe integer range.",
                            inst,
                            origin,
                            continue: !def.abort
                        });
                        return;
                    }
                }
                if (input < minimum) payload.issues.push({
                    origin: "number",
                    input,
                    code: "too_small",
                    minimum,
                    inclusive: true,
                    inst,
                    continue: !def.abort
                });
                if (input > maximum) payload.issues.push({
                    origin: "number",
                    input,
                    code: "too_big",
                    maximum,
                    inst
                });
            };
        });
        const $ZodCheckMaxLength = /*@__PURE__*/ $constructor("$ZodCheckMaxLength", (inst, def)=>{
            var _a;
            $ZodCheck.init(inst, def);
            (_a = inst._zod.def).when ?? (_a.when = (payload)=>{
                const val = payload.value;
                return !nullish(val) && void 0 !== val.length;
            });
            inst._zod.onattach.push((inst)=>{
                const curr = inst._zod.bag.maximum ?? 1 / 0;
                if (def.maximum < curr) inst._zod.bag.maximum = def.maximum;
            });
            inst._zod.check = (payload)=>{
                const input = payload.value;
                const length = input.length;
                if (length <= def.maximum) return;
                const origin = getLengthableOrigin(input);
                payload.issues.push({
                    origin,
                    code: "too_big",
                    maximum: def.maximum,
                    inclusive: true,
                    input,
                    inst,
                    continue: !def.abort
                });
            };
        });
        const $ZodCheckMinLength = /*@__PURE__*/ $constructor("$ZodCheckMinLength", (inst, def)=>{
            var _a;
            $ZodCheck.init(inst, def);
            (_a = inst._zod.def).when ?? (_a.when = (payload)=>{
                const val = payload.value;
                return !nullish(val) && void 0 !== val.length;
            });
            inst._zod.onattach.push((inst)=>{
                const curr = inst._zod.bag.minimum ?? -1 / 0;
                if (def.minimum > curr) inst._zod.bag.minimum = def.minimum;
            });
            inst._zod.check = (payload)=>{
                const input = payload.value;
                const length = input.length;
                if (length >= def.minimum) return;
                const origin = getLengthableOrigin(input);
                payload.issues.push({
                    origin,
                    code: "too_small",
                    minimum: def.minimum,
                    inclusive: true,
                    input,
                    inst,
                    continue: !def.abort
                });
            };
        });
        const $ZodCheckLengthEquals = /*@__PURE__*/ $constructor("$ZodCheckLengthEquals", (inst, def)=>{
            var _a;
            $ZodCheck.init(inst, def);
            (_a = inst._zod.def).when ?? (_a.when = (payload)=>{
                const val = payload.value;
                return !nullish(val) && void 0 !== val.length;
            });
            inst._zod.onattach.push((inst)=>{
                const bag = inst._zod.bag;
                bag.minimum = def.length;
                bag.maximum = def.length;
                bag.length = def.length;
            });
            inst._zod.check = (payload)=>{
                const input = payload.value;
                const length = input.length;
                if (length === def.length) return;
                const origin = getLengthableOrigin(input);
                const tooBig = length > def.length;
                payload.issues.push({
                    origin,
                    ...tooBig ? {
                        code: "too_big",
                        maximum: def.length
                    } : {
                        code: "too_small",
                        minimum: def.length
                    },
                    inclusive: true,
                    exact: true,
                    input: payload.value,
                    inst,
                    continue: !def.abort
                });
            };
        });
        const $ZodCheckStringFormat = /*@__PURE__*/ $constructor("$ZodCheckStringFormat", (inst, def)=>{
            var _a, _b;
            $ZodCheck.init(inst, def);
            inst._zod.onattach.push((inst)=>{
                const bag = inst._zod.bag;
                bag.format = def.format;
                if (def.pattern) {
                    bag.patterns ?? (bag.patterns = new Set());
                    bag.patterns.add(def.pattern);
                }
            });
            if (def.pattern) (_a = inst._zod).check ?? (_a.check = (payload)=>{
                def.pattern.lastIndex = 0;
                if (def.pattern.test(payload.value)) return;
                payload.issues.push({
                    origin: "string",
                    code: "invalid_format",
                    format: def.format,
                    input: payload.value,
                    ...def.pattern ? {
                        pattern: def.pattern.toString()
                    } : {},
                    inst,
                    continue: !def.abort
                });
            });
            else (_b = inst._zod).check ?? (_b.check = ()=>{});
        });
        const $ZodCheckRegex = /*@__PURE__*/ $constructor("$ZodCheckRegex", (inst, def)=>{
            $ZodCheckStringFormat.init(inst, def);
            inst._zod.check = (payload)=>{
                def.pattern.lastIndex = 0;
                if (def.pattern.test(payload.value)) return;
                payload.issues.push({
                    origin: "string",
                    code: "invalid_format",
                    format: "regex",
                    input: payload.value,
                    pattern: def.pattern.toString(),
                    inst,
                    continue: !def.abort
                });
            };
        });
        const $ZodCheckLowerCase = /*@__PURE__*/ $constructor("$ZodCheckLowerCase", (inst, def)=>{
            def.pattern ?? (def.pattern = lowercase);
            $ZodCheckStringFormat.init(inst, def);
        });
        const $ZodCheckUpperCase = /*@__PURE__*/ $constructor("$ZodCheckUpperCase", (inst, def)=>{
            def.pattern ?? (def.pattern = uppercase);
            $ZodCheckStringFormat.init(inst, def);
        });
        const $ZodCheckIncludes = /*@__PURE__*/ $constructor("$ZodCheckIncludes", (inst, def)=>{
            $ZodCheck.init(inst, def);
            const escapedRegex = escapeRegex(def.includes);
            const pattern = new RegExp("number" == typeof def.position ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
            def.pattern = pattern;
            inst._zod.onattach.push((inst)=>{
                const bag = inst._zod.bag;
                bag.patterns ?? (bag.patterns = new Set());
                bag.patterns.add(pattern);
            });
            inst._zod.check = (payload)=>{
                if (payload.value.includes(def.includes, def.position)) return;
                payload.issues.push({
                    origin: "string",
                    code: "invalid_format",
                    format: "includes",
                    includes: def.includes,
                    input: payload.value,
                    inst,
                    continue: !def.abort
                });
            };
        });
        const $ZodCheckStartsWith = /*@__PURE__*/ $constructor("$ZodCheckStartsWith", (inst, def)=>{
            $ZodCheck.init(inst, def);
            const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
            def.pattern ?? (def.pattern = pattern);
            inst._zod.onattach.push((inst)=>{
                const bag = inst._zod.bag;
                bag.patterns ?? (bag.patterns = new Set());
                bag.patterns.add(pattern);
            });
            inst._zod.check = (payload)=>{
                if (payload.value.startsWith(def.prefix)) return;
                payload.issues.push({
                    origin: "string",
                    code: "invalid_format",
                    format: "starts_with",
                    prefix: def.prefix,
                    input: payload.value,
                    inst,
                    continue: !def.abort
                });
            };
        });
        const $ZodCheckEndsWith = /*@__PURE__*/ $constructor("$ZodCheckEndsWith", (inst, def)=>{
            $ZodCheck.init(inst, def);
            const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
            def.pattern ?? (def.pattern = pattern);
            inst._zod.onattach.push((inst)=>{
                const bag = inst._zod.bag;
                bag.patterns ?? (bag.patterns = new Set());
                bag.patterns.add(pattern);
            });
            inst._zod.check = (payload)=>{
                if (payload.value.endsWith(def.suffix)) return;
                payload.issues.push({
                    origin: "string",
                    code: "invalid_format",
                    format: "ends_with",
                    suffix: def.suffix,
                    input: payload.value,
                    inst,
                    continue: !def.abort
                });
            };
        });
        const $ZodCheckOverwrite = /*@__PURE__*/ $constructor("$ZodCheckOverwrite", (inst, def)=>{
            $ZodCheck.init(inst, def);
            inst._zod.check = (payload)=>{
                payload.value = def.tx(payload.value);
            };
        });
        class Doc {
            constructor(args = []){
                this.content = [];
                this.indent = 0;
                if (this) this.args = args;
            }
            indented(fn) {
                this.indent += 1;
                fn(this);
                this.indent -= 1;
            }
            write(arg) {
                if ("function" == typeof arg) {
                    arg(this, {
                        execution: "sync"
                    });
                    arg(this, {
                        execution: "async"
                    });
                    return;
                }
                const content = arg;
                const lines = content.split("\n").filter((x)=>x);
                const minIndent = Math.min(...lines.map((x)=>x.length - x.trimStart().length));
                const dedented = lines.map((x)=>x.slice(minIndent)).map((x)=>" ".repeat(2 * this.indent) + x);
                for (const line of dedented)this.content.push(line);
            }
            compile() {
                const F = Function;
                const args = this?.args;
                const content = this?.content ?? [
                    ""
                ];
                const lines = [
                    ...content.map((x)=>`  ${x}`)
                ];
                return new F(...args, lines.join("\n"));
            }
        }
        const errors_initializer = (inst, def)=>{
            inst.name = "$ZodError";
            Object.defineProperty(inst, "_zod", {
                value: inst._zod,
                enumerable: false
            });
            Object.defineProperty(inst, "issues", {
                value: def,
                enumerable: false
            });
            inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
            Object.defineProperty(inst, "toString", {
                value: ()=>inst.message,
                enumerable: false
            });
        };
        const $ZodError = $constructor("$ZodError", errors_initializer);
        const $ZodRealError = $constructor("$ZodError", errors_initializer, {
            Parent: Error
        });
        function flattenError(error, mapper = (issue)=>issue.message) {
            const fieldErrors = {};
            const formErrors = [];
            for (const sub of error.issues)if (sub.path.length > 0) {
                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
                fieldErrors[sub.path[0]].push(mapper(sub));
            } else formErrors.push(mapper(sub));
            return {
                formErrors,
                fieldErrors
            };
        }
        function formatError(error, _mapper) {
            const mapper = _mapper || function(issue) {
                return issue.message;
            };
            const fieldErrors = {
                _errors: []
            };
            const processError = (error)=>{
                for (const issue of error.issues)if ("invalid_union" === issue.code && issue.errors.length) issue.errors.map((issues)=>processError({
                        issues
                    }));
                else if ("invalid_key" === issue.code) processError({
                    issues: issue.issues
                });
                else if ("invalid_element" === issue.code) processError({
                    issues: issue.issues
                });
                else if (0 === issue.path.length) fieldErrors._errors.push(mapper(issue));
                else {
                    let curr = fieldErrors;
                    let i = 0;
                    while(i < issue.path.length){
                        const el = issue.path[i];
                        const terminal = i === issue.path.length - 1;
                        if (terminal) {
                            curr[el] = curr[el] || {
                                _errors: []
                            };
                            curr[el]._errors.push(mapper(issue));
                        } else curr[el] = curr[el] || {
                            _errors: []
                        };
                        curr = curr[el];
                        i++;
                    }
                }
            };
            processError(error);
            return fieldErrors;
        }
        const _parse = (_Err)=>(schema, value, _ctx, _params)=>{
                const ctx = _ctx ? Object.assign(_ctx, {
                    async: false
                }) : {
                    async: false
                };
                const result = schema._zod.run({
                    value,
                    issues: []
                }, ctx);
                if (result instanceof Promise) throw new $ZodAsyncError();
                if (result.issues.length) {
                    const e = new (_params?.Err ?? _Err)(result.issues.map((iss)=>finalizeIssue(iss, ctx, core_config())));
                    captureStackTrace(e, _params?.callee);
                    throw e;
                }
                return result.value;
            };
        const _parseAsync = (_Err)=>async (schema, value, _ctx, params)=>{
                const ctx = _ctx ? Object.assign(_ctx, {
                    async: true
                }) : {
                    async: true
                };
                let result = schema._zod.run({
                    value,
                    issues: []
                }, ctx);
                if (result instanceof Promise) result = await result;
                if (result.issues.length) {
                    const e = new (params?.Err ?? _Err)(result.issues.map((iss)=>finalizeIssue(iss, ctx, core_config())));
                    captureStackTrace(e, params?.callee);
                    throw e;
                }
                return result.value;
            };
        const _safeParse = (_Err)=>(schema, value, _ctx)=>{
                const ctx = _ctx ? {
                    ..._ctx,
                    async: false
                } : {
                    async: false
                };
                const result = schema._zod.run({
                    value,
                    issues: []
                }, ctx);
                if (result instanceof Promise) throw new $ZodAsyncError();
                return result.issues.length ? {
                    success: false,
                    error: new (_Err ?? $ZodError)(result.issues.map((iss)=>finalizeIssue(iss, ctx, core_config())))
                } : {
                    success: true,
                    data: result.value
                };
            };
        const safeParse = /* @__PURE__*/ _safeParse($ZodRealError);
        const _safeParseAsync = (_Err)=>async (schema, value, _ctx)=>{
                const ctx = _ctx ? Object.assign(_ctx, {
                    async: true
                }) : {
                    async: true
                };
                let result = schema._zod.run({
                    value,
                    issues: []
                }, ctx);
                if (result instanceof Promise) result = await result;
                return result.issues.length ? {
                    success: false,
                    error: new _Err(result.issues.map((iss)=>finalizeIssue(iss, ctx, core_config())))
                } : {
                    success: true,
                    data: result.value
                };
            };
        const safeParseAsync = /* @__PURE__*/ _safeParseAsync($ZodRealError);
        const versions_version = {
            major: 4,
            minor: 0,
            patch: 14
        };
        const $ZodType = /*@__PURE__*/ $constructor("$ZodType", (inst, def)=>{
            var _a;
            inst ?? (inst = {});
            inst._zod.def = def;
            inst._zod.bag = inst._zod.bag || {};
            inst._zod.version = versions_version;
            const checks = [
                ...inst._zod.def.checks ?? []
            ];
            if (inst._zod.traits.has("$ZodCheck")) checks.unshift(inst);
            for (const ch of checks)for (const fn of ch._zod.onattach)fn(inst);
            if (0 === checks.length) {
                (_a = inst._zod).deferred ?? (_a.deferred = []);
                inst._zod.deferred?.push(()=>{
                    inst._zod.run = inst._zod.parse;
                });
            } else {
                const runChecks = (payload, checks, ctx)=>{
                    let isAborted = aborted(payload);
                    let asyncResult;
                    for (const ch of checks){
                        if (ch._zod.def.when) {
                            const shouldRun = ch._zod.def.when(payload);
                            if (!shouldRun) continue;
                        } else if (isAborted) continue;
                        const currLen = payload.issues.length;
                        const _ = ch._zod.check(payload);
                        if (_ instanceof Promise && ctx?.async === false) throw new $ZodAsyncError();
                        if (asyncResult || _ instanceof Promise) asyncResult = (asyncResult ?? Promise.resolve()).then(async ()=>{
                            await _;
                            const nextLen = payload.issues.length;
                            if (nextLen === currLen) return;
                            if (!isAborted) isAborted = aborted(payload, currLen);
                        });
                        else {
                            const nextLen = payload.issues.length;
                            if (nextLen === currLen) continue;
                            if (!isAborted) isAborted = aborted(payload, currLen);
                        }
                    }
                    if (asyncResult) return asyncResult.then(()=>payload);
                    return payload;
                };
                inst._zod.run = (payload, ctx)=>{
                    const result = inst._zod.parse(payload, ctx);
                    if (result instanceof Promise) {
                        if (false === ctx.async) throw new $ZodAsyncError();
                        return result.then((result)=>runChecks(result, checks, ctx));
                    }
                    return runChecks(result, checks, ctx);
                };
            }
            inst["~standard"] = {
                validate: (value)=>{
                    try {
                        const r = safeParse(inst, value);
                        return r.success ? {
                            value: r.data
                        } : {
                            issues: r.error?.issues
                        };
                    } catch (_) {
                        return safeParseAsync(inst, value).then((r)=>r.success ? {
                                value: r.data
                            } : {
                                issues: r.error?.issues
                            });
                    }
                },
                vendor: "zod",
                version: 1
            };
        });
        const $ZodString = /*@__PURE__*/ $constructor("$ZodString", (inst, def)=>{
            $ZodType.init(inst, def);
            inst._zod.pattern = [
                ...inst?._zod.bag?.patterns ?? []
            ].pop() ?? string(inst._zod.bag);
            inst._zod.parse = (payload, _)=>{
                if (def.coerce) try {
                    payload.value = String(payload.value);
                } catch (_) {}
                if ("string" == typeof payload.value) return payload;
                payload.issues.push({
                    expected: "string",
                    code: "invalid_type",
                    input: payload.value,
                    inst
                });
                return payload;
            };
        });
        const $ZodStringFormat = /*@__PURE__*/ $constructor("$ZodStringFormat", (inst, def)=>{
            $ZodCheckStringFormat.init(inst, def);
            $ZodString.init(inst, def);
        });
        const $ZodGUID = /*@__PURE__*/ $constructor("$ZodGUID", (inst, def)=>{
            def.pattern ?? (def.pattern = guid);
            $ZodStringFormat.init(inst, def);
        });
        const $ZodUUID = /*@__PURE__*/ $constructor("$ZodUUID", (inst, def)=>{
            if (def.version) {
                const versionMap = {
                    v1: 1,
                    v2: 2,
                    v3: 3,
                    v4: 4,
                    v5: 5,
                    v6: 6,
                    v7: 7,
                    v8: 8
                };
                const v = versionMap[def.version];
                if (void 0 === v) throw new Error(`Invalid UUID version: "${def.version}"`);
                def.pattern ?? (def.pattern = uuid(v));
            } else def.pattern ?? (def.pattern = uuid());
            $ZodStringFormat.init(inst, def);
        });
        const $ZodEmail = /*@__PURE__*/ $constructor("$ZodEmail", (inst, def)=>{
            def.pattern ?? (def.pattern = email);
            $ZodStringFormat.init(inst, def);
        });
        const $ZodURL = /*@__PURE__*/ $constructor("$ZodURL", (inst, def)=>{
            $ZodStringFormat.init(inst, def);
            inst._zod.check = (payload)=>{
                try {
                    const trimmed = payload.value.trim();
                    const url = new URL(trimmed);
                    if (def.hostname) {
                        def.hostname.lastIndex = 0;
                        if (!def.hostname.test(url.hostname)) payload.issues.push({
                            code: "invalid_format",
                            format: "url",
                            note: "Invalid hostname",
                            pattern: hostname.source,
                            input: payload.value,
                            inst,
                            continue: !def.abort
                        });
                    }
                    if (def.protocol) {
                        def.protocol.lastIndex = 0;
                        if (!def.protocol.test(url.protocol.endsWith(":") ? url.protocol.slice(0, -1) : url.protocol)) payload.issues.push({
                            code: "invalid_format",
                            format: "url",
                            note: "Invalid protocol",
                            pattern: def.protocol.source,
                            input: payload.value,
                            inst,
                            continue: !def.abort
                        });
                    }
                    if (def.normalize) payload.value = url.href;
                    else payload.value = trimmed;
                    return;
                } catch (_) {
                    payload.issues.push({
                        code: "invalid_format",
                        format: "url",
                        input: payload.value,
                        inst,
                        continue: !def.abort
                    });
                }
            };
        });
        const $ZodEmoji = /*@__PURE__*/ $constructor("$ZodEmoji", (inst, def)=>{
            def.pattern ?? (def.pattern = emoji());
            $ZodStringFormat.init(inst, def);
        });
        const $ZodNanoID = /*@__PURE__*/ $constructor("$ZodNanoID", (inst, def)=>{
            def.pattern ?? (def.pattern = nanoid);
            $ZodStringFormat.init(inst, def);
        });
        const $ZodCUID = /*@__PURE__*/ $constructor("$ZodCUID", (inst, def)=>{
            def.pattern ?? (def.pattern = cuid);
            $ZodStringFormat.init(inst, def);
        });
        const $ZodCUID2 = /*@__PURE__*/ $constructor("$ZodCUID2", (inst, def)=>{
            def.pattern ?? (def.pattern = cuid2);
            $ZodStringFormat.init(inst, def);
        });
        const $ZodULID = /*@__PURE__*/ $constructor("$ZodULID", (inst, def)=>{
            def.pattern ?? (def.pattern = ulid);
            $ZodStringFormat.init(inst, def);
        });
        const $ZodXID = /*@__PURE__*/ $constructor("$ZodXID", (inst, def)=>{
            def.pattern ?? (def.pattern = xid);
            $ZodStringFormat.init(inst, def);
        });
        const $ZodKSUID = /*@__PURE__*/ $constructor("$ZodKSUID", (inst, def)=>{
            def.pattern ?? (def.pattern = ksuid);
            $ZodStringFormat.init(inst, def);
        });
        const $ZodISODateTime = /*@__PURE__*/ $constructor("$ZodISODateTime", (inst, def)=>{
            def.pattern ?? (def.pattern = datetime(def));
            $ZodStringFormat.init(inst, def);
        });
        const $ZodISODate = /*@__PURE__*/ $constructor("$ZodISODate", (inst, def)=>{
            def.pattern ?? (def.pattern = date);
            $ZodStringFormat.init(inst, def);
        });
        const $ZodISOTime = /*@__PURE__*/ $constructor("$ZodISOTime", (inst, def)=>{
            def.pattern ?? (def.pattern = regexes_time(def));
            $ZodStringFormat.init(inst, def);
        });
        const $ZodISODuration = /*@__PURE__*/ $constructor("$ZodISODuration", (inst, def)=>{
            def.pattern ?? (def.pattern = duration);
            $ZodStringFormat.init(inst, def);
        });
        const $ZodIPv4 = /*@__PURE__*/ $constructor("$ZodIPv4", (inst, def)=>{
            def.pattern ?? (def.pattern = ipv4);
            $ZodStringFormat.init(inst, def);
            inst._zod.onattach.push((inst)=>{
                const bag = inst._zod.bag;
                bag.format = "ipv4";
            });
        });
        const $ZodIPv6 = /*@__PURE__*/ $constructor("$ZodIPv6", (inst, def)=>{
            def.pattern ?? (def.pattern = ipv6);
            $ZodStringFormat.init(inst, def);
            inst._zod.onattach.push((inst)=>{
                const bag = inst._zod.bag;
                bag.format = "ipv6";
            });
            inst._zod.check = (payload)=>{
                try {
                    new URL(`http://[${payload.value}]`);
                } catch  {
                    payload.issues.push({
                        code: "invalid_format",
                        format: "ipv6",
                        input: payload.value,
                        inst,
                        continue: !def.abort
                    });
                }
            };
        });
        const $ZodCIDRv4 = /*@__PURE__*/ $constructor("$ZodCIDRv4", (inst, def)=>{
            def.pattern ?? (def.pattern = cidrv4);
            $ZodStringFormat.init(inst, def);
        });
        const $ZodCIDRv6 = /*@__PURE__*/ $constructor("$ZodCIDRv6", (inst, def)=>{
            def.pattern ?? (def.pattern = cidrv6);
            $ZodStringFormat.init(inst, def);
            inst._zod.check = (payload)=>{
                const [address, prefix] = payload.value.split("/");
                try {
                    if (!prefix) throw new Error();
                    const prefixNum = Number(prefix);
                    if (`${prefixNum}` !== prefix) throw new Error();
                    if (prefixNum < 0 || prefixNum > 128) throw new Error();
                    new URL(`http://[${address}]`);
                } catch  {
                    payload.issues.push({
                        code: "invalid_format",
                        format: "cidrv6",
                        input: payload.value,
                        inst,
                        continue: !def.abort
                    });
                }
            };
        });
        function isValidBase64(data) {
            if ("" === data) return true;
            if (data.length % 4 !== 0) return false;
            try {
                atob(data);
                return true;
            } catch  {
                return false;
            }
        }
        const $ZodBase64 = /*@__PURE__*/ $constructor("$ZodBase64", (inst, def)=>{
            def.pattern ?? (def.pattern = regexes_base64);
            $ZodStringFormat.init(inst, def);
            inst._zod.onattach.push((inst)=>{
                inst._zod.bag.contentEncoding = "base64";
            });
            inst._zod.check = (payload)=>{
                if (isValidBase64(payload.value)) return;
                payload.issues.push({
                    code: "invalid_format",
                    format: "base64",
                    input: payload.value,
                    inst,
                    continue: !def.abort
                });
            };
        });
        function isValidBase64URL(data) {
            if (!base64url.test(data)) return false;
            const base64 = data.replace(/[-_]/g, (c)=>"-" === c ? "+" : "/");
            const padded = base64.padEnd(4 * Math.ceil(base64.length / 4), "=");
            return isValidBase64(padded);
        }
        const $ZodBase64URL = /*@__PURE__*/ $constructor("$ZodBase64URL", (inst, def)=>{
            def.pattern ?? (def.pattern = base64url);
            $ZodStringFormat.init(inst, def);
            inst._zod.onattach.push((inst)=>{
                inst._zod.bag.contentEncoding = "base64url";
            });
            inst._zod.check = (payload)=>{
                if (isValidBase64URL(payload.value)) return;
                payload.issues.push({
                    code: "invalid_format",
                    format: "base64url",
                    input: payload.value,
                    inst,
                    continue: !def.abort
                });
            };
        });
        const $ZodE164 = /*@__PURE__*/ $constructor("$ZodE164", (inst, def)=>{
            def.pattern ?? (def.pattern = e164);
            $ZodStringFormat.init(inst, def);
        });
        function isValidJWT(token, algorithm = null) {
            try {
                const tokensParts = token.split(".");
                if (3 !== tokensParts.length) return false;
                const [header] = tokensParts;
                if (!header) return false;
                const parsedHeader = JSON.parse(atob(header));
                if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT") return false;
                if (!parsedHeader.alg) return false;
                if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm)) return false;
                return true;
            } catch  {
                return false;
            }
        }
        const $ZodJWT = /*@__PURE__*/ $constructor("$ZodJWT", (inst, def)=>{
            $ZodStringFormat.init(inst, def);
            inst._zod.check = (payload)=>{
                if (isValidJWT(payload.value, def.alg)) return;
                payload.issues.push({
                    code: "invalid_format",
                    format: "jwt",
                    input: payload.value,
                    inst,
                    continue: !def.abort
                });
            };
        });
        const $ZodNumber = /*@__PURE__*/ $constructor("$ZodNumber", (inst, def)=>{
            $ZodType.init(inst, def);
            inst._zod.pattern = inst._zod.bag.pattern ?? number;
            inst._zod.parse = (payload, _ctx)=>{
                if (def.coerce) try {
                    payload.value = Number(payload.value);
                } catch (_) {}
                const input = payload.value;
                if ("number" == typeof input && !Number.isNaN(input) && Number.isFinite(input)) return payload;
                const received = "number" == typeof input ? Number.isNaN(input) ? "NaN" : Number.isFinite(input) ? void 0 : "Infinity" : void 0;
                payload.issues.push({
                    expected: "number",
                    code: "invalid_type",
                    input,
                    inst,
                    ...received ? {
                        received
                    } : {}
                });
                return payload;
            };
        });
        const $ZodNumberFormat = /*@__PURE__*/ $constructor("$ZodNumber", (inst, def)=>{
            $ZodCheckNumberFormat.init(inst, def);
            $ZodNumber.init(inst, def);
        });
        const $ZodBoolean = /*@__PURE__*/ $constructor("$ZodBoolean", (inst, def)=>{
            $ZodType.init(inst, def);
            inst._zod.pattern = regexes_boolean;
            inst._zod.parse = (payload, _ctx)=>{
                if (def.coerce) try {
                    payload.value = Boolean(payload.value);
                } catch (_) {}
                const input = payload.value;
                if ("boolean" == typeof input) return payload;
                payload.issues.push({
                    expected: "boolean",
                    code: "invalid_type",
                    input,
                    inst
                });
                return payload;
            };
        });
        const $ZodUndefined = /*@__PURE__*/ $constructor("$ZodUndefined", (inst, def)=>{
            $ZodType.init(inst, def);
            inst._zod.pattern = _undefined;
            inst._zod.values = new Set([
                void 0
            ]);
            inst._zod.optin = "optional";
            inst._zod.optout = "optional";
            inst._zod.parse = (payload, _ctx)=>{
                const input = payload.value;
                if (void 0 === input) return payload;
                payload.issues.push({
                    expected: "undefined",
                    code: "invalid_type",
                    input,
                    inst
                });
                return payload;
            };
        });
        const $ZodAny = /*@__PURE__*/ $constructor("$ZodAny", (inst, def)=>{
            $ZodType.init(inst, def);
            inst._zod.parse = (payload)=>payload;
        });
        const $ZodUnknown = /*@__PURE__*/ $constructor("$ZodUnknown", (inst, def)=>{
            $ZodType.init(inst, def);
            inst._zod.parse = (payload)=>payload;
        });
        const $ZodNever = /*@__PURE__*/ $constructor("$ZodNever", (inst, def)=>{
            $ZodType.init(inst, def);
            inst._zod.parse = (payload, _ctx)=>{
                payload.issues.push({
                    expected: "never",
                    code: "invalid_type",
                    input: payload.value,
                    inst
                });
                return payload;
            };
        });
        function handleArrayResult(result, final, index) {
            if (result.issues.length) final.issues.push(...prefixIssues(index, result.issues));
            final.value[index] = result.value;
        }
        const $ZodArray = /*@__PURE__*/ $constructor("$ZodArray", (inst, def)=>{
            $ZodType.init(inst, def);
            inst._zod.parse = (payload, ctx)=>{
                const input = payload.value;
                if (!Array.isArray(input)) {
                    payload.issues.push({
                        expected: "array",
                        code: "invalid_type",
                        input,
                        inst
                    });
                    return payload;
                }
                payload.value = Array(input.length);
                const proms = [];
                for(let i = 0; i < input.length; i++){
                    const item = input[i];
                    const result = def.element._zod.run({
                        value: item,
                        issues: []
                    }, ctx);
                    if (result instanceof Promise) proms.push(result.then((result)=>handleArrayResult(result, payload, i)));
                    else handleArrayResult(result, payload, i);
                }
                if (proms.length) return Promise.all(proms).then(()=>payload);
                return payload;
            };
        });
        function handlePropertyResult(result, final, key, input) {
            if (result.issues.length) final.issues.push(...prefixIssues(key, result.issues));
            if (void 0 === result.value) {
                if (key in input) final.value[key] = void 0;
            } else final.value[key] = result.value;
        }
        const $ZodObject = /*@__PURE__*/ $constructor("$ZodObject", (inst, def)=>{
            $ZodType.init(inst, def);
            const _normalized = cached(()=>{
                const keys = Object.keys(def.shape);
                for (const k of keys)if (!(def.shape[k] instanceof $ZodType)) throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
                const okeys = optionalKeys(def.shape);
                return {
                    shape: def.shape,
                    keys,
                    keySet: new Set(keys),
                    numKeys: keys.length,
                    optionalKeys: new Set(okeys)
                };
            });
            defineLazy(inst._zod, "propValues", ()=>{
                const shape = def.shape;
                const propValues = {};
                for(const key in shape){
                    const field = shape[key]._zod;
                    if (field.values) {
                        propValues[key] ?? (propValues[key] = new Set());
                        for (const v of field.values)propValues[key].add(v);
                    }
                }
                return propValues;
            });
            const generateFastpass = (shape)=>{
                const doc = new Doc([
                    "shape",
                    "payload",
                    "ctx"
                ]);
                const normalized = _normalized.value;
                const parseStr = (key)=>{
                    const k = esc(key);
                    return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
                };
                doc.write("const input = payload.value;");
                const ids = Object.create(null);
                let counter = 0;
                for (const key of normalized.keys)ids[key] = `key_${counter++}`;
                doc.write("const newResult = {}");
                for (const key of normalized.keys){
                    const id = ids[key];
                    const k = esc(key);
                    doc.write(`const ${id} = ${parseStr(key)};`);
                    doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
      `);
                }
                doc.write("payload.value = newResult;");
                doc.write("return payload;");
                const fn = doc.compile();
                return (payload, ctx)=>fn(shape, payload, ctx);
            };
            let fastpass;
            const isObject = util_isObject;
            const jit = !globalConfig.jitless;
            const allowsEval = util_allowsEval;
            const fastEnabled = jit && allowsEval.value;
            const catchall = def.catchall;
            let value;
            inst._zod.parse = (payload, ctx)=>{
                value ?? (value = _normalized.value);
                const input = payload.value;
                if (!isObject(input)) {
                    payload.issues.push({
                        expected: "object",
                        code: "invalid_type",
                        input,
                        inst
                    });
                    return payload;
                }
                const proms = [];
                if (jit && fastEnabled && ctx?.async === false && true !== ctx.jitless) {
                    if (!fastpass) fastpass = generateFastpass(def.shape);
                    payload = fastpass(payload, ctx);
                } else {
                    payload.value = {};
                    const shape = value.shape;
                    for (const key of value.keys){
                        const el = shape[key];
                        const r = el._zod.run({
                            value: input[key],
                            issues: []
                        }, ctx);
                        if (r instanceof Promise) proms.push(r.then((r)=>handlePropertyResult(r, payload, key, input)));
                        else handlePropertyResult(r, payload, key, input);
                    }
                }
                if (!catchall) return proms.length ? Promise.all(proms).then(()=>payload) : payload;
                const unrecognized = [];
                const keySet = value.keySet;
                const _catchall = catchall._zod;
                const t = _catchall.def.type;
                for (const key of Object.keys(input)){
                    if (keySet.has(key)) continue;
                    if ("never" === t) {
                        unrecognized.push(key);
                        continue;
                    }
                    const r = _catchall.run({
                        value: input[key],
                        issues: []
                    }, ctx);
                    if (r instanceof Promise) proms.push(r.then((r)=>handlePropertyResult(r, payload, key, input)));
                    else handlePropertyResult(r, payload, key, input);
                }
                if (unrecognized.length) payload.issues.push({
                    code: "unrecognized_keys",
                    keys: unrecognized,
                    input,
                    inst
                });
                if (!proms.length) return payload;
                return Promise.all(proms).then(()=>payload);
            };
        });
        function handleUnionResults(results, final, inst, ctx) {
            for (const result of results)if (0 === result.issues.length) {
                final.value = result.value;
                return final;
            }
            const nonaborted = results.filter((r)=>!aborted(r));
            if (1 === nonaborted.length) {
                final.value = nonaborted[0].value;
                return nonaborted[0];
            }
            final.issues.push({
                code: "invalid_union",
                input: final.value,
                inst,
                errors: results.map((result)=>result.issues.map((iss)=>finalizeIssue(iss, ctx, core_config())))
            });
            return final;
        }
        const $ZodUnion = /*@__PURE__*/ $constructor("$ZodUnion", (inst, def)=>{
            $ZodType.init(inst, def);
            defineLazy(inst._zod, "optin", ()=>def.options.some((o)=>"optional" === o._zod.optin) ? "optional" : void 0);
            defineLazy(inst._zod, "optout", ()=>def.options.some((o)=>"optional" === o._zod.optout) ? "optional" : void 0);
            defineLazy(inst._zod, "values", ()=>{
                if (def.options.every((o)=>o._zod.values)) return new Set(def.options.flatMap((option)=>Array.from(option._zod.values)));
            });
            defineLazy(inst._zod, "pattern", ()=>{
                if (def.options.every((o)=>o._zod.pattern)) {
                    const patterns = def.options.map((o)=>o._zod.pattern);
                    return new RegExp(`^(${patterns.map((p)=>cleanRegex(p.source)).join("|")})$`);
                }
            });
            const single = 1 === def.options.length;
            const first = def.options[0]._zod.run;
            inst._zod.parse = (payload, ctx)=>{
                if (single) return first(payload, ctx);
                let async = false;
                const results = [];
                for (const option of def.options){
                    const result = option._zod.run({
                        value: payload.value,
                        issues: []
                    }, ctx);
                    if (result instanceof Promise) {
                        results.push(result);
                        async = true;
                    } else {
                        if (0 === result.issues.length) return result;
                        results.push(result);
                    }
                }
                if (!async) return handleUnionResults(results, payload, inst, ctx);
                return Promise.all(results).then((results)=>handleUnionResults(results, payload, inst, ctx));
            };
        });
        const $ZodDiscriminatedUnion = /*@__PURE__*/ $constructor("$ZodDiscriminatedUnion", (inst, def)=>{
            $ZodUnion.init(inst, def);
            const _super = inst._zod.parse;
            defineLazy(inst._zod, "propValues", ()=>{
                const propValues = {};
                for (const option of def.options){
                    const pv = option._zod.propValues;
                    if (!pv || 0 === Object.keys(pv).length) throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
                    for (const [k, v] of Object.entries(pv)){
                        if (!propValues[k]) propValues[k] = new Set();
                        for (const val of v)propValues[k].add(val);
                    }
                }
                return propValues;
            });
            const disc = cached(()=>{
                const opts = def.options;
                const map = new Map();
                for (const o of opts){
                    const values = o._zod.propValues?.[def.discriminator];
                    if (!values || 0 === values.size) throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
                    for (const v of values){
                        if (map.has(v)) throw new Error(`Duplicate discriminator value "${String(v)}"`);
                        map.set(v, o);
                    }
                }
                return map;
            });
            inst._zod.parse = (payload, ctx)=>{
                const input = payload.value;
                if (!util_isObject(input)) {
                    payload.issues.push({
                        code: "invalid_type",
                        expected: "object",
                        input,
                        inst
                    });
                    return payload;
                }
                const opt = disc.value.get(input?.[def.discriminator]);
                if (opt) return opt._zod.run(payload, ctx);
                if (def.unionFallback) return _super(payload, ctx);
                payload.issues.push({
                    code: "invalid_union",
                    errors: [],
                    note: "No matching discriminator",
                    discriminator: def.discriminator,
                    input,
                    path: [
                        def.discriminator
                    ],
                    inst
                });
                return payload;
            };
        });
        const $ZodIntersection = /*@__PURE__*/ $constructor("$ZodIntersection", (inst, def)=>{
            $ZodType.init(inst, def);
            inst._zod.parse = (payload, ctx)=>{
                const input = payload.value;
                const left = def.left._zod.run({
                    value: input,
                    issues: []
                }, ctx);
                const right = def.right._zod.run({
                    value: input,
                    issues: []
                }, ctx);
                const async = left instanceof Promise || right instanceof Promise;
                if (async) return Promise.all([
                    left,
                    right
                ]).then(([left, right])=>handleIntersectionResults(payload, left, right));
                return handleIntersectionResults(payload, left, right);
            };
        });
        function mergeValues(a, b) {
            if (a === b) return {
                valid: true,
                data: a
            };
            if (a instanceof Date && b instanceof Date && +a === +b) return {
                valid: true,
                data: a
            };
            if (util_isPlainObject(a) && util_isPlainObject(b)) {
                const bKeys = Object.keys(b);
                const sharedKeys = Object.keys(a).filter((key)=>-1 !== bKeys.indexOf(key));
                const newObj = {
                    ...a,
                    ...b
                };
                for (const key of sharedKeys){
                    const sharedValue = mergeValues(a[key], b[key]);
                    if (!sharedValue.valid) return {
                        valid: false,
                        mergeErrorPath: [
                            key,
                            ...sharedValue.mergeErrorPath
                        ]
                    };
                    newObj[key] = sharedValue.data;
                }
                return {
                    valid: true,
                    data: newObj
                };
            }
            if (Array.isArray(a) && Array.isArray(b)) {
                if (a.length !== b.length) return {
                    valid: false,
                    mergeErrorPath: []
                };
                const newArray = [];
                for(let index = 0; index < a.length; index++){
                    const itemA = a[index];
                    const itemB = b[index];
                    const sharedValue = mergeValues(itemA, itemB);
                    if (!sharedValue.valid) return {
                        valid: false,
                        mergeErrorPath: [
                            index,
                            ...sharedValue.mergeErrorPath
                        ]
                    };
                    newArray.push(sharedValue.data);
                }
                return {
                    valid: true,
                    data: newArray
                };
            }
            return {
                valid: false,
                mergeErrorPath: []
            };
        }
        function handleIntersectionResults(result, left, right) {
            if (left.issues.length) result.issues.push(...left.issues);
            if (right.issues.length) result.issues.push(...right.issues);
            if (aborted(result)) return result;
            const merged = mergeValues(left.value, right.value);
            if (!merged.valid) throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
            result.value = merged.data;
            return result;
        }
        const $ZodRecord = /*@__PURE__*/ $constructor("$ZodRecord", (inst, def)=>{
            $ZodType.init(inst, def);
            inst._zod.parse = (payload, ctx)=>{
                const input = payload.value;
                if (!util_isPlainObject(input)) {
                    payload.issues.push({
                        expected: "record",
                        code: "invalid_type",
                        input,
                        inst
                    });
                    return payload;
                }
                const proms = [];
                if (def.keyType._zod.values) {
                    const values = def.keyType._zod.values;
                    payload.value = {};
                    for (const key of values)if ("string" == typeof key || "number" == typeof key || "symbol" == typeof key) {
                        const result = def.valueType._zod.run({
                            value: input[key],
                            issues: []
                        }, ctx);
                        if (result instanceof Promise) proms.push(result.then((result)=>{
                            if (result.issues.length) payload.issues.push(...prefixIssues(key, result.issues));
                            payload.value[key] = result.value;
                        }));
                        else {
                            if (result.issues.length) payload.issues.push(...prefixIssues(key, result.issues));
                            payload.value[key] = result.value;
                        }
                    }
                    let unrecognized;
                    for(const key in input)if (!values.has(key)) {
                        unrecognized = unrecognized ?? [];
                        unrecognized.push(key);
                    }
                    if (unrecognized && unrecognized.length > 0) payload.issues.push({
                        code: "unrecognized_keys",
                        input,
                        inst,
                        keys: unrecognized
                    });
                } else {
                    payload.value = {};
                    for (const key of Reflect.ownKeys(input)){
                        if ("__proto__" === key) continue;
                        const keyResult = def.keyType._zod.run({
                            value: key,
                            issues: []
                        }, ctx);
                        if (keyResult instanceof Promise) throw new Error("Async schemas not supported in object keys currently");
                        if (keyResult.issues.length) {
                            payload.issues.push({
                                code: "invalid_key",
                                origin: "record",
                                issues: keyResult.issues.map((iss)=>finalizeIssue(iss, ctx, core_config())),
                                input: key,
                                path: [
                                    key
                                ],
                                inst
                            });
                            payload.value[keyResult.value] = keyResult.value;
                            continue;
                        }
                        const result = def.valueType._zod.run({
                            value: input[key],
                            issues: []
                        }, ctx);
                        if (result instanceof Promise) proms.push(result.then((result)=>{
                            if (result.issues.length) payload.issues.push(...prefixIssues(key, result.issues));
                            payload.value[keyResult.value] = result.value;
                        }));
                        else {
                            if (result.issues.length) payload.issues.push(...prefixIssues(key, result.issues));
                            payload.value[keyResult.value] = result.value;
                        }
                    }
                }
                if (proms.length) return Promise.all(proms).then(()=>payload);
                return payload;
            };
        });
        const $ZodEnum = /*@__PURE__*/ $constructor("$ZodEnum", (inst, def)=>{
            $ZodType.init(inst, def);
            const values = getEnumValues(def.entries);
            const valuesSet = new Set(values);
            inst._zod.values = valuesSet;
            inst._zod.pattern = new RegExp(`^(${values.filter((k)=>propertyKeyTypes.has(typeof k)).map((o)=>"string" == typeof o ? escapeRegex(o) : o.toString()).join("|")})$`);
            inst._zod.parse = (payload, _ctx)=>{
                const input = payload.value;
                if (valuesSet.has(input)) return payload;
                payload.issues.push({
                    code: "invalid_value",
                    values,
                    input,
                    inst
                });
                return payload;
            };
        });
        const $ZodLiteral = /*@__PURE__*/ $constructor("$ZodLiteral", (inst, def)=>{
            $ZodType.init(inst, def);
            if (0 === def.values.length) throw new Error("Cannot create literal schema with no valid values");
            inst._zod.values = new Set(def.values);
            inst._zod.pattern = new RegExp(`^(${def.values.map((o)=>"string" == typeof o ? escapeRegex(o) : o ? escapeRegex(o.toString()) : String(o)).join("|")})$`);
            inst._zod.parse = (payload, _ctx)=>{
                const input = payload.value;
                if (inst._zod.values.has(input)) return payload;
                payload.issues.push({
                    code: "invalid_value",
                    values: def.values,
                    input,
                    inst
                });
                return payload;
            };
        });
        const $ZodTransform = /*@__PURE__*/ $constructor("$ZodTransform", (inst, def)=>{
            $ZodType.init(inst, def);
            inst._zod.parse = (payload, _ctx)=>{
                const _out = def.transform(payload.value, payload);
                if (_ctx.async) {
                    const output = _out instanceof Promise ? _out : Promise.resolve(_out);
                    return output.then((output)=>{
                        payload.value = output;
                        return payload;
                    });
                }
                if (_out instanceof Promise) throw new $ZodAsyncError();
                payload.value = _out;
                return payload;
            };
        });
        function handleOptionalResult(result, input) {
            if (result.issues.length && void 0 === input) return {
                issues: [],
                value: void 0
            };
            return result;
        }
        const $ZodOptional = /*@__PURE__*/ $constructor("$ZodOptional", (inst, def)=>{
            $ZodType.init(inst, def);
            inst._zod.optin = "optional";
            inst._zod.optout = "optional";
            defineLazy(inst._zod, "values", ()=>def.innerType._zod.values ? new Set([
                    ...def.innerType._zod.values,
                    void 0
                ]) : void 0);
            defineLazy(inst._zod, "pattern", ()=>{
                const pattern = def.innerType._zod.pattern;
                return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
            });
            inst._zod.parse = (payload, ctx)=>{
                if ("optional" === def.innerType._zod.optin) {
                    const result = def.innerType._zod.run(payload, ctx);
                    if (result instanceof Promise) return result.then((r)=>handleOptionalResult(r, payload.value));
                    return handleOptionalResult(result, payload.value);
                }
                if (void 0 === payload.value) return payload;
                return def.innerType._zod.run(payload, ctx);
            };
        });
        const $ZodNullable = /*@__PURE__*/ $constructor("$ZodNullable", (inst, def)=>{
            $ZodType.init(inst, def);
            defineLazy(inst._zod, "optin", ()=>def.innerType._zod.optin);
            defineLazy(inst._zod, "optout", ()=>def.innerType._zod.optout);
            defineLazy(inst._zod, "pattern", ()=>{
                const pattern = def.innerType._zod.pattern;
                return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
            });
            defineLazy(inst._zod, "values", ()=>def.innerType._zod.values ? new Set([
                    ...def.innerType._zod.values,
                    null
                ]) : void 0);
            inst._zod.parse = (payload, ctx)=>{
                if (null === payload.value) return payload;
                return def.innerType._zod.run(payload, ctx);
            };
        });
        const $ZodDefault = /*@__PURE__*/ $constructor("$ZodDefault", (inst, def)=>{
            $ZodType.init(inst, def);
            inst._zod.optin = "optional";
            defineLazy(inst._zod, "values", ()=>def.innerType._zod.values);
            inst._zod.parse = (payload, ctx)=>{
                if (void 0 === payload.value) {
                    payload.value = def.defaultValue;
                    return payload;
                }
                const result = def.innerType._zod.run(payload, ctx);
                if (result instanceof Promise) return result.then((result)=>handleDefaultResult(result, def));
                return handleDefaultResult(result, def);
            };
        });
        function handleDefaultResult(payload, def) {
            if (void 0 === payload.value) payload.value = def.defaultValue;
            return payload;
        }
        const $ZodPrefault = /*@__PURE__*/ $constructor("$ZodPrefault", (inst, def)=>{
            $ZodType.init(inst, def);
            inst._zod.optin = "optional";
            defineLazy(inst._zod, "values", ()=>def.innerType._zod.values);
            inst._zod.parse = (payload, ctx)=>{
                if (void 0 === payload.value) payload.value = def.defaultValue;
                return def.innerType._zod.run(payload, ctx);
            };
        });
        const $ZodNonOptional = /*@__PURE__*/ $constructor("$ZodNonOptional", (inst, def)=>{
            $ZodType.init(inst, def);
            defineLazy(inst._zod, "values", ()=>{
                const v = def.innerType._zod.values;
                return v ? new Set([
                    ...v
                ].filter((x)=>void 0 !== x)) : void 0;
            });
            inst._zod.parse = (payload, ctx)=>{
                const result = def.innerType._zod.run(payload, ctx);
                if (result instanceof Promise) return result.then((result)=>handleNonOptionalResult(result, inst));
                return handleNonOptionalResult(result, inst);
            };
        });
        function handleNonOptionalResult(payload, inst) {
            if (!payload.issues.length && void 0 === payload.value) payload.issues.push({
                code: "invalid_type",
                expected: "nonoptional",
                input: payload.value,
                inst
            });
            return payload;
        }
        const $ZodCatch = /*@__PURE__*/ $constructor("$ZodCatch", (inst, def)=>{
            $ZodType.init(inst, def);
            defineLazy(inst._zod, "optin", ()=>def.innerType._zod.optin);
            defineLazy(inst._zod, "optout", ()=>def.innerType._zod.optout);
            defineLazy(inst._zod, "values", ()=>def.innerType._zod.values);
            inst._zod.parse = (payload, ctx)=>{
                const result = def.innerType._zod.run(payload, ctx);
                if (result instanceof Promise) return result.then((result)=>{
                    payload.value = result.value;
                    if (result.issues.length) {
                        payload.value = def.catchValue({
                            ...payload,
                            error: {
                                issues: result.issues.map((iss)=>finalizeIssue(iss, ctx, core_config()))
                            },
                            input: payload.value
                        });
                        payload.issues = [];
                    }
                    return payload;
                });
                payload.value = result.value;
                if (result.issues.length) {
                    payload.value = def.catchValue({
                        ...payload,
                        error: {
                            issues: result.issues.map((iss)=>finalizeIssue(iss, ctx, core_config()))
                        },
                        input: payload.value
                    });
                    payload.issues = [];
                }
                return payload;
            };
        });
        const $ZodPipe = /*@__PURE__*/ $constructor("$ZodPipe", (inst, def)=>{
            $ZodType.init(inst, def);
            defineLazy(inst._zod, "values", ()=>def.in._zod.values);
            defineLazy(inst._zod, "optin", ()=>def.in._zod.optin);
            defineLazy(inst._zod, "optout", ()=>def.out._zod.optout);
            defineLazy(inst._zod, "propValues", ()=>def.in._zod.propValues);
            inst._zod.parse = (payload, ctx)=>{
                const left = def.in._zod.run(payload, ctx);
                if (left instanceof Promise) return left.then((left)=>handlePipeResult(left, def, ctx));
                return handlePipeResult(left, def, ctx);
            };
        });
        function handlePipeResult(left, def, ctx) {
            if (left.issues.length) return left;
            return def.out._zod.run({
                value: left.value,
                issues: left.issues
            }, ctx);
        }
        const $ZodReadonly = /*@__PURE__*/ $constructor("$ZodReadonly", (inst, def)=>{
            $ZodType.init(inst, def);
            defineLazy(inst._zod, "propValues", ()=>def.innerType._zod.propValues);
            defineLazy(inst._zod, "values", ()=>def.innerType._zod.values);
            defineLazy(inst._zod, "optin", ()=>def.innerType._zod.optin);
            defineLazy(inst._zod, "optout", ()=>def.innerType._zod.optout);
            inst._zod.parse = (payload, ctx)=>{
                const result = def.innerType._zod.run(payload, ctx);
                if (result instanceof Promise) return result.then(handleReadonlyResult);
                return handleReadonlyResult(result);
            };
        });
        function handleReadonlyResult(payload) {
            payload.value = Object.freeze(payload.value);
            return payload;
        }
        const $ZodCustom = /*@__PURE__*/ $constructor("$ZodCustom", (inst, def)=>{
            $ZodCheck.init(inst, def);
            $ZodType.init(inst, def);
            inst._zod.parse = (payload, _)=>payload;
            inst._zod.check = (payload)=>{
                const input = payload.value;
                const r = def.fn(input);
                if (r instanceof Promise) return r.then((r)=>handleRefineResult(r, payload, input, inst));
                handleRefineResult(r, payload, input, inst);
            };
        });
        function handleRefineResult(result, payload, input, inst) {
            if (!result) {
                const _iss = {
                    code: "custom",
                    input,
                    inst,
                    path: [
                        ...inst._zod.def.path ?? []
                    ],
                    continue: !inst._zod.def.abort
                };
                if (inst._zod.def.params) _iss.params = inst._zod.def.params;
                payload.issues.push(util_issue(_iss));
            }
        }
        Symbol("ZodOutput");
        Symbol("ZodInput");
        class $ZodRegistry {
            constructor(){
                this._map = new Map();
                this._idmap = new Map();
            }
            add(schema, ..._meta) {
                const meta = _meta[0];
                this._map.set(schema, meta);
                if (meta && "object" == typeof meta && "id" in meta) {
                    if (this._idmap.has(meta.id)) throw new Error(`ID ${meta.id} already exists in the registry`);
                    this._idmap.set(meta.id, schema);
                }
                return this;
            }
            clear() {
                this._map = new Map();
                this._idmap = new Map();
                return this;
            }
            remove(schema) {
                const meta = this._map.get(schema);
                if (meta && "object" == typeof meta && "id" in meta) this._idmap.delete(meta.id);
                this._map.delete(schema);
                return this;
            }
            get(schema) {
                const p = schema._zod.parent;
                if (p) {
                    const pm = {
                        ...this.get(p) ?? {}
                    };
                    delete pm.id;
                    const f = {
                        ...pm,
                        ...this._map.get(schema)
                    };
                    return Object.keys(f).length ? f : void 0;
                }
                return this._map.get(schema);
            }
            has(schema) {
                return this._map.has(schema);
            }
        }
        function registry() {
            return new $ZodRegistry();
        }
        const globalRegistry = /*@__PURE__*/ registry();
        function _string(Class, params) {
            return new Class({
                type: "string",
                ...normalizeParams(params)
            });
        }
        function _email(Class, params) {
            return new Class({
                type: "string",
                format: "email",
                check: "string_format",
                abort: false,
                ...normalizeParams(params)
            });
        }
        function _guid(Class, params) {
            return new Class({
                type: "string",
                format: "guid",
                check: "string_format",
                abort: false,
                ...normalizeParams(params)
            });
        }
        function _uuid(Class, params) {
            return new Class({
                type: "string",
                format: "uuid",
                check: "string_format",
                abort: false,
                ...normalizeParams(params)
            });
        }
        function _uuidv4(Class, params) {
            return new Class({
                type: "string",
                format: "uuid",
                check: "string_format",
                abort: false,
                version: "v4",
                ...normalizeParams(params)
            });
        }
        function _uuidv6(Class, params) {
            return new Class({
                type: "string",
                format: "uuid",
                check: "string_format",
                abort: false,
                version: "v6",
                ...normalizeParams(params)
            });
        }
        function _uuidv7(Class, params) {
            return new Class({
                type: "string",
                format: "uuid",
                check: "string_format",
                abort: false,
                version: "v7",
                ...normalizeParams(params)
            });
        }
        function _url(Class, params) {
            return new Class({
                type: "string",
                format: "url",
                check: "string_format",
                abort: false,
                ...normalizeParams(params)
            });
        }
        function api_emoji(Class, params) {
            return new Class({
                type: "string",
                format: "emoji",
                check: "string_format",
                abort: false,
                ...normalizeParams(params)
            });
        }
        function _nanoid(Class, params) {
            return new Class({
                type: "string",
                format: "nanoid",
                check: "string_format",
                abort: false,
                ...normalizeParams(params)
            });
        }
        function _cuid(Class, params) {
            return new Class({
                type: "string",
                format: "cuid",
                check: "string_format",
                abort: false,
                ...normalizeParams(params)
            });
        }
        function _cuid2(Class, params) {
            return new Class({
                type: "string",
                format: "cuid2",
                check: "string_format",
                abort: false,
                ...normalizeParams(params)
            });
        }
        function _ulid(Class, params) {
            return new Class({
                type: "string",
                format: "ulid",
                check: "string_format",
                abort: false,
                ...normalizeParams(params)
            });
        }
        function _xid(Class, params) {
            return new Class({
                type: "string",
                format: "xid",
                check: "string_format",
                abort: false,
                ...normalizeParams(params)
            });
        }
        function _ksuid(Class, params) {
            return new Class({
                type: "string",
                format: "ksuid",
                check: "string_format",
                abort: false,
                ...normalizeParams(params)
            });
        }
        function _ipv4(Class, params) {
            return new Class({
                type: "string",
                format: "ipv4",
                check: "string_format",
                abort: false,
                ...normalizeParams(params)
            });
        }
        function _ipv6(Class, params) {
            return new Class({
                type: "string",
                format: "ipv6",
                check: "string_format",
                abort: false,
                ...normalizeParams(params)
            });
        }
        function _cidrv4(Class, params) {
            return new Class({
                type: "string",
                format: "cidrv4",
                check: "string_format",
                abort: false,
                ...normalizeParams(params)
            });
        }
        function _cidrv6(Class, params) {
            return new Class({
                type: "string",
                format: "cidrv6",
                check: "string_format",
                abort: false,
                ...normalizeParams(params)
            });
        }
        function _base64(Class, params) {
            return new Class({
                type: "string",
                format: "base64",
                check: "string_format",
                abort: false,
                ...normalizeParams(params)
            });
        }
        function _base64url(Class, params) {
            return new Class({
                type: "string",
                format: "base64url",
                check: "string_format",
                abort: false,
                ...normalizeParams(params)
            });
        }
        function _e164(Class, params) {
            return new Class({
                type: "string",
                format: "e164",
                check: "string_format",
                abort: false,
                ...normalizeParams(params)
            });
        }
        function _jwt(Class, params) {
            return new Class({
                type: "string",
                format: "jwt",
                check: "string_format",
                abort: false,
                ...normalizeParams(params)
            });
        }
        function _isoDateTime(Class, params) {
            return new Class({
                type: "string",
                format: "datetime",
                check: "string_format",
                offset: false,
                local: false,
                precision: null,
                ...normalizeParams(params)
            });
        }
        function _isoDate(Class, params) {
            return new Class({
                type: "string",
                format: "date",
                check: "string_format",
                ...normalizeParams(params)
            });
        }
        function _isoTime(Class, params) {
            return new Class({
                type: "string",
                format: "time",
                check: "string_format",
                precision: null,
                ...normalizeParams(params)
            });
        }
        function _isoDuration(Class, params) {
            return new Class({
                type: "string",
                format: "duration",
                check: "string_format",
                ...normalizeParams(params)
            });
        }
        function _number(Class, params) {
            return new Class({
                type: "number",
                checks: [],
                ...normalizeParams(params)
            });
        }
        function _int(Class, params) {
            return new Class({
                type: "number",
                check: "number_format",
                abort: false,
                format: "safeint",
                ...normalizeParams(params)
            });
        }
        function _boolean(Class, params) {
            return new Class({
                type: "boolean",
                ...normalizeParams(params)
            });
        }
        function api_undefined(Class, params) {
            return new Class({
                type: "undefined",
                ...normalizeParams(params)
            });
        }
        function _any(Class) {
            return new Class({
                type: "any"
            });
        }
        function _unknown(Class) {
            return new Class({
                type: "unknown"
            });
        }
        function _never(Class, params) {
            return new Class({
                type: "never",
                ...normalizeParams(params)
            });
        }
        function _lt(value, params) {
            return new $ZodCheckLessThan({
                check: "less_than",
                ...normalizeParams(params),
                value,
                inclusive: false
            });
        }
        function _lte(value, params) {
            return new $ZodCheckLessThan({
                check: "less_than",
                ...normalizeParams(params),
                value,
                inclusive: true
            });
        }
        function _gt(value, params) {
            return new $ZodCheckGreaterThan({
                check: "greater_than",
                ...normalizeParams(params),
                value,
                inclusive: false
            });
        }
        function _gte(value, params) {
            return new $ZodCheckGreaterThan({
                check: "greater_than",
                ...normalizeParams(params),
                value,
                inclusive: true
            });
        }
        function _multipleOf(value, params) {
            return new $ZodCheckMultipleOf({
                check: "multiple_of",
                ...normalizeParams(params),
                value
            });
        }
        function _maxLength(maximum, params) {
            const ch = new $ZodCheckMaxLength({
                check: "max_length",
                ...normalizeParams(params),
                maximum
            });
            return ch;
        }
        function _minLength(minimum, params) {
            return new $ZodCheckMinLength({
                check: "min_length",
                ...normalizeParams(params),
                minimum
            });
        }
        function _length(length, params) {
            return new $ZodCheckLengthEquals({
                check: "length_equals",
                ...normalizeParams(params),
                length
            });
        }
        function _regex(pattern, params) {
            return new $ZodCheckRegex({
                check: "string_format",
                format: "regex",
                ...normalizeParams(params),
                pattern
            });
        }
        function _lowercase(params) {
            return new $ZodCheckLowerCase({
                check: "string_format",
                format: "lowercase",
                ...normalizeParams(params)
            });
        }
        function _uppercase(params) {
            return new $ZodCheckUpperCase({
                check: "string_format",
                format: "uppercase",
                ...normalizeParams(params)
            });
        }
        function _includes(includes, params) {
            return new $ZodCheckIncludes({
                check: "string_format",
                format: "includes",
                ...normalizeParams(params),
                includes
            });
        }
        function _startsWith(prefix, params) {
            return new $ZodCheckStartsWith({
                check: "string_format",
                format: "starts_with",
                ...normalizeParams(params),
                prefix
            });
        }
        function _endsWith(suffix, params) {
            return new $ZodCheckEndsWith({
                check: "string_format",
                format: "ends_with",
                ...normalizeParams(params),
                suffix
            });
        }
        function _overwrite(tx) {
            return new $ZodCheckOverwrite({
                check: "overwrite",
                tx
            });
        }
        function _normalize(form) {
            return _overwrite((input)=>input.normalize(form));
        }
        function _trim() {
            return _overwrite((input)=>input.trim());
        }
        function _toLowerCase() {
            return _overwrite((input)=>input.toLowerCase());
        }
        function _toUpperCase() {
            return _overwrite((input)=>input.toUpperCase());
        }
        function _array(Class, element, params) {
            return new Class({
                type: "array",
                element,
                ...normalizeParams(params)
            });
        }
        function _refine(Class, fn, _params) {
            const schema = new Class({
                type: "custom",
                check: "custom",
                fn: fn,
                ...normalizeParams(_params)
            });
            return schema;
        }
        function _superRefine(fn) {
            const ch = _check((payload)=>{
                payload.addIssue = (issue)=>{
                    if ("string" == typeof issue) payload.issues.push(util_issue(issue, payload.value, ch._zod.def));
                    else {
                        const _issue = issue;
                        if (_issue.fatal) _issue.continue = false;
                        _issue.code ?? (_issue.code = "custom");
                        _issue.input ?? (_issue.input = payload.value);
                        _issue.inst ?? (_issue.inst = ch);
                        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
                        payload.issues.push(util_issue(_issue));
                    }
                };
                return fn(payload.value, payload);
            });
            return ch;
        }
        function _check(fn, params) {
            const ch = new $ZodCheck({
                check: "custom",
                ...normalizeParams(params)
            });
            ch._zod.check = fn;
            return ch;
        }
        const ZodISODateTime = /*@__PURE__*/ $constructor("ZodISODateTime", (inst, def)=>{
            $ZodISODateTime.init(inst, def);
            ZodStringFormat.init(inst, def);
        });
        function iso_datetime(params) {
            return _isoDateTime(ZodISODateTime, params);
        }
        const ZodISODate = /*@__PURE__*/ $constructor("ZodISODate", (inst, def)=>{
            $ZodISODate.init(inst, def);
            ZodStringFormat.init(inst, def);
        });
        function iso_date(params) {
            return _isoDate(ZodISODate, params);
        }
        const ZodISOTime = /*@__PURE__*/ $constructor("ZodISOTime", (inst, def)=>{
            $ZodISOTime.init(inst, def);
            ZodStringFormat.init(inst, def);
        });
        function iso_time(params) {
            return _isoTime(ZodISOTime, params);
        }
        const ZodISODuration = /*@__PURE__*/ $constructor("ZodISODuration", (inst, def)=>{
            $ZodISODuration.init(inst, def);
            ZodStringFormat.init(inst, def);
        });
        function iso_duration(params) {
            return _isoDuration(ZodISODuration, params);
        }
        const classic_errors_initializer = (inst, issues)=>{
            $ZodError.init(inst, issues);
            inst.name = "ZodError";
            Object.defineProperties(inst, {
                format: {
                    value: (mapper)=>formatError(inst, mapper)
                },
                flatten: {
                    value: (mapper)=>flattenError(inst, mapper)
                },
                addIssue: {
                    value: (issue)=>{
                        inst.issues.push(issue);
                        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
                    }
                },
                addIssues: {
                    value: (issues)=>{
                        inst.issues.push(...issues);
                        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
                    }
                },
                isEmpty: {
                    get () {
                        return 0 === inst.issues.length;
                    }
                }
            });
        };
        $constructor("ZodError", classic_errors_initializer);
        const ZodRealError = $constructor("ZodError", classic_errors_initializer, {
            Parent: Error
        });
        const parse_parse = /* @__PURE__ */ _parse(ZodRealError);
        const parse_parseAsync = /* @__PURE__ */ _parseAsync(ZodRealError);
        const parse_safeParse = /* @__PURE__ */ _safeParse(ZodRealError);
        const parse_safeParseAsync = /* @__PURE__ */ _safeParseAsync(ZodRealError);
        const ZodType = /*@__PURE__*/ $constructor("ZodType", (inst, def)=>{
            $ZodType.init(inst, def);
            inst.def = def;
            Object.defineProperty(inst, "_def", {
                value: def
            });
            inst.check = (...checks)=>inst.clone({
                    ...def,
                    checks: [
                        ...def.checks ?? [],
                        ...checks.map((ch)=>"function" == typeof ch ? {
                                _zod: {
                                    check: ch,
                                    def: {
                                        check: "custom"
                                    },
                                    onattach: []
                                }
                            } : ch)
                    ]
                });
            inst.clone = (def, params)=>clone(inst, def, params);
            inst.brand = ()=>inst;
            inst.register = (reg, meta)=>{
                reg.add(inst, meta);
                return inst;
            };
            inst.parse = (data, params)=>parse_parse(inst, data, params, {
                    callee: inst.parse
                });
            inst.safeParse = (data, params)=>parse_safeParse(inst, data, params);
            inst.parseAsync = async (data, params)=>parse_parseAsync(inst, data, params, {
                    callee: inst.parseAsync
                });
            inst.safeParseAsync = async (data, params)=>parse_safeParseAsync(inst, data, params);
            inst.spa = inst.safeParseAsync;
            inst.refine = (check, params)=>inst.check(refine(check, params));
            inst.superRefine = (refinement)=>inst.check(superRefine(refinement));
            inst.overwrite = (fn)=>inst.check(_overwrite(fn));
            inst.optional = ()=>optional(inst);
            inst.nullable = ()=>nullable(inst);
            inst.nullish = ()=>optional(nullable(inst));
            inst.nonoptional = (params)=>nonoptional(inst, params);
            inst.array = ()=>schemas_array(inst);
            inst.or = (arg)=>union([
                    inst,
                    arg
                ]);
            inst.and = (arg)=>intersection(inst, arg);
            inst.transform = (tx)=>schemas_pipe(inst, transform(tx));
            inst.default = (def)=>schemas_default(inst, def);
            inst.prefault = (def)=>prefault(inst, def);
            inst.catch = (params)=>schemas_catch(inst, params);
            inst.pipe = (target)=>schemas_pipe(inst, target);
            inst.readonly = ()=>readonly(inst);
            inst.describe = (description)=>{
                const cl = inst.clone();
                globalRegistry.add(cl, {
                    description
                });
                return cl;
            };
            Object.defineProperty(inst, "description", {
                get () {
                    return globalRegistry.get(inst)?.description;
                },
                configurable: true
            });
            inst.meta = (...args)=>{
                if (0 === args.length) return globalRegistry.get(inst);
                const cl = inst.clone();
                globalRegistry.add(cl, args[0]);
                return cl;
            };
            inst.isOptional = ()=>inst.safeParse(void 0).success;
            inst.isNullable = ()=>inst.safeParse(null).success;
            return inst;
        });
        const _ZodString = /*@__PURE__*/ $constructor("_ZodString", (inst, def)=>{
            $ZodString.init(inst, def);
            ZodType.init(inst, def);
            const bag = inst._zod.bag;
            inst.format = bag.format ?? null;
            inst.minLength = bag.minimum ?? null;
            inst.maxLength = bag.maximum ?? null;
            inst.regex = (...args)=>inst.check(_regex(...args));
            inst.includes = (...args)=>inst.check(_includes(...args));
            inst.startsWith = (...args)=>inst.check(_startsWith(...args));
            inst.endsWith = (...args)=>inst.check(_endsWith(...args));
            inst.min = (...args)=>inst.check(_minLength(...args));
            inst.max = (...args)=>inst.check(_maxLength(...args));
            inst.length = (...args)=>inst.check(_length(...args));
            inst.nonempty = (...args)=>inst.check(_minLength(1, ...args));
            inst.lowercase = (params)=>inst.check(_lowercase(params));
            inst.uppercase = (params)=>inst.check(_uppercase(params));
            inst.trim = ()=>inst.check(_trim());
            inst.normalize = (...args)=>inst.check(_normalize(...args));
            inst.toLowerCase = ()=>inst.check(_toLowerCase());
            inst.toUpperCase = ()=>inst.check(_toUpperCase());
        });
        const ZodString = /*@__PURE__*/ $constructor("ZodString", (inst, def)=>{
            $ZodString.init(inst, def);
            _ZodString.init(inst, def);
            inst.email = (params)=>inst.check(_email(ZodEmail, params));
            inst.url = (params)=>inst.check(_url(ZodURL, params));
            inst.jwt = (params)=>inst.check(_jwt(ZodJWT, params));
            inst.emoji = (params)=>inst.check(api_emoji(ZodEmoji, params));
            inst.guid = (params)=>inst.check(_guid(ZodGUID, params));
            inst.uuid = (params)=>inst.check(_uuid(ZodUUID, params));
            inst.uuidv4 = (params)=>inst.check(_uuidv4(ZodUUID, params));
            inst.uuidv6 = (params)=>inst.check(_uuidv6(ZodUUID, params));
            inst.uuidv7 = (params)=>inst.check(_uuidv7(ZodUUID, params));
            inst.nanoid = (params)=>inst.check(_nanoid(ZodNanoID, params));
            inst.guid = (params)=>inst.check(_guid(ZodGUID, params));
            inst.cuid = (params)=>inst.check(_cuid(ZodCUID, params));
            inst.cuid2 = (params)=>inst.check(_cuid2(ZodCUID2, params));
            inst.ulid = (params)=>inst.check(_ulid(ZodULID, params));
            inst.base64 = (params)=>inst.check(_base64(ZodBase64, params));
            inst.base64url = (params)=>inst.check(_base64url(ZodBase64URL, params));
            inst.xid = (params)=>inst.check(_xid(ZodXID, params));
            inst.ksuid = (params)=>inst.check(_ksuid(ZodKSUID, params));
            inst.ipv4 = (params)=>inst.check(_ipv4(ZodIPv4, params));
            inst.ipv6 = (params)=>inst.check(_ipv6(ZodIPv6, params));
            inst.cidrv4 = (params)=>inst.check(_cidrv4(ZodCIDRv4, params));
            inst.cidrv6 = (params)=>inst.check(_cidrv6(ZodCIDRv6, params));
            inst.e164 = (params)=>inst.check(_e164(ZodE164, params));
            inst.datetime = (params)=>inst.check(iso_datetime(params));
            inst.date = (params)=>inst.check(iso_date(params));
            inst.time = (params)=>inst.check(iso_time(params));
            inst.duration = (params)=>inst.check(iso_duration(params));
        });
        function schemas_string(params) {
            return _string(ZodString, params);
        }
        const ZodStringFormat = /*@__PURE__*/ $constructor("ZodStringFormat", (inst, def)=>{
            $ZodStringFormat.init(inst, def);
            _ZodString.init(inst, def);
        });
        const ZodEmail = /*@__PURE__*/ $constructor("ZodEmail", (inst, def)=>{
            $ZodEmail.init(inst, def);
            ZodStringFormat.init(inst, def);
        });
        const ZodGUID = /*@__PURE__*/ $constructor("ZodGUID", (inst, def)=>{
            $ZodGUID.init(inst, def);
            ZodStringFormat.init(inst, def);
        });
        const ZodUUID = /*@__PURE__*/ $constructor("ZodUUID", (inst, def)=>{
            $ZodUUID.init(inst, def);
            ZodStringFormat.init(inst, def);
        });
        const ZodURL = /*@__PURE__*/ $constructor("ZodURL", (inst, def)=>{
            $ZodURL.init(inst, def);
            ZodStringFormat.init(inst, def);
        });
        const ZodEmoji = /*@__PURE__*/ $constructor("ZodEmoji", (inst, def)=>{
            $ZodEmoji.init(inst, def);
            ZodStringFormat.init(inst, def);
        });
        const ZodNanoID = /*@__PURE__*/ $constructor("ZodNanoID", (inst, def)=>{
            $ZodNanoID.init(inst, def);
            ZodStringFormat.init(inst, def);
        });
        const ZodCUID = /*@__PURE__*/ $constructor("ZodCUID", (inst, def)=>{
            $ZodCUID.init(inst, def);
            ZodStringFormat.init(inst, def);
        });
        const ZodCUID2 = /*@__PURE__*/ $constructor("ZodCUID2", (inst, def)=>{
            $ZodCUID2.init(inst, def);
            ZodStringFormat.init(inst, def);
        });
        const ZodULID = /*@__PURE__*/ $constructor("ZodULID", (inst, def)=>{
            $ZodULID.init(inst, def);
            ZodStringFormat.init(inst, def);
        });
        const ZodXID = /*@__PURE__*/ $constructor("ZodXID", (inst, def)=>{
            $ZodXID.init(inst, def);
            ZodStringFormat.init(inst, def);
        });
        const ZodKSUID = /*@__PURE__*/ $constructor("ZodKSUID", (inst, def)=>{
            $ZodKSUID.init(inst, def);
            ZodStringFormat.init(inst, def);
        });
        const ZodIPv4 = /*@__PURE__*/ $constructor("ZodIPv4", (inst, def)=>{
            $ZodIPv4.init(inst, def);
            ZodStringFormat.init(inst, def);
        });
        const ZodIPv6 = /*@__PURE__*/ $constructor("ZodIPv6", (inst, def)=>{
            $ZodIPv6.init(inst, def);
            ZodStringFormat.init(inst, def);
        });
        const ZodCIDRv4 = /*@__PURE__*/ $constructor("ZodCIDRv4", (inst, def)=>{
            $ZodCIDRv4.init(inst, def);
            ZodStringFormat.init(inst, def);
        });
        const ZodCIDRv6 = /*@__PURE__*/ $constructor("ZodCIDRv6", (inst, def)=>{
            $ZodCIDRv6.init(inst, def);
            ZodStringFormat.init(inst, def);
        });
        const ZodBase64 = /*@__PURE__*/ $constructor("ZodBase64", (inst, def)=>{
            $ZodBase64.init(inst, def);
            ZodStringFormat.init(inst, def);
        });
        const ZodBase64URL = /*@__PURE__*/ $constructor("ZodBase64URL", (inst, def)=>{
            $ZodBase64URL.init(inst, def);
            ZodStringFormat.init(inst, def);
        });
        const ZodE164 = /*@__PURE__*/ $constructor("ZodE164", (inst, def)=>{
            $ZodE164.init(inst, def);
            ZodStringFormat.init(inst, def);
        });
        const ZodJWT = /*@__PURE__*/ $constructor("ZodJWT", (inst, def)=>{
            $ZodJWT.init(inst, def);
            ZodStringFormat.init(inst, def);
        });
        const ZodNumber = /*@__PURE__*/ $constructor("ZodNumber", (inst, def)=>{
            $ZodNumber.init(inst, def);
            ZodType.init(inst, def);
            inst.gt = (value, params)=>inst.check(_gt(value, params));
            inst.gte = (value, params)=>inst.check(_gte(value, params));
            inst.min = (value, params)=>inst.check(_gte(value, params));
            inst.lt = (value, params)=>inst.check(_lt(value, params));
            inst.lte = (value, params)=>inst.check(_lte(value, params));
            inst.max = (value, params)=>inst.check(_lte(value, params));
            inst.int = (params)=>inst.check(schemas_int(params));
            inst.safe = (params)=>inst.check(schemas_int(params));
            inst.positive = (params)=>inst.check(_gt(0, params));
            inst.nonnegative = (params)=>inst.check(_gte(0, params));
            inst.negative = (params)=>inst.check(_lt(0, params));
            inst.nonpositive = (params)=>inst.check(_lte(0, params));
            inst.multipleOf = (value, params)=>inst.check(_multipleOf(value, params));
            inst.step = (value, params)=>inst.check(_multipleOf(value, params));
            inst.finite = ()=>inst;
            const bag = inst._zod.bag;
            inst.minValue = Math.max(bag.minimum ?? -1 / 0, bag.exclusiveMinimum ?? -1 / 0) ?? null;
            inst.maxValue = Math.min(bag.maximum ?? 1 / 0, bag.exclusiveMaximum ?? 1 / 0) ?? null;
            inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
            inst.isFinite = true;
            inst.format = bag.format ?? null;
        });
        function schemas_number(params) {
            return _number(ZodNumber, params);
        }
        const ZodNumberFormat = /*@__PURE__*/ $constructor("ZodNumberFormat", (inst, def)=>{
            $ZodNumberFormat.init(inst, def);
            ZodNumber.init(inst, def);
        });
        function schemas_int(params) {
            return _int(ZodNumberFormat, params);
        }
        const ZodBoolean = /*@__PURE__*/ $constructor("ZodBoolean", (inst, def)=>{
            $ZodBoolean.init(inst, def);
            ZodType.init(inst, def);
        });
        function schemas_boolean(params) {
            return _boolean(ZodBoolean, params);
        }
        const ZodUndefined = /*@__PURE__*/ $constructor("ZodUndefined", (inst, def)=>{
            $ZodUndefined.init(inst, def);
            ZodType.init(inst, def);
        });
        function schemas_undefined(params) {
            return api_undefined(ZodUndefined, params);
        }
        const ZodAny = /*@__PURE__*/ $constructor("ZodAny", (inst, def)=>{
            $ZodAny.init(inst, def);
            ZodType.init(inst, def);
        });
        function any() {
            return _any(ZodAny);
        }
        const ZodUnknown = /*@__PURE__*/ $constructor("ZodUnknown", (inst, def)=>{
            $ZodUnknown.init(inst, def);
            ZodType.init(inst, def);
        });
        function unknown() {
            return _unknown(ZodUnknown);
        }
        const ZodNever = /*@__PURE__*/ $constructor("ZodNever", (inst, def)=>{
            $ZodNever.init(inst, def);
            ZodType.init(inst, def);
        });
        function never(params) {
            return _never(ZodNever, params);
        }
        const ZodArray = /*@__PURE__*/ $constructor("ZodArray", (inst, def)=>{
            $ZodArray.init(inst, def);
            ZodType.init(inst, def);
            inst.element = def.element;
            inst.min = (minLength, params)=>inst.check(_minLength(minLength, params));
            inst.nonempty = (params)=>inst.check(_minLength(1, params));
            inst.max = (maxLength, params)=>inst.check(_maxLength(maxLength, params));
            inst.length = (len, params)=>inst.check(_length(len, params));
            inst.unwrap = ()=>inst.element;
        });
        function schemas_array(element, params) {
            return _array(ZodArray, element, params);
        }
        const ZodObject = /*@__PURE__*/ $constructor("ZodObject", (inst, def)=>{
            $ZodObject.init(inst, def);
            ZodType.init(inst, def);
            defineLazy(inst, "shape", ()=>def.shape);
            inst.keyof = ()=>schemas_enum(Object.keys(inst._zod.def.shape));
            inst.catchall = (catchall)=>inst.clone({
                    ...inst._zod.def,
                    catchall: catchall
                });
            inst.passthrough = ()=>inst.clone({
                    ...inst._zod.def,
                    catchall: unknown()
                });
            inst.loose = ()=>inst.clone({
                    ...inst._zod.def,
                    catchall: unknown()
                });
            inst.strict = ()=>inst.clone({
                    ...inst._zod.def,
                    catchall: never()
                });
            inst.strip = ()=>inst.clone({
                    ...inst._zod.def,
                    catchall: void 0
                });
            inst.extend = (incoming)=>extend(inst, incoming);
            inst.merge = (other)=>util_merge(inst, other);
            inst.pick = (mask)=>pick(inst, mask);
            inst.omit = (mask)=>omit(inst, mask);
            inst.partial = (...args)=>partial(ZodOptional, inst, args[0]);
            inst.required = (...args)=>required(ZodNonOptional, inst, args[0]);
        });
        function schemas_object(shape, params) {
            const def = {
                type: "object",
                get shape () {
                    assignProp(this, "shape", {
                        ...shape
                    });
                    return this.shape;
                },
                ...normalizeParams(params)
            };
            return new ZodObject(def);
        }
        const ZodUnion = /*@__PURE__*/ $constructor("ZodUnion", (inst, def)=>{
            $ZodUnion.init(inst, def);
            ZodType.init(inst, def);
            inst.options = def.options;
        });
        function union(options, params) {
            return new ZodUnion({
                type: "union",
                options: options,
                ...normalizeParams(params)
            });
        }
        const ZodDiscriminatedUnion = /*@__PURE__*/ $constructor("ZodDiscriminatedUnion", (inst, def)=>{
            ZodUnion.init(inst, def);
            $ZodDiscriminatedUnion.init(inst, def);
        });
        function discriminatedUnion(discriminator, options, params) {
            return new ZodDiscriminatedUnion({
                type: "union",
                options,
                discriminator,
                ...normalizeParams(params)
            });
        }
        const ZodIntersection = /*@__PURE__*/ $constructor("ZodIntersection", (inst, def)=>{
            $ZodIntersection.init(inst, def);
            ZodType.init(inst, def);
        });
        function intersection(left, right) {
            return new ZodIntersection({
                type: "intersection",
                left: left,
                right: right
            });
        }
        const ZodRecord = /*@__PURE__*/ $constructor("ZodRecord", (inst, def)=>{
            $ZodRecord.init(inst, def);
            ZodType.init(inst, def);
            inst.keyType = def.keyType;
            inst.valueType = def.valueType;
        });
        function record(keyType, valueType, params) {
            return new ZodRecord({
                type: "record",
                keyType,
                valueType: valueType,
                ...normalizeParams(params)
            });
        }
        const ZodEnum = /*@__PURE__*/ $constructor("ZodEnum", (inst, def)=>{
            $ZodEnum.init(inst, def);
            ZodType.init(inst, def);
            inst.enum = def.entries;
            inst.options = Object.values(def.entries);
            const keys = new Set(Object.keys(def.entries));
            inst.extract = (values, params)=>{
                const newEntries = {};
                for (const value of values)if (keys.has(value)) newEntries[value] = def.entries[value];
                else throw new Error(`Key ${value} not found in enum`);
                return new ZodEnum({
                    ...def,
                    checks: [],
                    ...normalizeParams(params),
                    entries: newEntries
                });
            };
            inst.exclude = (values, params)=>{
                const newEntries = {
                    ...def.entries
                };
                for (const value of values)if (keys.has(value)) delete newEntries[value];
                else throw new Error(`Key ${value} not found in enum`);
                return new ZodEnum({
                    ...def,
                    checks: [],
                    ...normalizeParams(params),
                    entries: newEntries
                });
            };
        });
        function schemas_enum(values, params) {
            const entries = Array.isArray(values) ? Object.fromEntries(values.map((v)=>[
                    v,
                    v
                ])) : values;
            return new ZodEnum({
                type: "enum",
                entries,
                ...normalizeParams(params)
            });
        }
        const ZodLiteral = /*@__PURE__*/ $constructor("ZodLiteral", (inst, def)=>{
            $ZodLiteral.init(inst, def);
            ZodType.init(inst, def);
            inst.values = new Set(def.values);
            Object.defineProperty(inst, "value", {
                get () {
                    if (def.values.length > 1) throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
                    return def.values[0];
                }
            });
        });
        function literal(value, params) {
            return new ZodLiteral({
                type: "literal",
                values: Array.isArray(value) ? value : [
                    value
                ],
                ...normalizeParams(params)
            });
        }
        const ZodTransform = /*@__PURE__*/ $constructor("ZodTransform", (inst, def)=>{
            $ZodTransform.init(inst, def);
            ZodType.init(inst, def);
            inst._zod.parse = (payload, _ctx)=>{
                payload.addIssue = (issue)=>{
                    if ("string" == typeof issue) payload.issues.push(util_issue(issue, payload.value, def));
                    else {
                        const _issue = issue;
                        if (_issue.fatal) _issue.continue = false;
                        _issue.code ?? (_issue.code = "custom");
                        _issue.input ?? (_issue.input = payload.value);
                        _issue.inst ?? (_issue.inst = inst);
                        payload.issues.push(util_issue(_issue));
                    }
                };
                const output = def.transform(payload.value, payload);
                if (output instanceof Promise) return output.then((output)=>{
                    payload.value = output;
                    return payload;
                });
                payload.value = output;
                return payload;
            };
        });
        function transform(fn) {
            return new ZodTransform({
                type: "transform",
                transform: fn
            });
        }
        const ZodOptional = /*@__PURE__*/ $constructor("ZodOptional", (inst, def)=>{
            $ZodOptional.init(inst, def);
            ZodType.init(inst, def);
            inst.unwrap = ()=>inst._zod.def.innerType;
        });
        function optional(innerType) {
            return new ZodOptional({
                type: "optional",
                innerType: innerType
            });
        }
        const ZodNullable = /*@__PURE__*/ $constructor("ZodNullable", (inst, def)=>{
            $ZodNullable.init(inst, def);
            ZodType.init(inst, def);
            inst.unwrap = ()=>inst._zod.def.innerType;
        });
        function nullable(innerType) {
            return new ZodNullable({
                type: "nullable",
                innerType: innerType
            });
        }
        const ZodDefault = /*@__PURE__*/ $constructor("ZodDefault", (inst, def)=>{
            $ZodDefault.init(inst, def);
            ZodType.init(inst, def);
            inst.unwrap = ()=>inst._zod.def.innerType;
            inst.removeDefault = inst.unwrap;
        });
        function schemas_default(innerType, defaultValue) {
            return new ZodDefault({
                type: "default",
                innerType: innerType,
                get defaultValue () {
                    return "function" == typeof defaultValue ? defaultValue() : defaultValue;
                }
            });
        }
        const ZodPrefault = /*@__PURE__*/ $constructor("ZodPrefault", (inst, def)=>{
            $ZodPrefault.init(inst, def);
            ZodType.init(inst, def);
            inst.unwrap = ()=>inst._zod.def.innerType;
        });
        function prefault(innerType, defaultValue) {
            return new ZodPrefault({
                type: "prefault",
                innerType: innerType,
                get defaultValue () {
                    return "function" == typeof defaultValue ? defaultValue() : defaultValue;
                }
            });
        }
        const ZodNonOptional = /*@__PURE__*/ $constructor("ZodNonOptional", (inst, def)=>{
            $ZodNonOptional.init(inst, def);
            ZodType.init(inst, def);
            inst.unwrap = ()=>inst._zod.def.innerType;
        });
        function nonoptional(innerType, params) {
            return new ZodNonOptional({
                type: "nonoptional",
                innerType: innerType,
                ...normalizeParams(params)
            });
        }
        const ZodCatch = /*@__PURE__*/ $constructor("ZodCatch", (inst, def)=>{
            $ZodCatch.init(inst, def);
            ZodType.init(inst, def);
            inst.unwrap = ()=>inst._zod.def.innerType;
            inst.removeCatch = inst.unwrap;
        });
        function schemas_catch(innerType, catchValue) {
            return new ZodCatch({
                type: "catch",
                innerType: innerType,
                catchValue: "function" == typeof catchValue ? catchValue : ()=>catchValue
            });
        }
        const ZodPipe = /*@__PURE__*/ $constructor("ZodPipe", (inst, def)=>{
            $ZodPipe.init(inst, def);
            ZodType.init(inst, def);
            inst.in = def.in;
            inst.out = def.out;
        });
        function schemas_pipe(in_, out) {
            return new ZodPipe({
                type: "pipe",
                in: in_,
                out: out
            });
        }
        const ZodReadonly = /*@__PURE__*/ $constructor("ZodReadonly", (inst, def)=>{
            $ZodReadonly.init(inst, def);
            ZodType.init(inst, def);
            inst.unwrap = ()=>inst._zod.def.innerType;
        });
        function readonly(innerType) {
            return new ZodReadonly({
                type: "readonly",
                innerType: innerType
            });
        }
        const ZodCustom = /*@__PURE__*/ $constructor("ZodCustom", (inst, def)=>{
            $ZodCustom.init(inst, def);
            ZodType.init(inst, def);
        });
        function refine(fn, _params = {}) {
            return _refine(ZodCustom, fn, _params);
        }
        function superRefine(fn) {
            return _superRefine(fn);
        }
        const zChartType = schemas_enum([
            'table',
            'pivotTable',
            'line',
            'column',
            'columnPercent',
            'columnParallel',
            'bar',
            'barPercent',
            'barParallel',
            'area',
            'areaPercent',
            'scatter',
            'dualAxis',
            'rose',
            'roseParallel',
            'pie',
            'donut',
            'radar',
            'funnel',
            'heatmap',
            'boxPlot',
            'histogram'
        ]);
        const zDualChartType = schemas_object({
            primary: schemas_enum([
                'line',
                'column',
                'columnParallel',
                'area',
                'scatter'
            ]).default('column'),
            secondary: schemas_enum([
                'line',
                'column',
                'columnParallel',
                'area',
                'scatter'
            ]).default('line')
        });
        const zDatum = record(schemas_string().or(schemas_number()), any());
        const zDataset = schemas_array(zDatum);
        const zDimension = schemas_object({
            id: schemas_string(),
            alias: schemas_string().optional(),
            encoding: schemas_enum([
                'xAxis',
                'yAxis',
                'angle',
                'color',
                'detail',
                'tooltip',
                'label',
                'row',
                'column'
            ]).optional()
        });
        const zDimensionGroup = schemas_object({
            id: schemas_string(),
            alias: schemas_string().optional(),
            get children () {
                return schemas_array(zDimensionGroup.or(zDimension)).optional();
            }
        });
        const zDimensions = schemas_array(zDimension);
        const zDimensionTree = schemas_array(zDimensionGroup.or(zDimension));
        const zNumFormat = schemas_object({
            type: schemas_enum([
                'number',
                'percent',
                'permille',
                'scientific'
            ]).default('number').optional(),
            ratio: schemas_number().default(1).optional(),
            symbol: schemas_string().default('').optional(),
            thousandSeparator: schemas_boolean().default(false).optional(),
            prefix: schemas_string().default('').optional(),
            suffix: schemas_string().default('').optional(),
            fractionDigits: schemas_number().default(2).optional(),
            significantDigits: schemas_number().default(0).optional(),
            roundingPriority: schemas_enum([
                'morePrecision',
                'lessPrecision'
            ]).default('morePrecision').optional(),
            roundingMode: schemas_enum([
                'floor',
                'ceil',
                'halfEven',
                'expand',
                'trunc',
                'halfFloor',
                'halfCeil',
                'halfExpand',
                'halfTrunc'
            ]).default('halfCeil').optional()
        }).optional();
        const zMeasure = schemas_object({
            id: schemas_string(),
            alias: schemas_string().optional(),
            autoFormat: schemas_boolean().optional(),
            numFormat: zNumFormat.optional(),
            format: zNumFormat.optional(),
            encoding: schemas_enum([
                'primaryYAxis',
                'secondaryYAxis',
                'xAxis',
                'yAxis',
                'angle',
                'radius',
                'size',
                'color',
                'label',
                'tooltip',
                'detail',
                'column',
                'value',
                'q1',
                'q3',
                'min',
                'max',
                'median',
                'outliers',
                'x0',
                'x1'
            ]).optional(),
            parentId: schemas_string().optional()
        });
        const zMeasureGroup = schemas_object({
            id: schemas_string(),
            alias: schemas_string().optional(),
            get children () {
                return schemas_array(zMeasureGroup.or(zMeasure)).optional();
            }
        });
        const zMeasures = schemas_array(zMeasure);
        const zMeasureTree = schemas_array(zMeasureGroup.or(zMeasure));
        const zDualMeasure = schemas_object({
            id: schemas_string(),
            primaryMeasures: schemas_array(zMeasure.omit({
                encoding: true,
                parentId: true
            })).or(zMeasure.omit({
                parentId: true,
                encoding: true
            })).optional(),
            secondaryMeasures: schemas_array(zMeasure).or(zMeasure).optional()
        });
        const zDualMeasures = schemas_array(zDualMeasure);
        const zScatterMeasure = schemas_object({
            id: schemas_string(),
            xMeasures: schemas_array(zMeasure.omit({
                parentId: true,
                encoding: true
            })).or(zMeasure).optional(),
            yMeasures: schemas_array(zMeasure.omit({
                parentId: true,
                encoding: true
            })).or(zMeasure).optional()
        });
        const zScatterMeasures = schemas_array(zScatterMeasure);
        const zFoldInfo = schemas_object({
            foldMap: record(schemas_string(), schemas_string().or(schemas_undefined())),
            statistics: schemas_object({
                min: schemas_number(),
                max: schemas_number(),
                sum: schemas_number(),
                count: schemas_number(),
                colorMin: schemas_number(),
                colorMax: schemas_number()
            }),
            measureId: schemas_string(),
            measureName: schemas_string(),
            measureValue: schemas_string()
        });
        const zUnfoldInfo = schemas_object({
            encodingX: schemas_string(),
            encodingY: schemas_string(),
            encodingColor: schemas_string(),
            encodingColorId: schemas_string(),
            encodingDetail: schemas_string(),
            encodingAngle: schemas_string(),
            colorItems: schemas_array(schemas_string()),
            colorIdMap: record(schemas_string(), schemas_object({
                id: schemas_string(),
                alias: schemas_string()
            }))
        });
        const zDatasetReshapeInfo = schemas_array(schemas_object({
            id: schemas_string(),
            index: schemas_number(),
            foldInfo: zFoldInfo,
            foldInfoList: schemas_array(zFoldInfo).nullish(),
            unfoldInfo: zUnfoldInfo
        }));
        const zEncoding = schemas_object({
            x: schemas_array(schemas_string()).nullish(),
            y: schemas_array(schemas_string()).nullish(),
            angle: schemas_array(schemas_string()).nullish(),
            radius: schemas_array(schemas_string()).nullish(),
            detail: schemas_array(schemas_string()).nullish(),
            color: schemas_array(schemas_string()).nullish(),
            size: schemas_array(schemas_string()).nullish(),
            tooltip: schemas_array(schemas_string()).nullish(),
            label: schemas_array(schemas_string()).nullish(),
            row: schemas_array(schemas_string()).nullish(),
            column: schemas_array(schemas_string()).nullish(),
            group: schemas_array(schemas_string()).nullish().describe('已弃用, 请使用颜色替代'),
            value: schemas_array(schemas_string()).nullish(),
            q1: schemas_array(schemas_string()).nullish(),
            q3: schemas_array(schemas_string()).nullish(),
            median: schemas_array(schemas_string()).nullish(),
            min: schemas_array(schemas_string()).nullish(),
            max: schemas_array(schemas_string()).nullish(),
            outliers: schemas_array(schemas_string()).nullish(),
            x0: schemas_array(schemas_string()).nullish(),
            x1: schemas_array(schemas_string()).nullish()
        });
        const EncodingEnum = {
            x: 'x',
            y: 'y',
            angle: 'angle',
            radius: 'radius',
            detail: 'detail',
            color: 'color',
            size: 'size',
            tooltip: 'tooltip',
            label: 'label',
            row: 'row',
            column: 'column',
            group: 'group'
        };
        const zDimensionEncoding = schemas_enum([
            'xAxis',
            'yAxis',
            'angle',
            'color',
            'detail',
            'tooltip',
            'label',
            'row',
            'column'
        ]);
        const DimensionEncodingEnum = {
            xAxis: 'xAxis',
            yAxis: 'yAxis',
            angle: 'angle',
            color: 'color',
            detail: 'detail',
            tooltip: 'tooltip',
            label: 'label',
            row: 'row',
            column: 'column'
        };
        const zMeasureEncoding = schemas_enum([
            'primaryYAxis',
            'secondaryYAxis',
            'xAxis',
            'yAxis',
            'angle',
            'radius',
            'size',
            'color',
            'detail',
            'column',
            'label',
            'tooltip'
        ]);
        const MeasureEncodingEnum = {
            primaryYAxis: 'primaryYAxis',
            secondaryYAxis: 'secondaryYAxis',
            xAxis: 'xAxis',
            yAxis: 'yAxis',
            angle: 'angle',
            radius: 'radius',
            size: 'size',
            color: 'color',
            detail: 'detail',
            column: 'column',
            label: 'label',
            tooltip: 'tooltip'
        };
        const zBackgroundColor = schemas_string().default('transparent').nullish();
        const zTableConfig = schemas_object({
            backgroundColor: zBackgroundColor.nullish(),
            borderColor: schemas_string().nullish(),
            bodyFontSize: schemas_number().nullish(),
            bodyFontColor: schemas_string().nullish(),
            bodyBackgroundColor: schemas_string().nullish(),
            hoverBodyBackgroundColor: schemas_string().nullish(),
            hoverBodyInlineBackgroundColor: schemas_string().nullish(),
            headerFontSize: schemas_number().nullish(),
            headerFontColor: schemas_string().nullish(),
            headerBackgroundColor: schemas_string().nullish(),
            hoverHeaderBackgroundColor: schemas_string().nullish(),
            hoverHeaderInlineBackgroundColor: schemas_string().nullish(),
            selectedBorderColor: schemas_string().nullish(),
            selectedBackgroundColor: schemas_string().nullish()
        });
        const zXBandAxis = schemas_object({
            visible: schemas_boolean().default(true).nullish(),
            labelAutoHide: schemas_boolean().default(true).nullish(),
            labelAutoHideGap: schemas_number().default(0).nullish(),
            labelAutoRotate: schemas_boolean().default(true).nullish(),
            labelAutoRotateAngleRange: schemas_array(schemas_number()).default([
                0,
                -45,
                -90
            ]).nullish(),
            labelAutoLimit: schemas_boolean().default(true).nullish(),
            labelAutoLimitLength: schemas_number().default(100).nullish(),
            label: schemas_object({
                visible: schemas_boolean().default(true).nullish(),
                labelColor: schemas_string().default('#797B85').nullish(),
                labelFontSize: schemas_number().default(12).nullish(),
                labelFontWeight: schemas_number().default(400).nullish(),
                labelAngle: schemas_number().default(0).nullish()
            }).nullish(),
            line: schemas_object({
                visible: schemas_boolean().default(true).nullish(),
                lineColor: schemas_string().default('rgba(54, 65, 89, 0.30)').nullish(),
                lineWidth: schemas_number().default(1).nullish()
            }).nullish(),
            tick: schemas_object({
                visible: schemas_boolean().default(true).nullish(),
                tickInside: schemas_boolean().default(false).nullish(),
                tickColor: schemas_string().default('rgba(54, 65, 89, 0.30)').nullish(),
                tickSize: schemas_number().default(4).nullish()
            }).nullish(),
            title: schemas_object({
                visible: schemas_boolean().default(false).nullish(),
                titleText: schemas_string().default('').nullish(),
                titleColor: schemas_string().default('#646A73').nullish(),
                titleFontSize: schemas_number().default(12).nullish(),
                titleFontWeight: schemas_number().default(400).nullish()
            }).nullish(),
            grid: schemas_object({
                visible: schemas_boolean().default(false).nullish(),
                gridColor: schemas_string().default('rgba(54, 65, 89, 0.15)').nullish(),
                gridWidth: schemas_number().default(0.5).nullish(),
                gridLineDash: schemas_array(schemas_number()).nullish()
            }).nullish()
        });
        const zYBandAxis = zXBandAxis;
        const zXLinearAxis = schemas_object({
            visible: schemas_boolean().default(true).nullish(),
            min: schemas_number().nullish(),
            max: schemas_number().nullish(),
            nice: schemas_boolean().default(true).nullish(),
            zero: schemas_boolean().default(true).nullish(),
            log: schemas_boolean().default(false).nullish(),
            logBase: schemas_number().default(10).nullish(),
            inverse: schemas_boolean().default(false).nullish(),
            numFormat: zNumFormat.nullish(),
            label: schemas_object({
                visible: schemas_boolean().default(true).nullish(),
                labelColor: schemas_string().default('#797B85').nullish(),
                labelFontSize: schemas_number().default(12).nullish(),
                labelFontWeight: schemas_number().default(400).nullish(),
                labelAngle: schemas_number().default(0).nullish()
            }).nullish(),
            line: schemas_object({
                visible: schemas_boolean().default(true).nullish(),
                lineColor: schemas_string().default('rgba(54, 65, 89, 0.30)').nullish(),
                lineWidth: schemas_number().default(1).nullish()
            }).nullish(),
            tick: schemas_object({
                visible: schemas_boolean().default(true).nullish(),
                tickInside: schemas_boolean().default(false).nullish(),
                tickColor: schemas_string().default('rgba(54, 65, 89, 0.30)').nullish(),
                tickSize: schemas_number().default(4).nullish()
            }).nullish(),
            title: schemas_object({
                visible: schemas_boolean().default(false).nullish(),
                titleText: schemas_string().default('').nullish(),
                titleColor: schemas_string().default('#646A73').nullish(),
                titleFontSize: schemas_number().default(12).nullish(),
                titleFontWeight: schemas_number().default(400).nullish()
            }).nullish(),
            grid: schemas_object({
                visible: schemas_boolean().default(false).nullish(),
                gridColor: schemas_string().default('rgba(54, 65, 89, 0.15)').nullish(),
                gridWidth: schemas_number().default(0.5).nullish(),
                gridLineDash: schemas_array(schemas_number()).nullish()
            }).nullish()
        });
        const zYLinearAxis = zXLinearAxis;
        const zCrosshairLine = schemas_object({
            visible: schemas_boolean().nullish(),
            lineColor: schemas_string().nullish(),
            labelColor: schemas_string().nullish(),
            labelVisible: schemas_boolean().nullish(),
            labelBackgroundColor: schemas_string().nullish(),
            lineDash: schemas_array(schemas_number()).nullish()
        });
        const zCrosshairRect = schemas_object({
            visible: schemas_boolean().nullish(),
            rectColor: schemas_string().nullish(),
            labelColor: schemas_string().nullish(),
            labelVisible: schemas_boolean().nullish(),
            labelBackgroundColor: schemas_string().nullish()
        });
        const zColor = schemas_object({
            colorScheme: schemas_array(schemas_string()).nullish(),
            linearColorScheme: schemas_array(schemas_string()).nullish(),
            colorMapping: record(schemas_string(), schemas_string()).nullish()
        });
        const zLinearColor = schemas_object({
            linearColorScheme: schemas_array(schemas_string()).nullish()
        });
        const zSelector = union([
            schemas_string(),
            schemas_number(),
            schemas_object({
                field: schemas_string(),
                operator: schemas_enum([
                    '=',
                    '==',
                    '!=',
                    '>',
                    '<',
                    '>=',
                    '<=',
                    'between'
                ]).nullish(),
                op: schemas_enum([
                    '=',
                    '==',
                    '!=',
                    '>',
                    '<',
                    '>=',
                    '<=',
                    'between'
                ]).nullish(),
                value: union([
                    schemas_string(),
                    schemas_number(),
                    schemas_array(union([
                        schemas_string(),
                        schemas_number()
                    ]))
                ])
            }),
            schemas_object({
                field: schemas_string(),
                operator: schemas_enum([
                    'in',
                    'not in'
                ]).nullish(),
                op: schemas_enum([
                    'in',
                    'not in'
                ]).nullish(),
                value: union([
                    schemas_string(),
                    schemas_number(),
                    schemas_array(union([
                        schemas_string(),
                        schemas_number()
                    ]))
                ])
            })
        ]);
        const zSelectors = schemas_array(zSelector);
        const zLabel = schemas_object({
            enable: schemas_boolean().nullish(),
            wrap: schemas_boolean().nullish(),
            showValue: schemas_boolean().nullish(),
            showValuePercent: schemas_boolean().nullish(),
            showDimension: schemas_boolean().nullish(),
            autoFormat: schemas_boolean().nullish(),
            numFormat: zNumFormat.nullish(),
            labelFontSize: schemas_number().nullish(),
            labelFontWeight: schemas_number().or(schemas_string()).nullish(),
            labelBackgroundColor: schemas_string().nullish(),
            labelColor: schemas_string().nullish(),
            labelColorSmartInvert: schemas_boolean().nullish(),
            labelPosition: schemas_string().nullish(),
            labelOverlap: schemas_boolean().nullish(),
            selector: union([
                zSelector,
                zSelectors
            ]).nullish()
        });
        const zLegend = schemas_object({
            enable: schemas_boolean().default(true).nullish(),
            border: schemas_boolean().default(true).nullish(),
            maxSize: schemas_number().default(1).nullish(),
            shapeType: schemas_enum([
                'circle',
                'cross',
                'diamond',
                'square',
                'arrow',
                'arrow2Left',
                'arrow2Right',
                'wedge',
                'thinTriangle',
                'triangle',
                'triangleUp',
                'triangleDown',
                'triangleRight',
                'triangleLeft',
                'stroke',
                'star',
                'wye',
                'rect',
                'arrowLeft',
                'arrowRight',
                'rectRound',
                'roundLine'
            ]).default('rectRound').nullish(),
            position: schemas_enum([
                'left',
                'leftTop',
                'leftBottom',
                'lt',
                'lb',
                'top',
                'topLeft',
                'topRight',
                'tl',
                'tr',
                'right',
                'rightTop',
                'rightBottom',
                'rt',
                'rb',
                'bottom',
                'bottomLeft',
                'bottomRight',
                'bl',
                'br'
            ]).default('bottom').nullish(),
            labelColor: schemas_string().default('#fff').nullish(),
            pagerIconColor: schemas_string().nullish(),
            pagerIconDisableColor: schemas_string().nullish(),
            labelFontSize: schemas_number().default(12).nullish(),
            labelFontWeight: schemas_number().or(schemas_string()).default(400).nullish()
        });
        const zColorLegend = schemas_object({
            position: schemas_enum([
                'left',
                'leftTop',
                'leftBottom',
                'lt',
                'lb',
                'top',
                'topLeft',
                'topRight',
                'tl',
                'tr',
                'right',
                'rightTop',
                'rightBottom',
                'rt',
                'rb',
                'bottom',
                'bottomLeft',
                'bottomRight',
                'bl',
                'br'
            ]).default('bottom').nullish(),
            enable: schemas_boolean().default(true).nullish()
        });
        const zTooltip = schemas_object({
            enable: schemas_boolean().default(true).nullish(),
            borderColor: schemas_string().nullish(),
            borderWidth: schemas_number().nullish(),
            borderRadius: schemas_number().nullish(),
            padding: schemas_number().or(schemas_array(schemas_number()).length(4)).nullish(),
            backgroundColor: schemas_string().nullish(),
            lineHeight: schemas_number().nullish(),
            fontSize: schemas_number().nullish(),
            lineSpace: schemas_number().nullish(),
            keyColor: schemas_string().nullish(),
            valueColor: schemas_string().nullish(),
            titleColor: schemas_string().nullish()
        });
        const zAnnotationPoint = schemas_object({
            selector: union([
                zSelector,
                zSelectors
            ]).nullish(),
            text: schemas_string().or(schemas_array(schemas_string())).nullish(),
            textColor: schemas_string().default('#ffffff').nullish(),
            textFontSize: schemas_number().default(12).nullish(),
            textFontWeight: schemas_number().default(400).nullish(),
            textAlign: schemas_enum([
                'left',
                'right',
                'center'
            ]).default('center').nullish(),
            textBaseline: schemas_enum([
                'top',
                'middle',
                'bottom'
            ]).default('middle').nullish(),
            textBackgroundVisible: schemas_boolean().default(true).nullish(),
            textBackgroundColor: schemas_string().default('#212121').nullish(),
            textBackgroundBorderColor: schemas_string().nullish(),
            textBackgroundBorderWidth: schemas_number().default(1).nullish(),
            textBackgroundBorderRadius: schemas_number().default(4).nullish(),
            textBackgroundPadding: schemas_number().nullish(),
            offsetY: schemas_number().default(0).nullish(),
            offsetX: schemas_number().default(0).nullish()
        });
        const zAnnotationHorizontalLine = schemas_object({
            selector: union([
                zSelector,
                zSelectors
            ]).nullish(),
            yValue: union([
                schemas_number(),
                schemas_string(),
                schemas_array(union([
                    schemas_number(),
                    schemas_string()
                ]))
            ]).nullish(),
            text: schemas_string().or(schemas_array(schemas_string())).nullish(),
            textPosition: schemas_enum([
                'outsideStart',
                'outsideEnd',
                'outsideMiddle',
                'insideStart',
                'insideMiddle',
                'insideEnd'
            ]).default('insideEnd').nullish(),
            textColor: schemas_string().default('#ffffff').nullish(),
            textFontSize: schemas_number().default(12).nullish(),
            textFontWeight: schemas_number().default(400).nullish(),
            textAlign: schemas_enum([
                'left',
                'right',
                'center'
            ]).default('right').nullish(),
            textBaseline: schemas_enum([
                'top',
                'middle',
                'bottom'
            ]).default('top').nullish(),
            lineVisible: schemas_boolean().default(true).nullish(),
            lineColor: schemas_string().default('#212121').nullish(),
            lineWidth: schemas_number().default(1).nullish(),
            lineStyle: union([
                literal('solid'),
                literal('dashed'),
                literal('dotted')
            ]).default('dashed').nullish(),
            textBackgroundVisible: schemas_boolean().default(true).nullish(),
            textBackgroundColor: schemas_string().default('#212121').nullish(),
            textBackgroundBorderColor: schemas_string().default('#212121').nullish(),
            textBackgroundBorderRadius: schemas_number().default(4).nullish(),
            textBackgroundBorderWidth: schemas_number().default(1).nullish(),
            textBackgroundPadding: schemas_number().default(2).nullish()
        });
        const zAnnotationArea = schemas_object({
            selector: union([
                zSelector,
                zSelectors
            ]).nullish(),
            textPosition: schemas_enum([
                'top',
                'topRight',
                'topLeft',
                'bottom',
                'bottomLeft',
                'bottomRight',
                'left',
                'right'
            ]).default('top').nullish(),
            text: schemas_string().or(schemas_array(schemas_string())).nullish(),
            textColor: schemas_string().default('#ffffff').nullish(),
            textFontSize: schemas_number().default(12).nullish(),
            textFontWeight: schemas_number().default(400).nullish(),
            textAlign: schemas_enum([
                'left',
                'right',
                'center'
            ]).default('center').nullish(),
            textBaseline: schemas_enum([
                'top',
                'middle',
                'bottom'
            ]).default('top').nullish(),
            textBackgroundVisible: schemas_boolean().default(true).nullish(),
            textBackgroundColor: schemas_string().default('#191d24').nullish(),
            textBackgroundBorderColor: schemas_string().default('#191d24').nullish(),
            textBackgroundBorderWidth: schemas_number().default(1).nullish(),
            textBackgroundBorderRadius: schemas_number().default(4).nullish(),
            textBackgroundPadding: schemas_number().default(4).nullish(),
            areaColor: schemas_string().default('#888888').nullish(),
            areaColorOpacity: schemas_number().default(0.15).nullish(),
            areaBorderColor: schemas_string().default('#888888').nullish(),
            areaBorderWidth: schemas_number().default(1).nullish(),
            areaBorderRadius: schemas_number().default(4).nullish(),
            areaLineDash: schemas_array(schemas_number()).nullish(),
            outerPadding: schemas_number().default(4).nullish()
        });
        const zAnnotationPointConfig = zAnnotationPoint.omit({
            selector: true,
            text: true
        }).partial();
        const zAnnotationHorizontalLineConfig = zAnnotationHorizontalLine.pick({
            lineColor: true,
            lineWidth: true,
            lineVisible: true,
            lineStyle: true,
            textBackgroundVisible: true,
            textColor: true,
            textFontSize: true,
            textFontWeight: true,
            textBackgroundColor: true,
            textBackgroundBorderColor: true,
            textBackgroundBorderWidth: true,
            textBackgroundBorderRadius: true,
            textBackgroundPadding: true
        }).extend({
            endSymbolVisible: schemas_boolean().nullish(),
            endSymbolType: schemas_string().nullish(),
            endSymbolSize: schemas_number().nullish(),
            startSymbolVisible: schemas_boolean().nullish(),
            startSymbolType: schemas_string().nullish(),
            startSymbolSize: schemas_number().nullish()
        }).partial();
        const zAnnotationVerticalLineConfig = zAnnotationHorizontalLineConfig.clone();
        const zAnnotationAreaConfig = zAnnotationArea.pick({
            textColor: true,
            textFontSize: true,
            textFontWeight: true,
            textBackgroundVisible: true,
            textBackgroundColor: true,
            textBackgroundBorderColor: true,
            textBackgroundBorderWidth: true,
            textBackgroundBorderRadius: true,
            textBackgroundPadding: true,
            areaColor: true,
            areaColorOpacity: true,
            areaBorderColor: true,
            areaBorderWidth: true,
            areaBorderRadius: true,
            areaLineDash: true,
            outerPadding: true
        }).partial();
        const zAnnotationConfig = schemas_object({
            annotationPoint: zAnnotationPointConfig.nullish(),
            annotationHorizontalLine: zAnnotationHorizontalLineConfig.nullish(),
            annotationVerticalLine: zAnnotationVerticalLineConfig.nullish(),
            annotationArea: zAnnotationAreaConfig.nullish()
        });
        const zPivotChartGridConfig = schemas_object({
            borderColor: schemas_string().nullish(),
            bodyFontColor: schemas_string().nullish(),
            headerFontColor: schemas_string().nullish(),
            headerBackgroundColor: schemas_string().nullish(),
            hoverHeaderBackgroundColor: schemas_string().nullish(),
            hoverHeaderInlineBackgroundColor: schemas_string().nullish(),
            outlineBorderLineWidth: schemas_number().nullish(),
            frameCornerRadius: schemas_number().nullish(),
            minChartWidth: schemas_number().nullish(),
            minChartHeight: schemas_number().nullish(),
            titleFontColor: schemas_string().nullish(),
            titleFontSize: schemas_number().nullish(),
            titleFontWeight: schemas_string().nullish(),
            chartGridColor: schemas_string().nullish(),
            axisLabelColor: schemas_string().nullish()
        });
        const zDimensionLinkage = schemas_object({
            enable: schemas_boolean().nullish(),
            showTooltip: schemas_boolean().nullish(),
            showLabel: schemas_boolean().nullish()
        });
        const zLineConfig = schemas_object({
            backgroundColor: zBackgroundColor.nullish(),
            label: zLabel.nullish(),
            color: zColor.nullish(),
            tooltip: zTooltip.nullish(),
            legend: zLegend.nullish(),
            xAxis: zXBandAxis.nullish(),
            yAxis: zYLinearAxis.nullish(),
            crosshairLine: zCrosshairLine.nullish(),
            pivotGrid: zPivotChartGridConfig.nullish(),
            annotation: zAnnotationConfig.nullish(),
            dimensionLinkage: zDimensionLinkage.nullish()
        });
        const zStackCornerRadius = schemas_number().or(schemas_array(schemas_number())).default([
            3,
            3,
            0,
            0
        ]);
        const zBarMaxWidth = schemas_number().or(schemas_string());
        const zBarGapInGroup = schemas_number().or(schemas_string());
        const zEcdfRegressionLine = schemas_object({
            enable: schemas_boolean().nullish(),
            color: schemas_string().nullish(),
            lineWidth: schemas_number().nullish(),
            lineDash: schemas_array(schemas_number()).nullish(),
            text: schemas_string().nullish(),
            textColor: schemas_string().nullish(),
            textFontSize: schemas_number().nullish(),
            textFontWeight: schemas_number().nullish()
        });
        const zKdeRegressionLine = zEcdfRegressionLine.extend({});
        const zLinearRegressionLine = zEcdfRegressionLine.extend({
            confidenceIntervalVisible: schemas_boolean().nullish(),
            confidenceIntervalColor: schemas_string().nullish(),
            confidenceIntervalOpacity: schemas_number().nullish()
        });
        const zLogisticRegressionLine = zLinearRegressionLine.extend({});
        const zLowessRegressionLine = zLinearRegressionLine.extend({});
        const zPolynomialRegressionLine = zLinearRegressionLine.extend({
            degree: schemas_number().nullish()
        });
        const zRegressionLine = schemas_object({
            ecdfRegressionLine: zEcdfRegressionLine.or(schemas_array(zEcdfRegressionLine)).nullish(),
            kdeRegressionLine: zKdeRegressionLine.or(schemas_array(zKdeRegressionLine)).nullish(),
            linearRegressionLine: zLinearRegressionLine.or(schemas_array(zLinearRegressionLine)).nullish(),
            lowessRegressionLine: zLowessRegressionLine.or(schemas_array(zLowessRegressionLine)).nullish(),
            polynomialRegressionLine: zPolynomialRegressionLine.or(schemas_array(zPolynomialRegressionLine)).nullish(),
            logisticRegressionLine: zLogisticRegressionLine.or(schemas_array(zLogisticRegressionLine)).nullish()
        });
        const zColumnParallelConfig = schemas_object({
            backgroundColor: zBackgroundColor.nullish(),
            label: zLabel.nullish(),
            color: zColor.nullish(),
            tooltip: zTooltip.nullish(),
            legend: zLegend.nullish(),
            xAxis: zXBandAxis.nullish(),
            yAxis: zYLinearAxis.nullish(),
            crosshairRect: zCrosshairRect.nullish(),
            stackCornerRadius: zStackCornerRadius.nullish(),
            barMaxWidth: zBarMaxWidth.nullish(),
            barGapInGroup: zBarGapInGroup.nullish(),
            pivotGrid: zPivotChartGridConfig.nullish(),
            annotation: zAnnotationConfig.nullish(),
            dimensionLinkage: zDimensionLinkage.nullish()
        });
        const zColumnConfig = zColumnParallelConfig.extend({
            regressionLine: zRegressionLine.nullish()
        });
        const zColumnPercentConfig = zColumnParallelConfig.extend({});
        const zBarConfig = schemas_object({
            backgroundColor: zBackgroundColor.nullish(),
            label: zLabel.nullish(),
            color: zColor.nullish(),
            tooltip: zTooltip.nullish(),
            legend: zLegend.nullish(),
            xAxis: zXLinearAxis.nullish(),
            yAxis: zYBandAxis.nullish(),
            crosshairRect: zCrosshairRect.nullish(),
            stackCornerRadius: zStackCornerRadius.nullish(),
            pivotGrid: zPivotChartGridConfig.nullish(),
            annotation: zAnnotationConfig.nullish(),
            dimensionLinkage: zDimensionLinkage.nullish()
        });
        const zBarParallelConfig = zBarConfig;
        const zBarPercentConfig = zBarConfig;
        const zAreaConfig = schemas_object({
            backgroundColor: zBackgroundColor.nullish(),
            label: zLabel.nullish(),
            color: zColor.nullish(),
            tooltip: zTooltip.nullish(),
            legend: zLegend.nullish(),
            xAxis: zXBandAxis.nullish(),
            yAxis: zYLinearAxis.nullish(),
            crosshairLine: zCrosshairLine.nullish(),
            pivotGrid: zPivotChartGridConfig.nullish(),
            annotation: zAnnotationConfig.nullish(),
            dimensionLinkage: zDimensionLinkage.nullish()
        });
        const zAreaPercentConfig = zAreaConfig;
        const zScatterConfig = schemas_object({
            backgroundColor: zBackgroundColor.nullish(),
            label: zLabel.nullish(),
            color: zColor.nullish(),
            tooltip: zTooltip.nullish(),
            legend: zLegend.nullish(),
            xAxis: zXLinearAxis.nullish(),
            yAxis: zYLinearAxis.nullish(),
            crosshairLine: zCrosshairLine.nullish(),
            size: schemas_number().or(schemas_array(schemas_number())).nullish(),
            sizeRange: schemas_number().or(schemas_array(schemas_number())).nullish(),
            pivotGrid: zPivotChartGridConfig.nullish(),
            annotation: zAnnotationConfig.nullish(),
            regressionLine: zRegressionLine.nullish(),
            dimensionLinkage: zDimensionLinkage.nullish()
        });
        const zDualAxisConfig = schemas_object({
            backgroundColor: zBackgroundColor.nullish(),
            label: zLabel.nullish(),
            color: zColor.nullish(),
            tooltip: zTooltip.nullish(),
            legend: zLegend.nullish(),
            dualChartType: schemas_array(zDualChartType).or(zDualChartType).nullish(),
            alignTicks: schemas_array(schemas_boolean()).or(schemas_boolean()).nullish(),
            primaryYAxis: schemas_array(zYLinearAxis).or(zYLinearAxis).nullish(),
            secondaryYAxis: schemas_array(zYLinearAxis).or(zYLinearAxis).nullish(),
            xAxis: zXBandAxis.nullish(),
            crosshairRect: zCrosshairRect.nullish(),
            pivotGrid: zPivotChartGridConfig.nullish(),
            annotation: zAnnotationConfig.nullish(),
            dimensionLinkage: zDimensionLinkage.nullish()
        });
        const zPieLabel = zLabel.extend({
            labelLayout: union([
                literal('arc'),
                literal('labelLine'),
                literal('edge')
            ]).nullish()
        });
        const zPieConfig = schemas_object({
            backgroundColor: zBackgroundColor.nullish(),
            label: zPieLabel.nullish(),
            color: zColor.nullish(),
            tooltip: zTooltip.nullish(),
            legend: zLegend.nullish(),
            pivotGrid: zPivotChartGridConfig.nullish(),
            cornerRadius: schemas_number().nullish()
        });
        const zDonutConfig = zPieConfig;
        const zRadarConfig = zPieConfig;
        const zRoseConfig = schemas_object({
            backgroundColor: zBackgroundColor.nullish(),
            label: zPieLabel.nullish(),
            color: zColor.nullish(),
            tooltip: zTooltip.nullish(),
            legend: zLegend.nullish(),
            pivotGrid: zPivotChartGridConfig.nullish()
        });
        const zRoseParallelConfig = zRoseConfig;
        const zFunnelTransform = schemas_object({
            backgroundColor: schemas_string().nullish(),
            textColor: schemas_string().nullish()
        });
        const zFunnelConfig = schemas_object({
            backgroundColor: zBackgroundColor.nullish(),
            label: zLabel.nullish(),
            color: zColor.nullish(),
            tooltip: zTooltip.nullish(),
            legend: zLegend.nullish(),
            pivotGrid: zPivotChartGridConfig.nullish(),
            transform: zFunnelTransform.nullish()
        });
        const zHeatmapCell = schemas_object({
            stroke: schemas_string().nullish(),
            lineWidth: schemas_number().nullish(),
            cornerRadius: schemas_number().nullish()
        });
        const zHeatmapConfig = schemas_object({
            backgroundColor: zBackgroundColor.nullish(),
            label: zLabel.nullish(),
            color: zColor.nullish(),
            tooltip: zTooltip.nullish(),
            legend: zLegend.nullish(),
            pivotGrid: zPivotChartGridConfig.nullish(),
            cell: zHeatmapCell.nullish()
        });
        const zPivotTableConfig = zTableConfig;
        const zWhiskersConfig = schemas_number().or(schemas_array(schemas_number())).default(1.5);
        const zBoxPlotStyle = schemas_object({
            selector: zSelector.or(zSelectors).nullish(),
            boxVisible: schemas_boolean().nullish(),
            boxColor: schemas_string().nullish(),
            boxColorOpacity: schemas_number().min(0).max(1).nullish(),
            boxBorderColor: schemas_string().nullish(),
            boxBorderWidth: schemas_number().min(0).nullish(),
            boxBorderOpacity: schemas_number().min(0).max(1).nullish()
        });
        const zOutlierStyle = schemas_object({
            selector: union([
                zSelector,
                zSelectors
            ]).optional(),
            pointVisible: schemas_boolean().optional(),
            pointSize: schemas_number().optional(),
            pointColor: schemas_string().optional(),
            pointColorOpacity: schemas_number().min(0).max(1).optional(),
            pointBorderColor: schemas_string().optional(),
            pointBorderWidth: schemas_number().min(0).optional(),
            pointBorderStyle: schemas_enum([
                'solid',
                'dashed',
                'dotted'
            ]).optional()
        });
        const zBoxMaxWidth = schemas_number().or(schemas_string());
        const zBoxGapInGroup = schemas_number().or(schemas_string());
        const zBoxplotConfig = schemas_object({
            backgroundColor: zBackgroundColor.nullish(),
            label: zLabel.nullish(),
            color: zColor.nullish(),
            tooltip: zTooltip.nullish(),
            legend: zLegend.nullish(),
            xAxis: zXBandAxis.nullish(),
            yAxis: zYLinearAxis.nullish(),
            crosshairRect: zCrosshairRect.nullish(),
            pivotGrid: zPivotChartGridConfig.nullish(),
            annotation: zAnnotationConfig.nullish(),
            whiskers: zWhiskersConfig.nullish(),
            dimensionLinkage: zDimensionLinkage.nullish(),
            boxPlotStyle: zBoxPlotStyle.omit({
                selector: true
            }).nullish(),
            outlierStyle: zOutlierStyle.omit({
                selector: true
            }).nullish(),
            boxMaxWidth: zBoxMaxWidth.nullish(),
            boxGapInGroup: zBoxGapInGroup.nullish()
        });
        const zHistogramConfig = schemas_object({
            backgroundColor: zBackgroundColor.nullish(),
            label: zLabel.nullish(),
            color: zColor.nullish(),
            tooltip: zTooltip.nullish(),
            legend: zLegend.nullish(),
            xAxis: zXBandAxis.nullish(),
            yAxis: zYLinearAxis.nullish(),
            crosshairRect: zCrosshairRect.nullish(),
            stackCornerRadius: zStackCornerRadius.nullish(),
            pivotGrid: zPivotChartGridConfig.nullish(),
            annotation: zAnnotationConfig.nullish(),
            binCount: schemas_number().positive().nullish(),
            binStep: schemas_number().positive().nullish(),
            binValueType: literal('count').or(literal('percentage')).nullish(),
            regressionLine: zRegressionLine.nullish(),
            dimensionLinkage: zDimensionLinkage.nullish()
        });
        const zConfig = schemas_object({
            table: zTableConfig.nullish(),
            pivotTable: zPivotTableConfig.nullish(),
            line: zLineConfig.nullish(),
            column: zColumnConfig.nullish(),
            columnParallel: zColumnParallelConfig.nullish(),
            columnPercent: zColumnPercentConfig.nullish(),
            bar: zBarConfig.nullish(),
            barParallel: zBarParallelConfig.nullish(),
            barPercent: zBarPercentConfig.nullish(),
            area: zAreaConfig.nullish(),
            areaPercent: zAreaPercentConfig.nullish(),
            scatter: zScatterConfig.nullish(),
            dualAxis: zDualAxisConfig.nullish(),
            rose: zRoseConfig.nullish(),
            roseParallel: zRoseParallelConfig.nullish(),
            pie: zPieConfig.nullish(),
            donut: zDonutConfig.nullish(),
            radar: zRadarConfig.nullish(),
            funnel: zFunnelConfig.nullish(),
            heatmap: zHeatmapConfig.nullish(),
            boxPlot: zBoxplotConfig.nullish(),
            histogram: zHistogramConfig.nullish()
        });
        const zCustomThemeConfig = schemas_object({
            config: zConfig.nullish()
        });
        const zCustomTheme = record(schemas_string(), zCustomThemeConfig).nullish();
        const zTheme = schemas_string();
        const zBarStyle = schemas_object({
            selector: union([
                zSelector,
                zSelectors
            ]).nullish(),
            barVisible: schemas_boolean().nullish(),
            barColor: schemas_string().nullish(),
            barColorOpacity: schemas_number().nullish(),
            barBorderColor: schemas_string().nullish(),
            barBorderWidth: schemas_number().nullish(),
            barBorderStyle: union([
                literal('solid'),
                literal('dashed'),
                literal('dotted')
            ]).nullish(),
            barRadius: union([
                schemas_number(),
                schemas_array(schemas_number())
            ]).nullish()
        });
        const zPointStyle = schemas_object({
            selector: union([
                zSelector,
                zSelectors
            ]).nullish(),
            pointVisible: schemas_boolean().nullish(),
            pointSize: schemas_number().nullish(),
            pointColor: schemas_string().nullish(),
            pointColorOpacity: schemas_number().nullish(),
            pointBorderColor: schemas_string().nullish(),
            pointBorderWidth: schemas_number().nullish(),
            pointBorderStyle: union([
                schemas_enum([
                    'solid',
                    'dashed',
                    'dotted'
                ])
            ]).nullish()
        });
        const zLineStyle = schemas_object({
            selector: union([
                zSelector,
                zSelectors
            ]).nullish(),
            lineVisible: schemas_boolean().nullish(),
            lineSmooth: schemas_boolean().nullish(),
            lineColor: schemas_string().nullish(),
            lineColorOpacity: schemas_number().nullish(),
            lineWidth: schemas_number().nullish(),
            lineStyle: union([
                schemas_enum([
                    'solid',
                    'dashed',
                    'dotted'
                ])
            ]).nullish()
        });
        const zAreaStyle = schemas_object({
            selector: union([
                zSelector,
                zSelectors
            ]).nullish(),
            areaVisible: schemas_boolean().nullish(),
            areaColor: schemas_string().nullish(),
            areaColorOpacity: schemas_number().nullish()
        });
        const zMarkStyle = schemas_object({
            barStyle: zBarStyle.or(schemas_array(zBarStyle)).nullish(),
            pointStyle: zPointStyle.or(schemas_array(zPointStyle)).nullish(),
            lineStyle: zLineStyle.or(schemas_array(zLineStyle)).nullish(),
            areaStyle: zAreaStyle.or(schemas_array(zAreaStyle)).nullish(),
            boxPlotStyle: zBoxPlotStyle.or(schemas_array(zBoxPlotStyle)).nullish(),
            outlierStyle: zOutlierStyle.or(schemas_array(zOutlierStyle)).nullish()
        });
        const zAnnotationVerticalLine = schemas_object({
            selector: union([
                zSelector,
                zSelectors
            ]).nullish(),
            xValue: union([
                schemas_number(),
                schemas_string(),
                schemas_array(union([
                    schemas_number(),
                    schemas_string()
                ]))
            ]).nullish(),
            text: schemas_string().or(schemas_array(schemas_string())).nullish(),
            textPosition: schemas_enum([
                'outsideStart',
                'outsideEnd',
                'outsideMiddle',
                'insideStart',
                'insideMiddle',
                'insideEnd'
            ]).default('insideEnd').nullish(),
            textColor: schemas_string().default('#ffffff').nullish(),
            textFontSize: schemas_number().default(12).nullish(),
            textFontWeight: schemas_number().default(400).nullish(),
            textAlign: schemas_enum([
                'left',
                'right',
                'center'
            ]).default('right').nullish(),
            textBaseline: schemas_enum([
                'top',
                'middle',
                'bottom'
            ]).default('top').nullish(),
            textBackgroundVisible: schemas_boolean().default(true).nullish(),
            textBackgroundColor: schemas_string().default('#212121').nullish(),
            textBackgroundBorderColor: schemas_string().default('#212121').nullish(),
            textBackgroundBorderRadius: schemas_number().default(4).nullish(),
            textBackgroundBorderWidth: schemas_number().default(1).nullish(),
            textBackgroundPadding: schemas_number().default(2).nullish(),
            lineVisible: schemas_boolean().default(true).nullish(),
            lineColor: schemas_string().default('#212121').nullish(),
            lineWidth: schemas_number().default(1).nullish(),
            lineStyle: union([
                literal('solid'),
                literal('dashed'),
                literal('dotted')
            ]).default('dashed').nullish()
        });
        const zAnnotation = schemas_object({
            annotationPoint: zAnnotationPoint.or(schemas_array(zAnnotationPoint)).nullish(),
            annotationVerticalLine: zAnnotationVerticalLine.or(schemas_array(zAnnotationVerticalLine)).nullish(),
            annotationHorizontalLine: zAnnotationHorizontalLine.or(schemas_array(zAnnotationHorizontalLine)).nullish(),
            annotationArea: zAnnotationArea.or(schemas_array(zAnnotationArea)).nullish()
        });
        const zSort = schemas_object({
            order: schemas_enum([
                'asc',
                'desc'
            ]).default('asc'),
            orderBy: schemas_string().nullish(),
            customOrder: schemas_array(any()).nullish()
        });
        const zSortLegend = schemas_object({
            order: schemas_enum([
                'asc',
                'desc'
            ]).default('asc'),
            orderBy: schemas_string().nullish(),
            customOrder: schemas_array(any()).nullish()
        });
        const zAnalysis = schemas_object({
            orderMapping: record(schemas_string(), schemas_array(schemas_string())).nullish()
        });
        const zBodyCellStyle = schemas_object({
            selector: union([
                zSelector,
                zSelectors
            ]).nullish(),
            backgroundColor: schemas_string().nullish(),
            textColor: schemas_string().nullish(),
            textFontSize: schemas_number().nullish(),
            borderColor: schemas_string().nullish(),
            borderLineWidth: schemas_number().nullish()
        });
        const zLocale = schemas_enum([
            'zh-CN',
            'en-US'
        ]).default('zh-CN');
        const zTable = schemas_object({
            chartType: literal('table'),
            dataset: zDataset.nullish(),
            dimensions: zDimensions.nullish(),
            measures: zMeasureTree.nullish(),
            backgroundColor: zBackgroundColor.nullish(),
            borderColor: schemas_string().nullish(),
            bodyFontSize: schemas_number().nullish(),
            bodyFontColor: schemas_string().nullish(),
            bodyBackgroundColor: schemas_string().nullish(),
            hoverBodyBackgroundColor: schemas_string().nullish(),
            hoverBodyInlineBackgroundColor: schemas_string().nullish(),
            headerFontSize: schemas_number().nullish(),
            headerFontColor: schemas_string().nullish(),
            headerBackgroundColor: schemas_string().nullish(),
            hoverHeaderBackgroundColor: schemas_string().nullish(),
            hoverHeaderInlineBackgroundColor: schemas_string().nullish(),
            selectedBorderColor: schemas_string().nullish(),
            selectedBackgroundColor: schemas_string().nullish(),
            bodyCellStyle: zBodyCellStyle.nullish(),
            theme: zTheme.nullish(),
            locale: zLocale.nullish()
        });
        const zPivotTable = schemas_object({
            chartType: literal('pivotTable'),
            dataset: zDataset.nullish(),
            dimensions: zDimensions.nullish(),
            measures: zMeasures.nullish(),
            backgroundColor: zBackgroundColor.nullish(),
            borderColor: schemas_string().nullish(),
            bodyFontSize: schemas_number().nullish(),
            bodyFontColor: schemas_string().nullish(),
            bodyBackgroundColor: schemas_string().nullish(),
            hoverBodyBackgroundColor: schemas_string().nullish(),
            hoverBodyInlineBackgroundColor: schemas_string().nullish(),
            headerFontSize: schemas_number().nullish(),
            headerFontColor: schemas_string().nullish(),
            headerBackgroundColor: schemas_string().nullish(),
            hoverHeaderBackgroundColor: schemas_string().nullish(),
            hoverHeaderInlineBackgroundColor: schemas_string().nullish(),
            selectedBorderColor: schemas_string().nullish(),
            selectedBackgroundColor: schemas_string().nullish(),
            bodyCellStyle: zBodyCellStyle.nullish(),
            theme: zTheme.nullish(),
            locale: zLocale.nullish()
        });
        const zLine = schemas_object({
            chartType: literal('line'),
            dataset: zDataset.nullish(),
            encoding: zEncoding.nullish(),
            dimensions: zDimensions.nullish(),
            measures: zMeasureTree.nullish(),
            backgroundColor: zBackgroundColor.nullish(),
            color: zColor.nullish(),
            label: zLabel.nullish(),
            legend: zLegend.nullish(),
            tooltip: zTooltip.nullish(),
            xAxis: zXBandAxis.nullish(),
            yAxis: zYLinearAxis.nullish(),
            crosshairLine: zCrosshairLine.nullish(),
            sort: zSort.nullish(),
            sortLegend: zSortLegend.nullish(),
            theme: zTheme.nullish(),
            pointStyle: schemas_array(zPointStyle).or(zPointStyle).nullish(),
            lineStyle: schemas_array(zLineStyle).or(zLineStyle).nullish(),
            annotationPoint: schemas_array(zAnnotationPoint).or(zAnnotationPoint).nullish(),
            annotationVerticalLine: schemas_array(zAnnotationVerticalLine).or(zAnnotationVerticalLine).nullish(),
            annotationHorizontalLine: schemas_array(zAnnotationHorizontalLine).or(zAnnotationHorizontalLine).nullish(),
            annotationArea: schemas_array(zAnnotationArea).or(zAnnotationArea).nullish(),
            dimensionLinkage: zDimensionLinkage.nullish(),
            locale: zLocale.nullish()
        });
        const zColumn = schemas_object({
            chartType: literal('column'),
            dataset: zDataset.nullish(),
            encoding: zEncoding.nullish(),
            dimensions: zDimensions.nullish(),
            measures: zMeasureTree.nullish(),
            backgroundColor: zBackgroundColor.nullish(),
            color: zColor.nullish(),
            label: zLabel.nullish(),
            legend: zLegend.nullish(),
            tooltip: zTooltip.nullish(),
            xAxis: zXBandAxis.nullish(),
            yAxis: zYLinearAxis.nullish(),
            sort: zSort.nullish(),
            sortLegent: zSortLegend.nullish(),
            crosshairRect: zCrosshairRect.nullish(),
            stackCornerRadius: zStackCornerRadius.nullish(),
            barMaxWidth: zBarMaxWidth.nullish(),
            theme: zTheme.nullish(),
            barStyle: schemas_array(zBarStyle).or(zBarStyle).nullish(),
            annotationPoint: schemas_array(zAnnotationPoint).or(zAnnotationPoint).nullish(),
            annotationVerticalLine: schemas_array(zAnnotationVerticalLine).or(zAnnotationVerticalLine).nullish(),
            annotationHorizontalLine: schemas_array(zAnnotationHorizontalLine).or(zAnnotationHorizontalLine).nullish(),
            annotationArea: schemas_array(zAnnotationArea).or(zAnnotationArea).nullish(),
            polynomialRegressionLine: schemas_array(zPolynomialRegressionLine).or(zPolynomialRegressionLine).nullish(),
            dimensionLinkage: zDimensionLinkage.nullish(),
            locale: zLocale.nullish()
        });
        const zColumnParallel = schemas_object({
            chartType: literal('columnParallel'),
            dataset: zDataset.nullish(),
            encoding: zEncoding.nullish(),
            dimensions: zDimensions.nullish(),
            measures: zMeasureTree.nullish(),
            backgroundColor: zBackgroundColor.nullish(),
            color: zColor.nullish(),
            label: zLabel.nullish(),
            legend: zLegend.nullish(),
            tooltip: zTooltip.nullish(),
            xAxis: zXBandAxis.nullish(),
            yAxis: zYLinearAxis.nullish(),
            crosshairRect: zCrosshairRect.nullish(),
            stackCornerRadius: zStackCornerRadius.nullish(),
            barMaxWidth: zBarMaxWidth.nullish(),
            barGapInGroup: zBarGapInGroup.nullish(),
            theme: zTheme.nullish(),
            barStyle: schemas_array(zBarStyle).or(zBarStyle).nullish(),
            annotationPoint: schemas_array(zAnnotationPoint).or(zAnnotationPoint).nullish(),
            annotationVerticalLine: schemas_array(zAnnotationVerticalLine).or(zAnnotationVerticalLine).nullish(),
            annotationHorizontalLine: schemas_array(zAnnotationHorizontalLine).or(zAnnotationHorizontalLine).nullish(),
            annotationArea: schemas_array(zAnnotationArea).or(zAnnotationArea).nullish(),
            dimensionLinkage: zDimensionLinkage.nullish(),
            locale: zLocale.nullish()
        });
        const zColumnPercent = schemas_object({
            chartType: literal('columnPercent'),
            dataset: zDataset.nullish(),
            encoding: zEncoding.nullish(),
            dimensions: zDimensions.nullish(),
            measures: zMeasureTree.nullish(),
            backgroundColor: zBackgroundColor.nullish(),
            color: zColor.nullish(),
            label: zLabel.nullish(),
            legend: zLegend.nullish(),
            tooltip: zTooltip.nullish(),
            xAxis: zXBandAxis.nullish(),
            yAxis: zYLinearAxis.nullish(),
            crosshairRect: zCrosshairRect.nullish(),
            stackCornerRadius: zStackCornerRadius.nullish(),
            barMaxWidth: zBarMaxWidth.nullish(),
            theme: zTheme.nullish(),
            barStyle: schemas_array(zBarStyle).or(zBarStyle).nullish(),
            annotationPoint: schemas_array(zAnnotationPoint).or(zAnnotationPoint).nullish(),
            annotationVerticalLine: schemas_array(zAnnotationVerticalLine).or(zAnnotationVerticalLine).nullish(),
            annotationHorizontalLine: schemas_array(zAnnotationHorizontalLine).or(zAnnotationHorizontalLine).nullish(),
            annotationArea: schemas_array(zAnnotationArea).or(zAnnotationArea).nullish(),
            dimensionLinkage: zDimensionLinkage.nullish(),
            locale: zLocale.nullish()
        });
        const zBar = schemas_object({
            chartType: literal('bar'),
            dataset: zDataset.nullish(),
            encoding: zEncoding.nullish(),
            dimensions: zDimensions.nullish(),
            measures: zMeasureTree.nullish(),
            backgroundColor: zBackgroundColor.nullish(),
            color: zColor.nullish(),
            label: zLabel.nullish(),
            legend: zLegend.nullish(),
            tooltip: zTooltip.nullish(),
            xAxis: zXLinearAxis.nullish(),
            yAxis: zYBandAxis.nullish(),
            crosshairRect: zCrosshairRect.nullish(),
            stackCornerRadius: zStackCornerRadius.nullish(),
            barMaxWidth: zBarMaxWidth.nullish(),
            theme: zTheme.nullish(),
            barStyle: schemas_array(zBarStyle).or(zBarStyle).nullish(),
            annotationPoint: schemas_array(zAnnotationPoint).or(zAnnotationPoint).nullish(),
            annotationVerticalLine: schemas_array(zAnnotationVerticalLine).or(zAnnotationVerticalLine).nullish(),
            annotationHorizontalLine: schemas_array(zAnnotationHorizontalLine).or(zAnnotationHorizontalLine).nullish(),
            annotationArea: schemas_array(zAnnotationArea).or(zAnnotationArea).nullish(),
            dimensionLinkage: zDimensionLinkage.nullish(),
            locale: zLocale.nullish()
        });
        const zBarParallel = schemas_object({
            chartType: literal('barParallel'),
            dataset: zDataset.nullish(),
            encoding: zEncoding.nullish(),
            dimensions: zDimensions.nullish(),
            measures: zMeasureTree.nullish(),
            backgroundColor: zBackgroundColor.nullish(),
            color: zColor.nullish(),
            label: zLabel.nullish(),
            legend: zLegend.nullish(),
            tooltip: zTooltip.nullish(),
            xAxis: zXLinearAxis.nullish(),
            yAxis: zYBandAxis.nullish(),
            crosshairRect: zCrosshairRect.nullish(),
            stackCornerRadius: zStackCornerRadius.nullish(),
            barMaxWidth: zBarMaxWidth.nullish(),
            barGapInGroup: zBarGapInGroup.nullish(),
            theme: zTheme.nullish(),
            barStyle: schemas_array(zBarStyle).or(zBarStyle).nullish(),
            annotationPoint: schemas_array(zAnnotationPoint).or(zAnnotationPoint).nullish(),
            annotationVerticalLine: schemas_array(zAnnotationVerticalLine).or(zAnnotationVerticalLine).nullish(),
            annotationHorizontalLine: schemas_array(zAnnotationHorizontalLine).or(zAnnotationHorizontalLine).nullish(),
            annotationArea: schemas_array(zAnnotationArea).or(zAnnotationArea).nullish(),
            dimensionLinkage: zDimensionLinkage.nullish(),
            locale: zLocale.nullish()
        });
        const zBarPercent = schemas_object({
            chartType: literal('barPercent'),
            dataset: zDataset.nullish(),
            encoding: zEncoding.nullish(),
            dimensions: zDimensions.nullish(),
            measures: zMeasureTree.nullish(),
            backgroundColor: zBackgroundColor.nullish(),
            color: zColor.nullish(),
            label: zLabel.nullish(),
            legend: zLegend.nullish(),
            tooltip: zTooltip.nullish(),
            xAxis: zXLinearAxis.nullish(),
            yAxis: zYBandAxis.nullish(),
            crosshairRect: zCrosshairRect.nullish(),
            stackCornerRadius: zStackCornerRadius.nullish(),
            barMaxWidth: zBarMaxWidth.nullish(),
            theme: zTheme.nullish(),
            barStyle: schemas_array(zBarStyle).or(zBarStyle).nullish(),
            annotationPoint: schemas_array(zAnnotationPoint).or(zAnnotationPoint).nullish(),
            annotationVerticalLine: schemas_array(zAnnotationVerticalLine).or(zAnnotationVerticalLine).nullish(),
            annotationHorizontalLine: schemas_array(zAnnotationHorizontalLine).or(zAnnotationHorizontalLine).nullish(),
            annotationArea: schemas_array(zAnnotationArea).or(zAnnotationArea).nullish(),
            dimensionLinkage: zDimensionLinkage.nullish(),
            locale: zLocale.nullish()
        });
        const zArea = schemas_object({
            chartType: literal('area'),
            dataset: zDataset.nullish(),
            encoding: zEncoding.nullish(),
            dimensions: zDimensions.nullish(),
            measures: zMeasureTree.nullish(),
            backgroundColor: zBackgroundColor.nullish(),
            color: zColor.nullish(),
            label: zLabel.nullish(),
            legend: zLegend.nullish(),
            tooltip: zTooltip.nullish(),
            xAxis: zXBandAxis.nullish(),
            yAxis: zYLinearAxis.nullish(),
            crosshairLine: zCrosshairLine.nullish(),
            theme: zTheme.nullish(),
            pointStyle: schemas_array(zPointStyle).or(zPointStyle).nullish(),
            lineStyle: schemas_array(zLineStyle).or(zLineStyle).nullish(),
            areaStyle: schemas_array(zAreaStyle).or(zAreaStyle).nullish(),
            annotationPoint: schemas_array(zAnnotationPoint).or(zAnnotationPoint).nullish(),
            annotationVerticalLine: schemas_array(zAnnotationVerticalLine).or(zAnnotationVerticalLine).nullish(),
            annotationHorizontalLine: schemas_array(zAnnotationHorizontalLine).or(zAnnotationHorizontalLine).nullish(),
            annotationArea: schemas_array(zAnnotationArea).or(zAnnotationArea).nullish(),
            dimensionLinkage: zDimensionLinkage.nullish(),
            locale: zLocale.nullish()
        });
        const zAreaPercent = schemas_object({
            chartType: literal('areaPercent'),
            dataset: zDataset.nullish(),
            encoding: zEncoding.nullish(),
            dimensions: zDimensions.nullish(),
            measures: zMeasureTree.nullish(),
            backgroundColor: zBackgroundColor.nullish(),
            color: zColor.nullish(),
            label: zLabel.nullish(),
            legend: zLegend.nullish(),
            tooltip: zTooltip.nullish(),
            xAxis: zXBandAxis.nullish(),
            yAxis: zYLinearAxis.nullish(),
            crosshairLine: zCrosshairLine.nullish(),
            theme: zTheme.nullish(),
            pointStyle: schemas_array(zPointStyle).or(zPointStyle).nullish(),
            lineStyle: schemas_array(zLineStyle).or(zLineStyle).nullish(),
            areaStyle: schemas_array(zAreaStyle).or(zAreaStyle).nullish(),
            annotationPoint: schemas_array(zAnnotationPoint).or(zAnnotationPoint).nullish(),
            annotationVerticalLine: schemas_array(zAnnotationVerticalLine).or(zAnnotationVerticalLine).nullish(),
            annotationHorizontalLine: schemas_array(zAnnotationHorizontalLine).or(zAnnotationHorizontalLine).nullish(),
            annotationArea: schemas_array(zAnnotationArea).or(zAnnotationArea).nullish(),
            dimensionLinkage: zDimensionLinkage.nullish(),
            locale: zLocale.nullish()
        });
        const zScatter = schemas_object({
            chartType: literal('scatter'),
            dataset: zDataset.nullish(),
            encoding: zEncoding.nullish(),
            dimensions: zDimensions.nullish(),
            measures: zMeasureTree.nullish(),
            scatterMeasures: zScatterMeasures.nullish(),
            backgroundColor: zBackgroundColor.nullish(),
            size: schemas_number().or(schemas_array(schemas_number())).nullish(),
            sizeRange: schemas_number().or(schemas_array(schemas_number())).nullish(),
            color: zColor.nullish(),
            label: zLabel.nullish(),
            legend: zLegend.nullish(),
            tooltip: zTooltip.nullish(),
            xAxis: zXLinearAxis.nullish(),
            yAxis: zYLinearAxis.nullish(),
            crosshairLine: zCrosshairLine.nullish(),
            theme: zTheme.nullish(),
            pointStyle: schemas_array(zPointStyle).or(zPointStyle).nullish(),
            annotationPoint: schemas_array(zAnnotationPoint).or(zAnnotationPoint).nullish(),
            annotationVerticalLine: schemas_array(zAnnotationVerticalLine).or(zAnnotationVerticalLine).nullish(),
            annotationHorizontalLine: schemas_array(zAnnotationHorizontalLine).or(zAnnotationHorizontalLine).nullish(),
            annotationArea: schemas_array(zAnnotationArea).or(zAnnotationArea).nullish(),
            linearRegressionLine: schemas_array(zLinearRegressionLine).or(zLinearRegressionLine).nullish(),
            lowessRegressionLine: schemas_array(zLowessRegressionLine).or(zLowessRegressionLine).nullish(),
            polynomialRegressionLine: schemas_array(zPolynomialRegressionLine).or(zPolynomialRegressionLine).nullish(),
            logisticRegressionLine: schemas_array(zLogisticRegressionLine).or(zLogisticRegressionLine).nullish(),
            dimensionLinkage: zDimensionLinkage.nullish(),
            locale: zLocale.nullish()
        });
        const zDualAxis = schemas_object({
            chartType: literal('dualAxis'),
            dataset: zDataset.nullish(),
            dimensions: zDimensions.nullish(),
            measures: zMeasureTree.nullish(),
            dualMeasures: zDualMeasures.nullish(),
            dualChartType: schemas_array(zDualChartType).or(zDualChartType).nullish(),
            alignTicks: schemas_array(schemas_boolean()).or(schemas_boolean()).nullish(),
            primaryYAxis: schemas_array(zYLinearAxis).or(zYLinearAxis).nullish(),
            secondaryYAxis: schemas_array(zYLinearAxis).or(zYLinearAxis).nullish(),
            xAxis: zXBandAxis.nullish(),
            backgroundColor: zBackgroundColor.nullish(),
            color: zColor.nullish(),
            label: zLabel.nullish(),
            legend: zLegend.nullish(),
            tooltip: zTooltip.nullish(),
            crosshairRect: zCrosshairRect.nullish(),
            sort: zSort.nullish(),
            sortLegend: zSortLegend.nullish(),
            theme: zTheme.nullish(),
            barMaxWidth: zBarMaxWidth.nullish(),
            barGapInGroup: zBarGapInGroup.nullish(),
            barStyle: schemas_array(zBarStyle).or(zBarStyle).nullish(),
            pointStyle: schemas_array(zPointStyle).or(zPointStyle).nullish(),
            lineStyle: schemas_array(zLineStyle).or(zLineStyle).nullish(),
            areaStyle: schemas_array(zAreaStyle).or(zAreaStyle).nullish(),
            annotationPoint: schemas_array(zAnnotationPoint).or(zAnnotationPoint).nullish(),
            annotationVerticalLine: schemas_array(zAnnotationVerticalLine).or(zAnnotationVerticalLine).nullish(),
            annotationHorizontalLine: schemas_array(zAnnotationHorizontalLine).or(zAnnotationHorizontalLine).nullish(),
            annotationArea: schemas_array(zAnnotationArea).or(zAnnotationArea).nullish(),
            dimensionLinkage: zDimensionLinkage.nullish(),
            locale: zLocale.nullish()
        });
        const zHistogram = schemas_object({
            chartType: literal('histogram'),
            dataset: zDataset.nullish(),
            encoding: zEncoding.nullish(),
            dimensions: zDimensions.nullish(),
            measures: zMeasureTree.nullish(),
            backgroundColor: zBackgroundColor.nullish(),
            color: zColor.nullish(),
            label: zLabel.nullish(),
            legend: zLegend.nullish(),
            tooltip: zTooltip.nullish(),
            xAxis: zXLinearAxis.nullish(),
            yAxis: zYLinearAxis.nullish(),
            crosshairRect: zCrosshairRect.nullish(),
            binCount: schemas_number().positive().nullish(),
            binStep: schemas_number().positive().nullish(),
            binValueType: literal('count').or(literal('percentage')).nullish(),
            theme: zTheme.nullish(),
            barStyle: schemas_array(zBarStyle).or(zBarStyle).nullish(),
            annotationPoint: schemas_array(zAnnotationPoint).or(zAnnotationPoint).nullish(),
            annotationVerticalLine: schemas_array(zAnnotationVerticalLine).or(zAnnotationVerticalLine).nullish(),
            annotationHorizontalLine: schemas_array(zAnnotationHorizontalLine).or(zAnnotationHorizontalLine).nullish(),
            annotationArea: schemas_array(zAnnotationArea).or(zAnnotationArea).nullish(),
            ecdfRegressionLine: schemas_array(zEcdfRegressionLine).or(zEcdfRegressionLine).nullish(),
            kdeRegressionLine: schemas_array(zKdeRegressionLine).or(zKdeRegressionLine).nullish(),
            dimensionLinkage: zDimensionLinkage.nullish(),
            locale: zLocale.nullish()
        });
        const zRose = schemas_object({
            chartType: literal('rose'),
            dataset: zDataset.nullish(),
            encoding: zEncoding.nullish(),
            dimensions: zDimensions.nullish(),
            measures: zMeasureTree.nullish(),
            backgroundColor: zBackgroundColor.nullish(),
            color: zColor.nullish(),
            label: zLabel.nullish(),
            legend: zLegend.nullish(),
            tooltip: zTooltip.nullish(),
            theme: zTheme.nullish(),
            locale: zLocale.nullish()
        });
        const zRoseParallel = schemas_object({
            chartType: literal('roseParallel'),
            dataset: zDataset.nullish(),
            encoding: zEncoding.nullish(),
            dimensions: zDimensions.nullish(),
            measures: zMeasureTree.nullish(),
            backgroundColor: zBackgroundColor.nullish(),
            color: zColor.nullish(),
            label: zLabel.nullish(),
            legend: zLegend.nullish(),
            tooltip: zTooltip.nullish(),
            theme: zTheme.nullish(),
            locale: zLocale.nullish()
        });
        const zPie = schemas_object({
            chartType: literal('pie'),
            dataset: zDataset.nullish(),
            encoding: zEncoding.nullish(),
            dimensions: zDimensions.nullish(),
            measures: zMeasureTree.nullish(),
            backgroundColor: zBackgroundColor.nullish(),
            color: zColor.nullish(),
            label: zPieLabel.nullish(),
            legend: zLegend.nullish(),
            tooltip: zTooltip.nullish(),
            theme: zTheme.nullish(),
            locale: zLocale.nullish()
        });
        const zDonut = schemas_object({
            chartType: literal('donut'),
            dataset: zDataset.nullish(),
            encoding: zEncoding.nullish(),
            dimensions: zDimensions.nullish(),
            measures: zMeasureTree.nullish(),
            backgroundColor: zBackgroundColor.nullish(),
            color: zColor.nullish(),
            label: zPieLabel.nullish(),
            legend: zLegend.nullish(),
            tooltip: zTooltip.nullish(),
            theme: zTheme.nullish(),
            locale: zLocale.nullish()
        });
        const zRadar = schemas_object({
            chartType: literal('radar'),
            dataset: zDataset.nullish(),
            encoding: zEncoding.nullish(),
            dimensions: zDimensions.nullish(),
            measures: zMeasureTree.nullish(),
            backgroundColor: zBackgroundColor.nullish(),
            color: zColor.nullish(),
            label: zLabel.nullish(),
            legend: zLegend.nullish(),
            tooltip: zTooltip.nullish(),
            theme: zTheme.nullish(),
            locale: zLocale.nullish()
        });
        const zFunnel = schemas_object({
            chartType: literal('funnel'),
            dataset: zDataset.nullish(),
            encoding: zEncoding.nullish(),
            dimensions: zDimensions.nullish(),
            measures: zMeasureTree.nullish(),
            backgroundColor: zBackgroundColor.nullish(),
            color: zColor.nullish(),
            label: zLabel.nullish(),
            legend: zColorLegend.nullish(),
            tooltip: zTooltip.nullish(),
            theme: zTheme.nullish(),
            locale: zLocale.nullish()
        });
        const zHeatmap = schemas_object({
            chartType: literal('heatmap'),
            dataset: zDataset.nullish(),
            dimensions: zDimensions.nullish(),
            measures: zMeasureTree.nullish(),
            backgroundColor: zBackgroundColor.nullish(),
            color: zColor.nullish(),
            label: zLabel.nullish(),
            legend: zColorLegend.nullish(),
            tooltip: zTooltip.nullish(),
            theme: zTheme.nullish(),
            locale: zLocale.nullish()
        });
        const zBoxPlot = schemas_object({
            chartType: literal('boxPlot'),
            dataset: zDataset.nullish(),
            encoding: zEncoding.nullish(),
            dimensions: zDimensions.nullish(),
            measures: zMeasureTree.nullish(),
            backgroundColor: zBackgroundColor.nullish(),
            color: zColor.nullish(),
            label: zLabel.nullish(),
            legend: zLegend.nullish(),
            tooltip: zTooltip.nullish(),
            xAxis: zXBandAxis.nullish(),
            yAxis: zYLinearAxis.nullish(),
            sort: zSort.nullish(),
            sortLegent: zSortLegend.nullish(),
            crosshairRect: zCrosshairRect.nullish(),
            boxPlotStyle: schemas_array(zBoxPlotStyle).or(zBoxPlotStyle).nullish(),
            outlierStyle: schemas_array(zOutlierStyle).or(zOutlierStyle).nullish(),
            theme: zTheme.nullish(),
            whiskers: zWhiskersConfig.nullish(),
            annotationPoint: schemas_array(zAnnotationPoint).or(zAnnotationPoint).nullish(),
            annotationVerticalLine: schemas_array(zAnnotationVerticalLine).or(zAnnotationVerticalLine).nullish(),
            annotationHorizontalLine: schemas_array(zAnnotationHorizontalLine).or(zAnnotationHorizontalLine).nullish(),
            annotationArea: schemas_array(zAnnotationArea).or(zAnnotationArea).nullish(),
            dimensionLinkage: zDimensionLinkage.nullish(),
            locale: zLocale.nullish(),
            boxMaxWidth: zBoxMaxWidth.nullish(),
            boxGapInGroup: zBoxGapInGroup.nullish()
        });
        const zVSeed = discriminatedUnion('chartType', [
            zTable,
            zPivotTable,
            zLine,
            zColumn,
            zColumnParallel,
            zColumnPercent,
            zBar,
            zBarParallel,
            zBarPercent,
            zArea,
            zAreaPercent,
            zScatter,
            zDualAxis,
            zPie,
            zDonut,
            zRose,
            zRoseParallel,
            zRadar,
            zFunnel,
            zHeatmap,
            zBoxPlot,
            zHistogram
        ]);
        const zCellStyle = schemas_object({
            bodyCellStyle: zBodyCellStyle.nullish()
        });
        const zAdvancedVSeed = schemas_object({
            chartType: zChartType,
            dataset: zDataset,
            datasetReshapeInfo: zDatasetReshapeInfo,
            pivotAllDatasetReshapeInfo: zDatasetReshapeInfo,
            dimensions: zDimensionTree,
            measures: zMeasureTree,
            reshapeMeasures: zMeasureTree.optional(),
            reshapeDimensions: zDimensionTree.optional(),
            encoding: zEncoding,
            config: zConfig,
            analysis: zAnalysis,
            theme: zTheme,
            markStyle: zMarkStyle,
            cellStyle: zCellStyle,
            customTheme: zCustomThemeConfig,
            annotation: zAnnotation,
            locale: zLocale,
            regressionLine: zRegressionLine
        });
        return __webpack_exports__;
    })());

//# sourceMappingURL=index.js.map