{"version":3,"file":"dataReshape/unfoldDimensions.js","sources":["../../../src/dataReshape/unfoldDimensions.ts"],"sourcesContent":["import type { Dataset, Datum, Dimension, Encoding, UnfoldInfo } from 'src/types'\nimport {\n  AngleEncoding,\n  XEncoding,\n  YEncoding,\n  ColorEncoding,\n  DetailEncoding,\n  ColorIdEncoding,\n  MeasureId,\n  MeasureName,\n} from './constant'\n\n/**\n * @description 展开并合并视觉通道的维度, 在foldMeasures后合并维度, 所以不需要进行笛卡尔积\n * @param dataset 原始数据集\n * @param dimensions 维度\n * @param encoding 编码\n * @param options\n * @returns\n */\nexport const unfoldDimensions = (\n  dataset: Dataset,\n  dimensions: Dimension[],\n  encoding: Encoding,\n  options: {\n    foldMeasureId: string\n    separator: string\n    colorItemAsId: boolean\n  },\n): {\n  dataset: Dataset\n  unfoldInfo: UnfoldInfo\n} => {\n  const { separator } = options\n\n  const unfoldInfo: UnfoldInfo = {\n    encodingAngle: AngleEncoding,\n    encodingX: XEncoding,\n    encodingY: YEncoding,\n    encodingDetail: DetailEncoding,\n    encodingColor: ColorEncoding,\n    encodingColorId: ColorIdEncoding,\n\n    colorItems: [],\n    colorIdMap: {},\n  }\n\n  // 每个通道对应的维度\n  const { color, x, y, detail, angle } = encoding\n  const angleDimensions = angle ? dimensions.filter((dim) => angle.includes(dim.id)) : []\n  const xDimensions = x ? dimensions.filter((dim) => x.includes(dim.id)) : []\n  const yDimensions = y ? dimensions.filter((dim) => y.includes(dim.id)) : []\n  const colorDimensions = color ? dimensions.filter((dim) => color.includes(dim.id)) : []\n  const detailDimensions = detail ? dimensions.filter((dim) => detail.includes(dim.id)) : []\n\n  // 离散图例项\n  const colorItems = new Set<string>()\n  const colorIdMap: Record<string, { id: string; alias: string }> = {}\n\n  // 遍历数据集, 按通道合并维度\n  for (let i = 0; i < dataset.length; i++) {\n    // 应用编码至Datum上\n    const datum = dataset[i]\n\n    /**\n     * !important 这是全仓库, 最最最重要的五行代码, 贯穿VSeed整个生命周期, 是化繁为简的绝对核心\n     * 1. 点睛之笔: 呼应foldMeasures, 此时此刻的datum一定是单点数据, 维度合并不可能造成任何冲突.\n     * 2. 数据即通道\n     * 3. 利用需要合并的维度, 直接进行join, 即可生成新的维度, 与指标彻底解耦;\n     * 4. 以下通道均在一次遍历中完成, 不存在性能问题\n     * 5. 以下通道均可放入多个维度\n     */\n    applyEncoding(AngleEncoding, angleDimensions, datum, separator)\n    applyEncoding(XEncoding, xDimensions, datum, separator)\n    applyEncoding(YEncoding, yDimensions, datum, separator)\n    applyEncoding(ColorEncoding, colorDimensions, datum, separator)\n    applyEncoding(DetailEncoding, detailDimensions, datum, separator)\n\n    // 处理离散的颜色图例\n    if (!colorDimensions.length || !datum[ColorEncoding]) {\n      // 无颜色通道, 则跳过\n      continue\n    }\n    const colorId = String(datum[ColorEncoding] ?? '')\n\n    datum[ColorIdEncoding] = colorId\n\n    colorIdMap[colorId] = {\n      id: colorId,\n      alias: getColorAliasItem(ColorEncoding, colorDimensions, datum, separator),\n    }\n    colorItems.add(colorId)\n  }\n\n  unfoldInfo.colorItems = Array.from(colorItems)\n  unfoldInfo.colorIdMap = colorIdMap\n\n  return {\n    dataset,\n    unfoldInfo,\n  }\n}\n\n/**\n * @description 应用编码至数据中, 此方法会原地修改数据\n * @param encoding 编码\n * @param dimensions 维度\n * @param datum 数据\n * @param separator 分隔符\n * @returns undefined\n */\nconst applyEncoding = (encoding: string, dimensions: Dimension[], datum: Datum, separator: string) => {\n  if (encoding && dimensions.length) {\n    datum[encoding] = dimensions.map((dim) => String(datum[dim.id])).join(separator)\n  }\n}\n\nconst getColorAliasItem = (encoding: string, dimensions: Dimension[], datum: Datum, separator: string) => {\n  if (encoding && dimensions.length) {\n    return dimensions\n      .map((dim) => {\n        if (dim.id === MeasureId) {\n          return String(datum[MeasureName])\n        }\n\n        return String(datum[dim.id])\n      })\n      .join(separator)\n  }\n  return ''\n}\n"],"names":["unfoldDimensions","dataset","dimensions","encoding","options","separator","unfoldInfo","AngleEncoding","XEncoding","YEncoding","DetailEncoding","ColorEncoding","ColorIdEncoding","color","x","y","detail","angle","angleDimensions","dim","xDimensions","yDimensions","colorDimensions","detailDimensions","colorItems","Set","colorIdMap","i","datum","applyEncoding","colorId","String","getColorAliasItem","Array","MeasureId","MeasureName"],"mappings":";AAoBO,MAAMA,mBAAmB,CAC9BC,SACAC,YACAC,UACAC;IASA,MAAM,EAAEC,SAAS,EAAE,GAAGD;IAEtB,MAAME,aAAyB;QAC7B,eAAeC;QACf,WAAWC;QACX,WAAWC;QACX,gBAAgBC;QAChB,eAAeC;QACf,iBAAiBC;QAEjB,YAAY,EAAE;QACd,YAAY,CAAC;IACf;IAGA,MAAM,EAAEC,KAAK,EAAEC,CAAC,EAAEC,CAAC,EAAEC,MAAM,EAAEC,KAAK,EAAE,GAAGd;IACvC,MAAMe,kBAAkBD,QAAQf,WAAW,MAAM,CAAC,CAACiB,MAAQF,MAAM,QAAQ,CAACE,IAAI,EAAE,KAAK,EAAE;IACvF,MAAMC,cAAcN,IAAIZ,WAAW,MAAM,CAAC,CAACiB,MAAQL,EAAE,QAAQ,CAACK,IAAI,EAAE,KAAK,EAAE;IAC3E,MAAME,cAAcN,IAAIb,WAAW,MAAM,CAAC,CAACiB,MAAQJ,EAAE,QAAQ,CAACI,IAAI,EAAE,KAAK,EAAE;IAC3E,MAAMG,kBAAkBT,QAAQX,WAAW,MAAM,CAAC,CAACiB,MAAQN,MAAM,QAAQ,CAACM,IAAI,EAAE,KAAK,EAAE;IACvF,MAAMI,mBAAmBP,SAASd,WAAW,MAAM,CAAC,CAACiB,MAAQH,OAAO,QAAQ,CAACG,IAAI,EAAE,KAAK,EAAE;IAG1F,MAAMK,aAAa,IAAIC;IACvB,MAAMC,aAA4D,CAAC;IAGnE,IAAK,IAAIC,IAAI,GAAGA,IAAI1B,QAAQ,MAAM,EAAE0B,IAAK;QAEvC,MAAMC,QAAQ3B,OAAO,CAAC0B,EAAE;QAUxBE,cAActB,eAAeW,iBAAiBU,OAAOvB;QACrDwB,cAAcrB,WAAWY,aAAaQ,OAAOvB;QAC7CwB,cAAcpB,WAAWY,aAAaO,OAAOvB;QAC7CwB,cAAclB,eAAeW,iBAAiBM,OAAOvB;QACrDwB,cAAcnB,gBAAgBa,kBAAkBK,OAAOvB;QAGvD,IAAI,CAACiB,gBAAgB,MAAM,IAAI,CAACM,KAAK,CAACjB,cAAc,EAElD;QAEF,MAAMmB,UAAUC,OAAOH,KAAK,CAACjB,cAAc,IAAI;QAE/CiB,KAAK,CAAChB,gBAAgB,GAAGkB;QAEzBJ,UAAU,CAACI,QAAQ,GAAG;YACpB,IAAIA;YACJ,OAAOE,kBAAkBrB,eAAeW,iBAAiBM,OAAOvB;QAClE;QACAmB,WAAW,GAAG,CAACM;IACjB;IAEAxB,WAAW,UAAU,GAAG2B,MAAM,IAAI,CAACT;IACnClB,WAAW,UAAU,GAAGoB;IAExB,OAAO;QACLzB;QACAK;IACF;AACF;AAUA,MAAMuB,gBAAgB,CAAC1B,UAAkBD,YAAyB0B,OAAcvB;IAC9E,IAAIF,YAAYD,WAAW,MAAM,EAC/B0B,KAAK,CAACzB,SAAS,GAAGD,WAAW,GAAG,CAAC,CAACiB,MAAQY,OAAOH,KAAK,CAACT,IAAI,EAAE,CAAC,GAAG,IAAI,CAACd;AAE1E;AAEA,MAAM2B,oBAAoB,CAAC7B,UAAkBD,YAAyB0B,OAAcvB;IAClF,IAAIF,YAAYD,WAAW,MAAM,EAC/B,OAAOA,WACJ,GAAG,CAAC,CAACiB;QACJ,IAAIA,IAAI,EAAE,KAAKe,WACb,OAAOH,OAAOH,KAAK,CAACO,YAAY;QAGlC,OAAOJ,OAAOH,KAAK,CAACT,IAAI,EAAE,CAAC;IAC7B,GACC,IAAI,CAACd;IAEV,OAAO;AACT"}