import { isNullish, pipe, uniqueBy } from "remeda";
import { createFormatterByMeasure, findAllMeasures } from "../../../../utils/index.js";
import { ColorEncoding, LowerWhisker, MedianMeasureId, OutliersMeasureId, Q1MeasureValue, Q3MeasureValue, UpperWhisker, XEncoding } from "../../../../../dataReshape/index.js";
import { getTooltipStyle } from "./tooltipStyle.js";
import { intl } from "../../../../../i18n/index.js";
const boxPlotMeasureKeys = [
    UpperWhisker,
    Q3MeasureValue,
    MedianMeasureId,
    Q1MeasureValue,
    LowerWhisker
];
const VCHART_OUTLIER_KEY = '__VCHART_BOX_PLOT_OUTLIER_VALUE';
const tooltipBoxplot = (spec, context)=>{
    const result = {
        ...spec
    };
    const { advancedVSeed, vseed } = context;
    const { chartType, dimensions, encoding } = advancedVSeed;
    const baseConfig = advancedVSeed.config[chartType];
    const { tooltip = {
        enable: true
    } } = baseConfig;
    const { enable } = tooltip;
    const meas = findAllMeasures(vseed.measures);
    const valueMeasure = meas.find((item)=>'value' === item.encoding || isNullish(item.encoding));
    const defaultFormatter = valueMeasure ? createFormatterByMeasure(valueMeasure) : (v)=>v;
    const measureAliasMapping = {
        [OutliersMeasureId]: intl.i18n`异常点`,
        [UpperWhisker]: intl.i18n`上边界`,
        [Q3MeasureValue]: intl.i18n`上四分位数`,
        [MedianMeasureId]: intl.i18n`中位数`,
        [Q1MeasureValue]: intl.i18n`下四分位数`,
        [LowerWhisker]: intl.i18n`下边界`
    };
    result.tooltip = {
        visible: enable,
        style: getTooltipStyle(tooltip),
        mark: {
            title: {
                visible: false
            },
            content: createMarkContent(encoding.tooltip || [], dimensions, encoding),
            updateContent: (prev, data)=>{
                const datum = data?.[0]?.datum?.[0];
                if (!isNullish(datum?.[VCHART_OUTLIER_KEY])) {
                    const tooltipItems = (prev ?? []).filter((item)=>!boxPlotMeasureKeys.includes(item.key));
                    const outerlierMeasure = meas.find((item)=>item.id === OutliersMeasureId);
                    const formatter = outerlierMeasure ? createFormatterByMeasure(outerlierMeasure) : defaultFormatter;
                    tooltipItems.push({
                        ...tooltipItems[0],
                        key: outerlierMeasure?.alias ?? measureAliasMapping[OutliersMeasureId],
                        value: formatter(datum?.[VCHART_OUTLIER_KEY])
                    });
                    return tooltipItems;
                }
                return (prev ?? []).map((entry)=>{
                    if (boxPlotMeasureKeys.includes(entry.key)) {
                        const mea = meas.find((item)=>item.id === entry.key);
                        const formatter = mea ? createFormatterByMeasure(mea) : defaultFormatter;
                        return {
                            ...entry,
                            value: formatter(datum?.[entry.key]),
                            key: mea?.alias ?? measureAliasMapping[entry?.key] ?? entry.key
                        };
                    }
                    return entry;
                });
            }
        },
        dimension: {
            visible: false
        }
    };
    return result;
};
const createMarkContent = (tooltip, dimensions, encoding)=>{
    const dims = pipe(dimensions.filter((item)=>tooltip.includes(item.id)), uniqueBy((item)=>item.id), uniqueBy((item)=>item.alias));
    const dimContent = dims.map((item)=>({
            visible: true,
            hasShape: true,
            shapeType: 'rectRound',
            key: item.alias ?? item.id,
            value: (datum)=>{
                if (!isNullish(datum?.[VCHART_OUTLIER_KEY])) {
                    if (encoding.color?.includes(item.id)) return datum?.[ColorEncoding];
                    if (encoding.x?.includes(item.id)) return datum?.[XEncoding];
                }
                return datum?.[item.id];
            }
        }));
    const defaultContent = boxPlotMeasureKeys.map((key)=>({
            visible: true,
            hasShape: true,
            shapeType: 'rectRound',
            key,
            value: (datum)=>{
                if (!datum) return '';
                return datum[key];
            }
        }));
    return [
        ...dimContent,
        defaultContent
    ];
};
export { tooltipBoxplot };

//# sourceMappingURL=tooltipBoxplot.js.map