import { Color, array, clamper } from "@visactor/vutils";
import { isNullish, isNumber, isPlainObject } from "remeda";
const formatGradientStops = (stops)=>{
    const firstInvalidateIndex = stops.findIndex((stop)=>stop.offset < 0 || stop.offset > 1);
    if (firstInvalidateIndex >= 0) {
        if (stops[firstInvalidateIndex].offset > 1) {
            const newStops = stops.slice(0, firstInvalidateIndex + 1);
            newStops[newStops.length - 1].offset = 1;
            return newStops;
        }
        const newStops = stops.slice(firstInvalidateIndex + 1);
        newStops[0].offset = 0;
        return newStops;
    }
    return stops;
};
const splitLine = (spec, context)=>{
    const { advancedVSeed } = context;
    const { annotation, chartType, datasetReshapeInfo } = advancedVSeed;
    if (!annotation || !annotation.annotationHorizontalLine) return spec;
    const baseConfig = advancedVSeed.config[chartType];
    const splitLineConfig = array(annotation.annotationHorizontalLine).find((item)=>!!item.splitLine);
    const splitValue = +splitLineConfig?.yValue;
    if (Number.isNaN(splitValue) || !isNumber(splitValue)) return spec;
    const result = {
        ...spec
    };
    const colorTheme = baseConfig?.color ?? {};
    const colorConfig = {
        positiveColor: colorTheme.positiveColor || 'red',
        negativeColor: colorTheme.negativeColor || 'green',
        ...isPlainObject(splitLineConfig?.splitLine) ? splitLineConfig?.splitLine : {}
    };
    const groupMark = {
        type: 'group',
        name: 'annotationHorizontalLine-splitLine',
        zIndex: 300,
        style: {
            splitConfig: (datum, ctx)=>{
                const vchart = ctx.vchart;
                const chart = vchart.getChart();
                const lineSeries = chart.getAllSeries().find((s)=>'line' === s.type || 'area' === s.type);
                if (!lineSeries) return;
                const lineMark = lineSeries.getMarkInName('line') ?? lineSeries.getMarkInName('area');
                if (!lineMark) return;
                const lineGraphics = lineMark.getGraphics();
                if (!lineGraphics || 1 !== lineGraphics.length || !lineGraphics[0]) return;
                const points = lineGraphics[0].attribute.points ?? [];
                if (lineGraphics[0].attribute.segments?.length) lineGraphics[0].attribute.segments.forEach((seg)=>{
                    seg.points.forEach((pt)=>{
                        points.push({
                            x: pt.x,
                            y: pt.y
                        });
                    });
                });
                if (!points || !points.length) return;
                const scale = lineSeries.getYAxisHelper().getScale(0);
                const splitCoordinate = scale.scale(splitValue);
                const minY = Math.min(...points.map((p)=>p.y));
                const maxY = Math.max(...points.map((p)=>p.y));
                const ratio = (splitCoordinate - minY) / (maxY - minY);
                const lineStroke = {
                    gradient: 'linear',
                    x0: 0,
                    x1: 0,
                    y0: 0,
                    y1: 1,
                    stops: formatGradientStops([
                        {
                            color: colorConfig.positiveColor,
                            offset: 0
                        },
                        {
                            color: colorConfig.positiveColor,
                            offset: ratio
                        },
                        {
                            color: colorConfig.negativeColor,
                            offset: ratio + 0.0000001
                        },
                        {
                            color: colorConfig.negativeColor,
                            offset: 1
                        }
                    ])
                };
                const areaFill = {
                    gradient: 'linear',
                    x0: 0,
                    x1: 0,
                    y0: 0,
                    y1: 1,
                    stops: formatGradientStops([
                        {
                            color: colorConfig.positiveColor,
                            offset: 0
                        },
                        {
                            color: new Color(colorConfig.positiveColor).setOpacity(0).toRGBA(),
                            offset: ratio
                        },
                        {
                            offset: ratio + 0.0000001,
                            color: new Color(colorConfig.negativeColor).setOpacity(0).toRGBA()
                        },
                        {
                            color: colorConfig.negativeColor,
                            offset: 1
                        }
                    ])
                };
                const attrs = {
                    segments: null,
                    points
                };
                if ('area' === lineGraphics[0].type) {
                    attrs.stroke = lineStroke;
                    attrs.fill = areaFill;
                } else attrs.stroke = lineStroke;
                lineGraphics[0].setAttributes(attrs);
                lineGraphics[0].setFinalAttributes?.(attrs);
                const start = lineSeries.getRegion().getLayoutStartPoint();
                const range = scale.range();
                return {
                    points: points.map((entry)=>({
                            x: entry.x + start.x,
                            y: entry.y + start.y
                        })),
                    splitCoordinate: clamper(range[0], range[range.length - 1])(splitCoordinate) + start.y,
                    areaFill,
                    lineStroke
                };
            }
        },
        children: [
            {
                type: 'area',
                interactive: false,
                zIndex: 500,
                style: {
                    fillOpacity: 0.5,
                    points: (datum, ctx, opt)=>{
                        const parentNode = opt.mark?._product?.parent;
                        if (parentNode?.attribute?.splitConfig) {
                            const { points, splitCoordinate } = parentNode.attribute.splitConfig;
                            return points.map((entry)=>({
                                    ...entry,
                                    y1: splitCoordinate
                                }));
                        }
                        return [];
                    },
                    fill: (datum, ctx, opt)=>{
                        const parentNode = opt.mark?._product?.parent;
                        if (parentNode?.attribute?.splitConfig) {
                            const { areaFill } = parentNode.attribute.splitConfig;
                            return areaFill;
                        }
                    }
                }
            }
        ]
    };
    if (!result.customMark) result.customMark = [];
    result.customMark.push(groupMark);
    const seriesSpec = 'line' === result.type || 'area' === result.type ? result : result.series?.find((s)=>'line' === s.type || 'area' === s.type);
    if (seriesSpec) {
        if (!seriesSpec.point) seriesSpec.point = {};
        if (!seriesSpec.line) seriesSpec.line = {};
        if (!seriesSpec.point.style) seriesSpec.point.style = {};
        if (!seriesSpec.line.style) seriesSpec.line.style = {};
        const measureValueKey = datasetReshapeInfo[0].foldInfo.measureValue;
        seriesSpec.point.style.fill = (datum)=>datum?.[measureValueKey] < splitValue ? colorConfig.negativeColor : colorConfig.positiveColor;
        seriesSpec.line.style.stroke = (datum)=>datum?.[measureValueKey] < splitValue ? colorConfig.negativeColor : colorConfig.positiveColor;
        if (seriesSpec.label && seriesSpec.label.visible && isNullish(seriesSpec.label.style?.fill)) seriesSpec.label.style = {
            ...seriesSpec.label.style,
            fill: (datum)=>datum?.[measureValueKey] < splitValue ? colorConfig.negativeColor : colorConfig.positiveColor
        };
    }
    return result;
};
export { splitLine };

//# sourceMappingURL=splitLine.js.map