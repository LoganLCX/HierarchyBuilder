import { DATUM_HIDE_KEY, createFormatter, createFormatterByMeasure, findMeasureById } from "../../../../utils/index.js";
import { isNumber, merge, uniqueBy } from "remeda";
import { selector } from "../../../../../dataSelector/index.js";
import { MeasureId } from "../../../../../dataReshape/constant.js";
const label_label = (spec, context)=>{
    const result = {
        ...spec
    };
    const { advancedVSeed, vseed } = context;
    const { datasetReshapeInfo } = advancedVSeed;
    const { chartType, encoding } = advancedVSeed;
    const baseConfig = advancedVSeed.config[chartType];
    const foldInfo = datasetReshapeInfo[0].foldInfo;
    const { label } = baseConfig;
    result.label = buildLabel(label, vseed.measures, vseed.dimensions, advancedVSeed.dimensions, advancedVSeed.measures, encoding, [
        foldInfo
    ]);
    return result;
};
const generateMeasureValue = (value, measure, labelAutoFormat, numFormat = {})=>{
    const format = merge(numFormat, measure.numFormat || measure.format);
    const mergedMeasure = {
        ...measure,
        numFormat: format,
        autoFormat: labelAutoFormat || measure.autoFormat
    };
    const formatter = createFormatterByMeasure(mergedMeasure);
    return formatter(value);
};
const generateMeasurePercent = (value, sum, formatter)=>{
    if (null == value) return String(value);
    const num = Number(value);
    if (Number.isNaN(num)) return String(value);
    const percentValue = num / sum;
    return formatter(percentValue);
};
const buildLabel = (label, vseedMeasures = [], vseedDimensions = [], advancedVSeedDimensions, advancedVSeedMeasures, encoding, foldInfoList)=>{
    const { enable, wrap, showValue, showValuePercent, showDimension, labelOverlap, labelColorSmartInvert, labelStroke, labelColor, labelFontSize, labelFontWeight, labelBackgroundColor, labelPosition, autoFormat, numFormat = {} } = label;
    const hasDimLabelEncoding = vseedDimensions.some((item)=>encoding.label?.includes(item.id));
    const labelDims = uniqueBy(hasDimLabelEncoding ? vseedDimensions.filter((item)=>encoding.label?.includes(item.id)) : showDimension ? advancedVSeedDimensions.filter((d)=>d.id !== MeasureId) : [], (item)=>item.id);
    const labelMeas = uniqueBy(vseedMeasures.filter((item)=>encoding.label?.includes(item.id)), (item)=>item.id);
    const percentFormat = merge(numFormat, {
        type: 'percent'
    });
    const percentFormatter = createFormatter(percentFormat);
    const result = {
        visible: enable,
        dataFilter: (data)=>data.filter((entry)=>entry.data?.[DATUM_HIDE_KEY] !== true && selector(entry.data, label.selector, 'Or')),
        formatMethod: (_, datum)=>{
            const result = [];
            const dimLabels = labelDims.map((item)=>{
                const id = item.id;
                return datum[id];
            });
            const meaLabels = labelMeas.map((item)=>generateMeasureValue(datum[item.id], item, autoFormat, numFormat));
            result.push(...dimLabels);
            foldInfoList.forEach((foldInfo)=>{
                const { measureId, measureValue, statistics } = foldInfo;
                const measure = findMeasureById(advancedVSeedMeasures, datum[measureId]);
                if (measure) {
                    const measureValueLabel = generateMeasureValue(datum[measureValue], measure, autoFormat, numFormat);
                    const measurePercentLabel = isNumber(datum['__VCHART_ARC_RATIO']) ? generateMeasurePercent(datum['__VCHART_ARC_RATIO'], 1, percentFormatter) : generateMeasurePercent(datum[measureValue], statistics.sum, percentFormatter);
                    if (showValue) result.push(measureValueLabel);
                    if (showValuePercent) result.push(measurePercentLabel);
                }
            });
            result.push(...meaLabels);
            if (wrap) return result;
            return result.join(' ');
        },
        position: labelPosition,
        style: {
            stroke: labelStroke,
            fill: labelColor,
            fontSize: labelFontSize,
            fontWeight: labelFontWeight,
            background: labelBackgroundColor
        },
        smartInvert: labelColorSmartInvert
    };
    if (labelOverlap) result.overlap = {
        hideOnHit: true,
        clampForce: true
    };
    return result;
};
export { buildLabel, generateMeasurePercent, generateMeasureValue, label_label as label };

//# sourceMappingURL=label.js.map