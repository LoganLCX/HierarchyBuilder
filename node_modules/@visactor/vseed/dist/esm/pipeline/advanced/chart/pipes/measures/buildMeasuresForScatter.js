import { isMeasureTreeWithChildren, isMeasureTreeWithParentId } from "./utils.js";
import { clone } from "remeda";
import { DEFAULT_PARENT_ID } from "../../../../utils/constant.js";
const buildMeasuresForScatter = (advancedVSeed, context)=>{
    const { vseed } = context;
    if (isMeasureTreeWithChildren(advancedVSeed.measures)) return advancedVSeed;
    if (isMeasureTreeWithParentId(advancedVSeed.measures)) {
        advancedVSeed.measures = generateMeasuresByParentId(advancedVSeed.measures);
        return advancedVSeed;
    }
    const scatterMeasures = vseed.scatterMeasures ? clone(vseed.scatterMeasures) : basicMeasuresToScatterMeasures(advancedVSeed.measures || []);
    advancedVSeed.measures = scatterMeasuresToMeasureTree(scatterMeasures);
    return advancedVSeed;
};
const basicMeasuresToScatterMeasures = (basicMeasures)=>{
    const yMeasures = [];
    const xMeasures = [];
    for(let index = 0; index < basicMeasures.length; index++){
        const item = basicMeasures[index];
        const encoding = Array.isArray(item.encoding) ? item.encoding : [
            item.encoding
        ];
        const isYAxis = encoding.includes('yAxis');
        const isXAxis = encoding.includes('xAxis');
        if (isYAxis) yMeasures.push(item);
        else if (isXAxis) xMeasures.push(item);
        else if (0 !== index) yMeasures.push(item);
        else xMeasures.push(item);
    }
    if (0 === yMeasures.length && xMeasures.length > 0) yMeasures.push(xMeasures[0]);
    return [
        {
            id: 'scatterMeasures',
            xMeasures,
            yMeasures
        }
    ];
};
const scatterMeasuresToMeasureTree = (scatterMeasures)=>{
    const measureTree = scatterMeasures.map((item, index)=>{
        const { id, xMeasures, yMeasures } = item;
        const groupChildren = [];
        let groupId = `${id}-`;
        if (xMeasures) {
            const arrPrimaryMeasures = Array.isArray(xMeasures) ? xMeasures : [
                xMeasures
            ];
            const alias = arrPrimaryMeasures.map((item)=>item.alias || item.id).toString();
            groupId += alias;
            groupChildren.push({
                id: `${index}-x`,
                alias: arrPrimaryMeasures.map((item)=>item.alias || item.id).toString(),
                children: arrPrimaryMeasures
            });
        }
        if (yMeasures) {
            const arrSecondaryMeasures = Array.isArray(yMeasures) ? yMeasures : [
                yMeasures
            ];
            const alias = arrSecondaryMeasures.map((item)=>item.alias || item.id).toString();
            groupId += alias;
            groupChildren.push({
                id: `${index}-y`,
                alias: arrSecondaryMeasures.map((item)=>item.alias || item.id).toString(),
                children: arrSecondaryMeasures
            });
        }
        return {
            id: groupId,
            alias: groupId,
            children: groupChildren
        };
    });
    if (1 === scatterMeasures.length) return measureTree[0].children || [];
    return measureTree;
};
const generateMeasuresByParentId = (measures)=>{
    const scatterMeasures = [];
    measures.forEach((item)=>{
        const id = item.parentId || DEFAULT_PARENT_ID;
        if (!scatterMeasures.find((d)=>d.id === id)) scatterMeasures.push({
            id,
            yMeasures: [],
            xMeasures: []
        });
        const scatterChart = scatterMeasures.find((d)=>d.id === id);
        if (!scatterChart || !Array.isArray(scatterChart.yMeasures) || !Array.isArray(scatterChart.xMeasures)) return;
        const encoding = Array.isArray(item.encoding) ? item.encoding : [
            item.encoding
        ].filter(Boolean);
        const isX = encoding.includes('xAxis');
        const isY = encoding.includes('yAxis');
        const isEmpty = !encoding.length;
        if (isY) scatterChart.yMeasures.push(item);
        else if (isX) scatterChart.xMeasures.push(item);
        else if (isEmpty) if (0 !== scatterChart.yMeasures.length) scatterChart.yMeasures.push(item);
        else scatterChart.xMeasures.push(item);
    });
    return scatterMeasuresToMeasureTree(scatterMeasures);
};
export { buildMeasuresForScatter };

//# sourceMappingURL=buildMeasuresForScatter.js.map