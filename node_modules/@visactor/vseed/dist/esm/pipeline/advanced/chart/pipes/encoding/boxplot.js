import { unique } from "remeda";
import { MeasureId } from "../../../../../dataReshape/index.js";
import { findAllMeasures } from "../../../../utils/index.js";
import { addColorToEncoding } from "./color/index.js";
const defaultEncodingForBoxplot = (advancedVSeed)=>{
    const { measures: vseedMeasures = [], dimensions = [] } = advancedVSeed;
    const measures = findAllMeasures(vseedMeasures);
    const encoding = {};
    generateDefaultDimensionEncoding(dimensions, encoding);
    generateDefaultMeasureEncoding(measures, encoding);
    return {
        ...advancedVSeed,
        encoding
    };
};
const encodingForBoxplot = (advancedVSeed)=>{
    const { measures: vseedMeasures = [], dimensions = [] } = advancedVSeed;
    const measures = findAllMeasures(vseedMeasures);
    const hasDimensionEncoding = dimensions.some((item)=>item.encoding);
    const hasMeasureEncoding = measures.some((item)=>item.encoding);
    const encoding = {};
    if (hasDimensionEncoding) generateDimensionEncoding(dimensions, encoding, measures.length > 1);
    else generateDefaultDimensionEncoding(dimensions, encoding);
    if (hasMeasureEncoding) generateMeasureEncoding(measures, encoding);
    else generateDefaultMeasureEncoding(measures, encoding);
    if ((!encoding.value || encoding.value.length <= 1) && encoding.color && encoding.color.length > 1) encoding.color = encoding.color.filter((c)=>c !== MeasureId);
    return {
        ...advancedVSeed,
        encoding
    };
};
const generateDefaultDimensionEncoding = (dimensions, encoding)=>{
    const onlyMeasureId = 1 === dimensions.length && dimensions.find((item)=>item.id === MeasureId);
    const uniqueDimIds = unique(dimensions.map((d)=>d.id));
    encoding.x = uniqueDimIds.slice(0, 1);
    encoding.color = uniqueDimIds.slice(onlyMeasureId ? 0 : 1);
    encoding.tooltip = uniqueDimIds.filter((d)=>d !== MeasureId);
    encoding.label = [];
    encoding.row = [];
    encoding.column = [];
};
const generateDimensionEncoding = (dimensions, encoding, isMultiMeasure)=>{
    encoding.x = unique(dimensions.filter((item)=>'xAxis' === item.encoding).map((item)=>item.id));
    if (0 === encoding.x.length) encoding.x = [
        dimensions[0].id
    ];
    addColorToEncoding(dimensions, encoding, isMultiMeasure);
    encoding.tooltip = unique(dimensions.map((item)=>item.id));
    encoding.tooltip = encoding.tooltip.filter((d)=>d !== MeasureId);
    encoding.label = unique(dimensions.filter((item)=>'label' === item.encoding).map((item)=>item.id));
    encoding.label = encoding.label.filter((d)=>d !== MeasureId);
};
const generateDefaultMeasureEncoding = (measures, encoding)=>{
    encoding.value = unique(measures.filter((item)=>'value' === item.encoding || !item.encoding).map((item)=>item.id));
};
const generateMeasureEncoding = (measures, encoding)=>{
    encoding.value = unique(measures.filter((item)=>'value' === item.encoding || !item.encoding).map((item)=>item.id));
    encoding.q1 = unique(measures.filter((item)=>'q1' === item.encoding).map((item)=>item.id));
    encoding.median = unique(measures.filter((item)=>'median' === item.encoding).map((item)=>item.id));
    encoding.q3 = unique(measures.filter((item)=>'q3' === item.encoding).map((item)=>item.id));
    encoding.min = unique(measures.filter((item)=>'min' === item.encoding).map((item)=>item.id));
    encoding.max = unique(measures.filter((item)=>'max' === item.encoding).map((item)=>item.id));
    encoding.outliers = unique(measures.filter((item)=>'outliers' === item.encoding).map((item)=>item.id));
    const color = unique(measures.filter((item)=>'color' === item.encoding).map((item)=>item.id));
    if (color.length > 0) encoding.color = color;
    const label = unique(measures.filter((item)=>'label' === item.encoding).map((item)=>item.id));
    encoding.label = unique([
        ...encoding.label || [],
        ...label
    ]);
    const tooltip = unique(measures.filter((item)=>'tooltip' === item.encoding).map((item)=>item.id));
    encoding.tooltip = unique([
        ...encoding.tooltip || [],
        ...label,
        ...tooltip
    ]);
};
export { defaultEncodingForBoxplot, encodingForBoxplot };

//# sourceMappingURL=boxplot.js.map