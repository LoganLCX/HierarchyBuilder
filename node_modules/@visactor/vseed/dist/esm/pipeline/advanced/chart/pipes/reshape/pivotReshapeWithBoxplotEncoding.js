import { boxplot } from "@visactor/vdataset";
import { uniqueBy } from "remeda";
import { FoldMeasureId, FoldMeasureName, LowerWhisker, MedianMeasureId, OutliersMeasureId, Q1MeasureValue, Q3MeasureValue, Separator, UpperWhisker, unfoldDimensions } from "../../../../../dataReshape/index.js";
const pivotReshapeWithBoxplotEncoding = (advancedVSeed, context)=>{
    const result = {
        ...advancedVSeed
    };
    const { vseed } = context;
    const { dataset, chartType } = vseed;
    const { encoding = {}, config } = advancedVSeed;
    const measures = advancedVSeed.reshapeMeasures ?? advancedVSeed.measures ?? [];
    const dimensions = advancedVSeed.reshapeDimensions ?? advancedVSeed.dimensions ?? [];
    const uniqDims = uniqueBy(dimensions, (item)=>item.id);
    const chartConfig = config?.[chartType];
    const whiskers = chartConfig?.whiskers;
    const measureGroups = [];
    if (measures) measures.forEach((measure)=>{
        if (measure.children && measure.children.length > 0) measureGroups.push(measure);
    });
    const rowColumnFields = uniqueBy(dimensions.filter((dim)=>'row' === dim.encoding || 'column' === dim.encoding), (item)=>item.id);
    const datasets = [];
    const datasetReshapeInfo = [];
    measureGroups.forEach((measureGroup, index)=>{
        const subMeasures = measureGroup.children;
        if (!subMeasures) return;
        const groupId = measureGroup.id;
        let newDatasets = [];
        let foldInfo = {};
        let unfoldInfo = {};
        const validEncodingIds = (encoding.value || []).filter((id)=>subMeasures.find((field)=>field.id === id));
        if (validEncodingIds.length) {
            const boxPlotDataList = [];
            validEncodingIds.forEach((f)=>{
                const m = subMeasures.find((m)=>m.id === f);
                const boxPlotData = boxplot(dataset, {
                    field: f,
                    groupField: [
                        ...encoding.x ?? [],
                        ...encoding.color ?? [],
                        ...rowColumnFields.map((item)=>item.id)
                    ],
                    whiskers,
                    outputNames: {
                        q1: Q1MeasureValue,
                        q3: Q3MeasureValue,
                        lowerWhisker: LowerWhisker,
                        upperWhisker: UpperWhisker,
                        median: MedianMeasureId,
                        outliers: OutliersMeasureId
                    }
                });
                boxPlotData.forEach((datum)=>{
                    datum[FoldMeasureId] = f;
                    datum[FoldMeasureName] = m?.alias ?? f;
                });
                boxPlotDataList.push(...boxPlotData);
            });
            const res = unfoldDimensions(boxPlotDataList, uniqDims, encoding, {
                foldMeasureId: FoldMeasureId,
                separator: Separator,
                colorItemAsId: false
            });
            res.dataset.forEach((d)=>{
                newDatasets.push(d);
            });
            unfoldInfo = res.unfoldInfo;
        } else if (encoding.q1?.length && encoding.q3?.length && encoding.min?.length && encoding.max?.length && encoding.median?.length) {
            const res = unfoldDimensions(dataset, uniqDims, encoding, {
                foldMeasureId: FoldMeasureId,
                separator: Separator,
                colorItemAsId: false
            });
            res.dataset.forEach((datum)=>{
                datum[UpperWhisker] = datum[encoding.max[0]];
                datum[LowerWhisker] = datum[encoding.min[0]];
                datum[Q1MeasureValue] = datum[encoding.q1[0]];
                datum[Q3MeasureValue] = datum[encoding.q3[0]];
                datum[MedianMeasureId] = datum[encoding.median[0]];
            });
            newDatasets = res.dataset;
            foldInfo = {};
            unfoldInfo = res.unfoldInfo;
        }
        const reshapeInfo = {
            id: `${groupId}`,
            index,
            foldInfo,
            unfoldInfo
        };
        datasets.push(newDatasets);
        datasetReshapeInfo.push(reshapeInfo);
    });
    return {
        ...result,
        dataset: datasets,
        datasetReshapeInfo: datasetReshapeInfo
    };
};
export { pivotReshapeWithBoxplotEncoding };

//# sourceMappingURL=pivotReshapeWithBoxplotEncoding.js.map