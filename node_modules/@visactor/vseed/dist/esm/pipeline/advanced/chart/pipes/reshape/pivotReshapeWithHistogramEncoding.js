import { bin } from "@visactor/vdataset";
import { uniqueBy } from "remeda";
import { BinCountMeasureId, BinEndMeasureId, BinPercentageMeasureId, BinStartMeasureId, FoldMeasureId, FoldMeasureName, FoldMeasureValue, Separator, dataReshapeByEncoding, unfoldDimensions } from "../../../../../dataReshape/index.js";
import { getColorMeasureId } from "../../../../spec/chart/pipes/index.js";
const pivotReshapeWithHistogramEncoding = (advancedVSeed, context)=>{
    const result = {
        ...advancedVSeed
    };
    const { vseed } = context;
    const { dataset, chartType } = vseed;
    const { encoding = {}, config } = advancedVSeed;
    const measures = advancedVSeed.reshapeMeasures ?? advancedVSeed.measures ?? [];
    const dimensions = advancedVSeed.reshapeDimensions ?? advancedVSeed.dimensions ?? [];
    const colorMeasureId = getColorMeasureId(advancedVSeed, vseed);
    const uniqDims = uniqueBy(dimensions, (item)=>item.id);
    const chartConfig = config?.[chartType];
    const binCount = chartConfig?.binCount;
    const binStep = chartConfig?.binStep;
    const binValueType = chartConfig?.binValueType;
    const measureGroups = [];
    if (measures) measures.forEach((measure)=>{
        if (measure.children && measure.children.length > 0) measureGroups.push(measure);
    });
    const rowColumnFields = uniqueBy(dimensions.filter((dim)=>'row' === dim.encoding || 'column' === dim.encoding), (item)=>item.id);
    const datasets = [];
    const datasetReshapeInfo = [];
    measureGroups.forEach((measureGroup, index)=>{
        const subMeasures = measureGroup.children;
        if (!subMeasures) return;
        const groupId = measureGroup.id;
        let newDatasets = [];
        let foldInfo = {
            foldMap: {},
            measureId: FoldMeasureId,
            measureName: FoldMeasureName,
            measureValue: FoldMeasureValue,
            statistics: {
                max: -1 / 0,
                min: 1 / 0,
                sum: 0,
                count: 0,
                colorMin: 1 / 0,
                colorMax: -1 / 0
            }
        };
        let unfoldInfo = {};
        if (encoding.value?.length) {
            const valueField = encoding.value[0];
            const m = subMeasures.find((m)=>m.id === valueField);
            const binData = bin(dataset, {
                field: valueField,
                groupField: [
                    ...encoding.x ?? [],
                    ...encoding.color ?? []
                ],
                facetField: rowColumnFields.map((item)=>item.id),
                bins: binCount,
                step: binStep,
                outputNames: {
                    x0: BinStartMeasureId,
                    x1: BinEndMeasureId,
                    count: BinCountMeasureId,
                    percentage: BinPercentageMeasureId
                }
            });
            binData.forEach((datum)=>{
                datum[FoldMeasureId] = valueField;
                datum[FoldMeasureName] = m?.alias ?? valueField;
                const valueNumber = 'percentage' === binValueType ? +datum[BinPercentageMeasureId] : +datum[BinCountMeasureId];
                datum[FoldMeasureValue] = valueNumber;
                datum[valueField] = valueNumber;
                foldInfo.statistics.min = Math.min(foldInfo.statistics.min, valueNumber);
                foldInfo.statistics.max = Math.max(foldInfo.statistics.max, valueNumber);
                foldInfo.statistics.sum += valueNumber;
                foldInfo.statistics.count++;
            });
            if (m?.id) foldInfo.foldMap[m?.id] = m?.alias;
            const res = unfoldDimensions(binData, uniqDims, encoding, {
                foldMeasureId: FoldMeasureId,
                separator: Separator,
                colorItemAsId: false
            });
            res.dataset.forEach((d)=>{
                newDatasets.push(d);
            });
            unfoldInfo = res.unfoldInfo;
        } else if (encoding.x0?.length && encoding.x1?.length && encoding.y?.length) {
            const res = dataReshapeByEncoding(dataset, uniqueBy(dimensions, (item)=>item.id), subMeasures.filter((item)=>encoding.y?.includes(item.id)).slice(0, 1), encoding, {
                colorItemAsId: false,
                colorMeasureId
            });
            res.dataset.forEach((datum)=>{
                datum[BinStartMeasureId] = datum[encoding.x0[0]];
                datum[BinEndMeasureId] = datum[encoding.x1[0]];
                datum[FoldMeasureId] = datum[encoding.y[0]];
            });
            newDatasets = res.dataset;
            foldInfo = res.foldInfo;
            unfoldInfo = res.unfoldInfo;
        }
        const reshapeInfo = {
            id: `${groupId}`,
            index,
            foldInfo,
            unfoldInfo
        };
        datasets.push(newDatasets);
        datasetReshapeInfo.push(reshapeInfo);
    });
    return {
        ...result,
        dataset: datasets,
        datasetReshapeInfo: datasetReshapeInfo
    };
};
export { pivotReshapeWithHistogramEncoding };

//# sourceMappingURL=pivotReshapeWithHistogramEncoding.js.map