import { isMeasureTreeWithChildren, isMeasureTreeWithParentId } from "./utils.js";
import { clone } from "remeda";
import { DEFAULT_PARENT_ID } from "../../../../utils/constant.js";
const buildMeasuresForDualAxis = (advancedVSeed, context)=>{
    const { vseed } = context;
    if (isMeasureTreeWithChildren(advancedVSeed.measures)) return advancedVSeed;
    if (isMeasureTreeWithParentId(advancedVSeed.measures)) {
        advancedVSeed.measures = generateMeasuresByParentId(advancedVSeed.measures);
        return advancedVSeed;
    }
    const dualMeasures = vseed.dualMeasures ? clone(vseed.dualMeasures) : basicMeasuresToDualMeasures(advancedVSeed.measures || []);
    advancedVSeed.measures = dualMeasuresToMeasureTree(dualMeasures);
    return advancedVSeed;
};
const basicMeasuresToDualMeasures = (basicMeasures)=>{
    const primaryMeasures = [];
    const secondaryMeasures = [];
    for(let index = 0; index < basicMeasures.length; index++){
        const item = basicMeasures[index];
        const encoding = Array.isArray(item.encoding) ? item.encoding : [
            item.encoding
        ];
        const isPrimaryYAxis = encoding.includes('primaryYAxis');
        const isSecondaryYAxis = encoding.includes('secondaryYAxis');
        if (isPrimaryYAxis) primaryMeasures.push(item);
        else if (isSecondaryYAxis) secondaryMeasures.push(item);
        else if (0 === index) primaryMeasures.push(item);
        else secondaryMeasures.push(item);
    }
    return [
        {
            id: 'dualMeasures',
            primaryMeasures,
            secondaryMeasures
        }
    ];
};
const dualMeasuresToMeasureTree = (dualMeasures)=>{
    const measureTree = dualMeasures.map((item, index)=>{
        const { id, primaryMeasures, secondaryMeasures } = item;
        const groupChildren = [];
        let groupId = `${id}-`;
        if (primaryMeasures) {
            const arrPrimaryMeasures = Array.isArray(primaryMeasures) ? primaryMeasures : [
                primaryMeasures
            ];
            const alias = arrPrimaryMeasures.map((item)=>item.alias || item.id).toString();
            groupId += alias;
            groupChildren.push({
                id: `${index}-primary`,
                alias: arrPrimaryMeasures.map((item)=>item.alias || item.id).toString(),
                children: arrPrimaryMeasures
            });
        }
        if (secondaryMeasures) {
            const arrSecondaryMeasures = Array.isArray(secondaryMeasures) ? secondaryMeasures : [
                secondaryMeasures
            ];
            const alias = arrSecondaryMeasures.map((item)=>item.alias || item.id).toString();
            groupId += alias;
            groupChildren.push({
                id: `${index}-secondary`,
                alias: arrSecondaryMeasures.map((item)=>item.alias || item.id).toString(),
                children: arrSecondaryMeasures
            });
        }
        return {
            id: groupId,
            alias: groupId,
            children: groupChildren
        };
    });
    if (1 === dualMeasures.length) return measureTree[0].children || [];
    return measureTree;
};
const generateMeasuresByParentId = (measures)=>{
    const dualMeasures = [];
    measures.forEach((item)=>{
        const id = item.parentId || DEFAULT_PARENT_ID;
        if (!dualMeasures.find((d)=>d.id === id)) dualMeasures.push({
            id,
            primaryMeasures: [],
            secondaryMeasures: []
        });
        const dualChart = dualMeasures.find((d)=>d.id === id);
        if (!dualChart || !Array.isArray(dualChart.primaryMeasures) || !Array.isArray(dualChart.secondaryMeasures)) return;
        const encoding = Array.isArray(item.encoding) ? item.encoding : [
            item.encoding
        ].filter(Boolean);
        const isPrimary = encoding.includes('primaryYAxis');
        const isSecondary = encoding.includes('secondaryYAxis');
        const isEmpty = !item.encoding;
        if (isPrimary) dualChart.primaryMeasures.push(item);
        else if (isSecondary) dualChart.secondaryMeasures.push(item);
        else if (isEmpty) if (0 === dualChart.primaryMeasures.length) dualChart.primaryMeasures.push(item);
        else dualChart.secondaryMeasures.push(item);
    });
    return dualMeasuresToMeasureTree(dualMeasures);
};
export { buildMeasuresForDualAxis };

//# sourceMappingURL=buildMeasuresForDualAxis.js.map