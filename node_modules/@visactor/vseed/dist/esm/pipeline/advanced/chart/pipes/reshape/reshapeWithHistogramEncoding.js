import { BinCountMeasureId, BinEndMeasureId, BinPercentageMeasureId, BinStartMeasureId, FoldMeasureId, FoldMeasureName, FoldMeasureValue, Separator, dataReshapeByEncoding, unfoldDimensions } from "../../../../../dataReshape/index.js";
import { findAllMeasures } from "../../../../utils/index.js";
import { bin } from "@visactor/vdataset";
import { uniqueBy } from "remeda";
import { getColorMeasureId } from "../../../../spec/chart/pipes/color/colorAdapter.js";
const reshapeWithHistogramEncoding = (advancedVSeed, context)=>{
    const result = {
        ...advancedVSeed
    };
    const { vseed } = context;
    const { dataset, chartType } = vseed;
    const { encoding = {}, config } = advancedVSeed;
    const measures = advancedVSeed.reshapeMeasures ?? advancedVSeed.measures ?? [];
    const dimensions = advancedVSeed.reshapeDimensions ?? advancedVSeed.dimensions ?? [];
    const uniqDims = uniqueBy(dimensions, (item)=>item.id);
    const chartConfig = config?.[chartType];
    const binCount = chartConfig?.binCount;
    const binStep = chartConfig?.binStep;
    const binValueType = chartConfig?.binValueType;
    let newDatasets = [];
    let foldInfo = {
        foldMap: {},
        measureId: FoldMeasureId,
        measureName: FoldMeasureName,
        measureValue: FoldMeasureValue,
        statistics: {
            max: -1 / 0,
            min: 1 / 0,
            sum: 0,
            count: 0,
            colorMin: 1 / 0,
            colorMax: -1 / 0
        }
    };
    let unfoldInfo = {};
    const colorMeasureId = getColorMeasureId(advancedVSeed, vseed);
    const allMeasures = findAllMeasures(measures);
    if (encoding.value?.length) {
        const valueField = encoding.value[0];
        const m = allMeasures.find((m)=>m.id === valueField);
        const binData = bin(dataset, {
            field: valueField,
            groupField: [
                ...encoding.x ?? [],
                ...encoding.color ?? []
            ],
            bins: binCount,
            step: binStep,
            outputNames: {
                x0: BinStartMeasureId,
                x1: BinEndMeasureId,
                count: BinCountMeasureId,
                percentage: BinPercentageMeasureId
            }
        });
        binData.forEach((datum)=>{
            datum[FoldMeasureId] = valueField;
            datum[FoldMeasureName] = m?.alias ?? valueField;
            const valueNumber = 'percentage' === binValueType ? +datum[BinPercentageMeasureId] : +datum[BinCountMeasureId];
            datum[FoldMeasureValue] = valueNumber;
            datum[valueField] = valueNumber;
            foldInfo.statistics.min = Math.min(foldInfo.statistics.min, valueNumber);
            foldInfo.statistics.max = Math.max(foldInfo.statistics.max, valueNumber);
            foldInfo.statistics.sum += valueNumber;
            foldInfo.statistics.count++;
        });
        if (m?.id) foldInfo.foldMap[m?.id] = m?.alias;
        const res = unfoldDimensions(binData, uniqDims, encoding, {
            foldMeasureId: FoldMeasureId,
            separator: Separator,
            colorItemAsId: false
        });
        res.dataset.forEach((d)=>{
            newDatasets.push(d);
        });
        unfoldInfo = res.unfoldInfo;
    } else if (encoding.x0?.length && encoding.x1?.length && encoding.y?.length) {
        const res = dataReshapeByEncoding(dataset, uniqueBy(dimensions, (item)=>item.id), findAllMeasures(measures).filter((item)=>encoding.y?.includes(item.id)).slice(0, 1), encoding, {
            colorItemAsId: false,
            colorMeasureId
        });
        res.dataset.forEach((datum)=>{
            datum[BinStartMeasureId] = datum[encoding.x0[0]];
            datum[BinEndMeasureId] = datum[encoding.x1[0]];
        });
        newDatasets = res.dataset;
        foldInfo = res.foldInfo;
        unfoldInfo = res.unfoldInfo;
    }
    return {
        ...result,
        dataset: newDatasets,
        datasetReshapeInfo: [
            {
                id: String(chartType),
                index: 0,
                foldInfo,
                unfoldInfo
            }
        ],
        dimensions,
        measures
    };
};
export { reshapeWithHistogramEncoding };

//# sourceMappingURL=reshapeWithHistogramEncoding.js.map