import isNil from "./isNil";

import { computeLinearCIComponents, invNorm, stdErrorsAt } from "./regression-utils";

export function ordinaryLeastSquares(uX, uY, uXY, uX2) {
    const denom = uX2 - uX * uX;
    if (Math.abs(denom) < Number.EPSILON) return {
        a: uY,
        b: 0
    };
    const b = (uXY - uX * uY) / denom;
    return {
        a: uY - b * uX,
        b: b
    };
}

export function visitPoints(data, x, y, callback) {
    for (let i = 0; i < data.length; i++) {
        const d = data[i];
        let xi = x(d), yi = y(d);
        !isNil(xi) && (xi = +xi) >= xi && !isNil(yi) && (yi = +yi) >= yi && callback(xi, yi, i);
    }
}

export function rSquared(data, x, y, uY, predict) {
    let ssr = 0, sst = 0;
    for (let i = 0; i < data.length; i++) {
        const d = data[i];
        let yi = y(d);
        if (!isNil(yi) && (yi = +yi) >= yi) {
            const r = yi - predict(x(d));
            ssr += r * r;
            const t = yi - uY;
            sst += t * t;
        }
    }
    return 0 === sst ? 0 : 1 - ssr / sst;
}

export function regressionLinear(data, x = (d => d.x), y = (d => d.y), options) {
    var _a;
    const alpha = null !== (_a = null == options ? void 0 : options.alpha) && void 0 !== _a ? _a : .05;
    let n = 0, meanX = 0, meanY = 0, meanXY = 0, meanX2 = 0;
    visitPoints(data, x, y, ((xi, yi) => {
        n++, meanX += (xi - meanX) / n, meanY += (yi - meanY) / n, meanXY += (xi * yi - meanXY) / n, 
        meanX2 += (xi * xi - meanX2) / n;
    }));
    const {a: a, b: b} = ordinaryLeastSquares(meanX, meanY, meanXY, meanX2), predict = xx => a + b * xx, comps = computeLinearCIComponents(data, x, y, predict);
    return {
        coef: {
            a: a,
            b: b
        },
        predict: predict,
        rSquared: rSquared(data, x, y, meanY, predict),
        evaluateGrid: function(N) {
            const out = [];
            if (0 === comps.n || N <= 0) return out;
            if (comps.min === comps.max) {
                for (let i = 0; i < N; i++) out.push({
                    x: comps.min,
                    y: predict(comps.min)
                });
                return out;
            }
            const step = (comps.max - comps.min) / (N - 1);
            for (let i = 0; i < N; i++) {
                const px = i === N - 1 ? comps.max : comps.min + step * i;
                out.push({
                    x: px,
                    y: predict(px)
                });
            }
            return out;
        },
        confidenceInterval: function(N = 50) {
            const out = [];
            if (0 === comps.n || N <= 0) return out;
            const z = invNorm(1 - alpha / 2);
            if (comps.min === comps.max) {
                const m = predict(comps.min), errs = stdErrorsAt(comps.min, comps);
                for (let i = 0; i < N; i++) out.push({
                    x: comps.min,
                    mean: m,
                    lower: m - z * errs.seMean,
                    upper: m + z * errs.seMean,
                    predLower: m - z * errs.sePred,
                    predUpper: m + z * errs.sePred
                });
                return out;
            }
            const step = (comps.max - comps.min) / (N - 1);
            for (let i = 0; i < N; i++) {
                const px = i === N - 1 ? comps.max : comps.min + step * i, m = predict(px), errs = stdErrorsAt(px, comps);
                out.push({
                    x: px,
                    mean: m,
                    lower: m - z * errs.seMean,
                    upper: m + z * errs.seMean,
                    predLower: m - z * errs.sePred,
                    predUpper: m + z * errs.sePred
                });
            }
            return out;
        }
    };
}

export default {
    ordinaryLeastSquares: ordinaryLeastSquares,
    visitPoints: visitPoints,
    rSquared: rSquared,
    regressionLinear: regressionLinear
};
//# sourceMappingURL=regression-linear.js.map
