import { visitPoints } from "./regression-linear";

import { computeLinearCIComponents, invNorm, stdErrorsAt } from "./regression-utils";

export function regressionLogistic(data, x = (d => d.x), y = (d => d.y), options) {
    var _a, _b, _c;
    const maxIter = null !== (_a = null == options ? void 0 : options.maxIteration) && void 0 !== _a ? _a : 25, tol = null !== (_b = null == options ? void 0 : options.tol) && void 0 !== _b ? _b : 1e-6, alpha = null !== (_c = null == options ? void 0 : options.alpha) && void 0 !== _c ? _c : .05, xs = [], ys = [];
    visitPoints(data, x, y, ((dx, dy) => {
        xs.push(dx), ys.push(dy ? 1 : 0);
    }));
    const n = xs.length;
    if (0 === n) return {
        coef: [ 0, 0 ],
        predict: _x => 0,
        evaluateGrid: N => [],
        confidenceInterval: (N = 50) => []
    };
    let intercept = 0, beta = 0;
    for (let iter = 0; iter < maxIter; iter++) {
        const p = new Array(n);
        let converged = !0;
        for (let i = 0; i < n; i++) {
            const z = intercept + beta * xs[i], pi = 1 / (1 + Math.exp(-z));
            p[i] = pi;
        }
        let g0 = 0, g1 = 0, h00 = 0, h01 = 0, h11 = 0;
        for (let i = 0; i < n; i++) {
            const wi = p[i] * (1 - p[i]), diff = ys[i] - p[i];
            g0 += diff, g1 += diff * xs[i], h00 += wi, h01 += wi * xs[i], h11 += wi * xs[i] * xs[i];
        }
        const det = h00 * h11 - h01 * h01;
        if (Math.abs(det) < 1e-12) break;
        const delta0 = (h11 * g0 - h01 * g1) / det, delta1 = (-h01 * g0 + h00 * g1) / det;
        if (intercept += delta0, beta += delta1, (Math.abs(delta0) > tol || Math.abs(delta1) > tol) && (converged = !1), 
        converged) break;
    }
    const predict = xx => {
        const z = intercept + beta * xx;
        return 1 / (1 + Math.exp(-z));
    };
    return {
        coef: [ intercept, beta ],
        predict: predict,
        evaluateGrid: function(N) {
            const out = [];
            if (N <= 0) return out;
            let min = 1 / 0, max = -1 / 0;
            if (visitPoints(data, x, y, (dx => {
                dx < min && (min = dx), dx > max && (max = dx);
            })), min === 1 / 0 || max === -1 / 0) return out;
            if (min === max) {
                const v = predict(min);
                for (let i = 0; i < N; i++) out.push({
                    x: min,
                    y: v
                });
                return out;
            }
            const step = (max - min) / (N - 1);
            for (let i = 0; i < N; i++) {
                const px = i === N - 1 ? max : min + step * i;
                out.push({
                    x: px,
                    y: predict(px)
                });
            }
            return out;
        },
        confidenceInterval: function(N = 50) {
            const out = [];
            if (N <= 0) return out;
            const comps = computeLinearCIComponents(data, x, y, predict);
            if (0 === comps.n) return out;
            const z = Math.abs(invNorm(1 - alpha / 2));
            if (comps.min === comps.max) {
                const v = predict(comps.min), errs = stdErrorsAt(comps.min, comps);
                for (let i = 0; i < N; i++) out.push({
                    x: comps.min,
                    mean: v,
                    lower: v - z * errs.seMean,
                    upper: v + z * errs.seMean,
                    predLower: v - z * errs.sePred,
                    predUpper: v + z * errs.sePred
                });
                return out;
            }
            const step = (comps.max - comps.min) / (N - 1);
            for (let i = 0; i < N; i++) {
                const px = i === N - 1 ? comps.max : comps.min + step * i, yh = predict(px), errs = stdErrorsAt(px, comps);
                out.push({
                    x: px,
                    mean: yh,
                    lower: yh - z * errs.seMean,
                    upper: yh + z * errs.seMean,
                    predLower: yh - z * errs.sePred,
                    predUpper: yh + z * errs.sePred
                });
            }
            return out;
        }
    };
}

export default regressionLogistic;
//# sourceMappingURL=regression-logistic.js.map
