import { visitPoints, rSquared } from "./regression-linear";

import isNil from "./isNil";

import { computeLinearCIComponents, invNorm, stdErrorsAt } from "./regression-utils";

function solveLinearSystem(A, b) {
    const n = b.length, M = new Array(n);
    for (let i = 0; i < n; i++) M[i] = A[i].slice(), M[i].push(b[i]);
    for (let k = 0; k < n; k++) {
        let maxRow = k, maxVal = Math.abs(M[k][k]);
        for (let i = k + 1; i < n; i++) {
            const v = Math.abs(M[i][k]);
            v > maxVal && (maxVal = v, maxRow = i);
        }
        if (maxRow !== k) {
            const tmp = M[k];
            M[k] = M[maxRow], M[maxRow] = tmp;
        }
        if (Math.abs(M[k][k]) < 1e-12) {
            return new Array(n).fill(0);
        }
        for (let j = k + 1; j <= n; j++) M[k][j] = M[k][j] / M[k][k];
        M[k][k] = 1;
        for (let i = 0; i < n; i++) {
            if (i === k) continue;
            const factor = M[i][k];
            if (0 !== factor) {
                for (let j = k + 1; j <= n; j++) M[i][j] -= factor * M[k][j];
                M[i][k] = 0;
            }
        }
    }
    const x = new Array(n);
    for (let i = 0; i < n; i++) x[i] = M[i][n];
    return x;
}

export function regressionPolynomial(data, x = (d => d.x), y = (d => d.y), options = {}) {
    var _a, _b;
    let degree = null !== (_a = options.degree) && void 0 !== _a ? _a : 0;
    degree < 0 && (degree = 0);
    const alpha = null !== (_b = options.alpha) && void 0 !== _b ? _b : .05, m = degree + 1, sums = new Array(2 * degree + 1).fill(0);
    visitPoints(data, x, y, ((dx, dy) => {
        let xp = 1;
        for (let k = 0; k < sums.length; k++) sums[k] += xp, xp *= dx;
    }));
    const A = new Array(m);
    for (let i = 0; i < m; i++) {
        A[i] = new Array(m).fill(0);
        for (let j = 0; j < m; j++) A[i][j] = sums[i + j];
    }
    const B = new Array(m).fill(0);
    visitPoints(data, x, y, ((dx, dy) => {
        let xp = 1;
        for (let k = 0; k < m; k++) B[k] += dy * xp, xp *= dx;
    }));
    const coef = solveLinearSystem(A, B), predict = xx => {
        let xp = 1, v = 0;
        for (let k = 0; k < coef.length; k++) v += coef[k] * xp, xp *= xx;
        return v;
    };
    return {
        degree: degree,
        coef: coef,
        predict: predict,
        rSquared: rSquared(data, x, y, (() => {
            let sum = 0, cnt = 0;
            return visitPoints(data, x, y, ((_dx, dy) => {
                sum += dy, cnt++;
            })), 0 === cnt ? 0 : sum / cnt;
        })(), predict),
        evaluateGrid(N) {
            const out = [];
            if (N <= 0) return out;
            let min = 1 / 0, max = -1 / 0;
            if (visitPoints(data, x, y, (dx => {
                isNil(dx) || (dx < min && (min = dx), dx > max && (max = dx));
            })), min === 1 / 0 || max === -1 / 0) return out;
            if (min === max) {
                const v = predict(min);
                for (let i = 0; i < N; i++) out.push({
                    x: min,
                    y: v
                });
                return out;
            }
            const step = (max - min) / (N - 1);
            for (let i = 0; i < N; i++) {
                const px = i === N - 1 ? max : min + step * i;
                out.push({
                    x: px,
                    y: predict(px)
                });
            }
            return out;
        },
        confidenceInterval(N = 50) {
            const out = [];
            if (N <= 0) return out;
            const comps = computeLinearCIComponents(data, x, y, predict);
            if (0 === comps.n) return out;
            const z = Math.abs(invNorm(1 - alpha / 2));
            if (comps.min === comps.max) {
                const v = predict(comps.min), errs = stdErrorsAt(comps.min, comps);
                for (let i = 0; i < N; i++) out.push({
                    x: comps.min,
                    mean: v,
                    lower: v - z * errs.seMean,
                    upper: v + z * errs.seMean,
                    predLower: v - z * errs.sePred,
                    predUpper: v + z * errs.sePred
                });
                return out;
            }
            const step = (comps.max - comps.min) / (N - 1);
            for (let i = 0; i < N; i++) {
                const px = i === N - 1 ? comps.max : comps.min + step * i, yh = predict(px), errs = stdErrorsAt(px, comps);
                out.push({
                    x: px,
                    mean: yh,
                    lower: yh - z * errs.seMean,
                    upper: yh + z * errs.seMean,
                    predLower: yh - z * errs.sePred,
                    predUpper: yh + z * errs.sePred
                });
            }
            return out;
        }
    };
}

export default regressionPolynomial;
//# sourceMappingURL=regression-polynomial.js.map
