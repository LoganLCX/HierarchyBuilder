{"version":3,"sources":["../src/common/regression-utils.ts"],"names":[],"mappings":"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","file":"regression-utils.js","sourcesContent":["import isNil from './isNil';\n\n/**\n * Approximate inverse normal CDF (probit) using Acklam's algorithm.\n * Returns z such that P(Z <= z) = p for standard normal Z.\n */\nexport function invNorm(p: number) {\n  if (p <= 0 || p >= 1) {\n    return 0;\n  }\n\n  const a1 = -39.6968302866538;\n  const a2 = 220.946098424521;\n  const a3 = -275.928510446969;\n  const a4 = 138.357751867269;\n  const a5 = -30.6647980661472;\n  const a6 = 2.50662827745924;\n\n  const b1 = -54.4760987982241;\n  const b2 = 161.585836858041;\n  const b3 = -155.698979859887;\n  const b4 = 66.8013118877197;\n  const b5 = -13.2806815528857;\n\n  const c1 = -0.00778489400243029;\n  const c2 = -0.322396458041136;\n  const c3 = -2.40075827716184;\n  const c4 = -2.54973253934373;\n  const c5 = 4.37466414146497;\n  const c6 = 2.93816398269878;\n\n  const d1 = 0.00778469570904146;\n  const d2 = 0.32246712907004;\n  const d3 = 2.445134137143;\n  const d4 = 3.75440866190742;\n\n  const pLow = 0.02425;\n  const pHigh = 1 - pLow;\n\n  let q: number;\n  let r: number;\n\n  if (p < pLow) {\n    q = Math.sqrt(-2 * Math.log(p));\n    return (((((c1 * q + c2) * q + c3) * q + c4) * q + c5) * q + c6) / ((((d1 * q + d2) * q + d3) * q + d4) * q + 1);\n  }\n\n  if (p <= pHigh) {\n    q = p - 0.5;\n    r = q * q;\n    return (\n      ((((((a1 * r + a2) * r + a3) * r + a4) * r + a5) * r + a6) * q) /\n      (((((b1 * r + b2) * r + b3) * r + b4) * r + b5) * r + 1)\n    );\n  }\n\n  q = Math.sqrt(-2 * Math.log(1 - p));\n  return -((((((c1 * q + c2) * q + c3) * q + c4) * q + c5) * q + c6) / ((((d1 * q + d2) * q + d3) * q + d4) * q + 1));\n}\n\nexport interface LinearCIComponents {\n  min: number;\n  max: number;\n  n: number;\n  X: number; // mean of x\n  SSE: number;\n  Sxx: number;\n}\n\n/**\n * Compute basic components used for linear regression confidence / prediction intervals.\n * - scans data to compute min/max of x, n, mean X, SSE and Sxx (sum (xi - X)^2).\n */\nexport function computeLinearCIComponents(\n  data: any[],\n  x: (d: any) => number,\n  y: (d: any) => number,\n  predict: (x: number) => number\n): LinearCIComponents {\n  // simple local scanner to avoid circular imports\n  let min = Infinity;\n  let max = -Infinity;\n  let n = 0;\n  let sumX = 0;\n\n  for (let i = 0; i < data.length; i++) {\n    const d = data[i];\n    let dx = x(d);\n    let dy = y(d);\n    if (!isNil(dx) && (dx = +dx) >= dx && !isNil(dy) && (dy = +dy) >= dy) {\n      if (dx < min) {\n        min = dx;\n      }\n      if (dx > max) {\n        max = dx;\n      }\n      n++;\n      sumX += dx;\n    }\n  }\n\n  if (n === 0) {\n    return { min, max, n, X: 0, SSE: 0, Sxx: 0 };\n  }\n\n  const X = sumX / n;\n  let SSE = 0;\n  let Sxx = 0;\n  for (let i = 0; i < data.length; i++) {\n    const d = data[i];\n    let dx = x(d);\n    let dy = y(d);\n    if (!isNil(dx) && (dx = +dx) >= dx && !isNil(dy) && (dy = +dy) >= dy) {\n      const r = dy - predict(dx);\n      SSE += r * r;\n      const dxc = dx - X;\n      Sxx += dxc * dxc;\n    }\n  }\n\n  return { min, max, n, X, SSE, Sxx };\n}\n\n/**\n * Compute standard errors for mean and prediction at px using components.\n */\nexport function stdErrorsAt(px: number, comps: LinearCIComponents) {\n  const { n, X, Sxx, SSE } = comps;\n  const s2 = n > 2 ? SSE / (n - 2) : 0;\n  const seMean = Sxx > 0 ? Math.sqrt(s2 * (1 / n + ((px - X) * (px - X)) / Sxx)) : Math.sqrt(s2 / n);\n  const sePred = Math.sqrt(s2 * (1 + 1 / n + (Sxx > 0 ? ((px - X) * (px - X)) / Sxx : 0)));\n  return { seMean, sePred };\n}\n\nexport default {\n  invNorm,\n  computeLinearCIComponents,\n  stdErrorsAt\n};\n"]}