import isNil from "./isNil";

export function invNorm(p) {
    if (p <= 0 || p >= 1) return 0;
    const c1 = -.00778489400243029, c2 = -.322396458041136, c3 = -2.40075827716184, c4 = -2.54973253934373, c5 = 4.37466414146497, c6 = 2.93816398269878, d1 = .00778469570904146, d2 = .32246712907004, d3 = 2.445134137143, d4 = 3.75440866190742;
    let q, r;
    return p < .02425 ? (q = Math.sqrt(-2 * Math.log(p)), (((((c1 * q + c2) * q + c3) * q + c4) * q + c5) * q + c6) / ((((d1 * q + d2) * q + d3) * q + d4) * q + 1)) : p <= .97575 ? (q = p - .5, 
    r = q * q, (((((-39.6968302866538 * r + 220.946098424521) * r - 275.928510446969) * r + 138.357751867269) * r - 30.6647980661472) * r + 2.50662827745924) * q / (((((-54.4760987982241 * r + 161.585836858041) * r - 155.698979859887) * r + 66.8013118877197) * r - 13.2806815528857) * r + 1)) : (q = Math.sqrt(-2 * Math.log(1 - p)), 
    -(((((c1 * q + c2) * q + c3) * q + c4) * q + c5) * q + c6) / ((((d1 * q + d2) * q + d3) * q + d4) * q + 1));
}

export function computeLinearCIComponents(data, x, y, predict) {
    let min = 1 / 0, max = -1 / 0, n = 0, sumX = 0;
    for (let i = 0; i < data.length; i++) {
        const d = data[i];
        let dx = x(d), dy = y(d);
        !isNil(dx) && (dx = +dx) >= dx && !isNil(dy) && (dy = +dy) >= dy && (dx < min && (min = dx), 
        dx > max && (max = dx), n++, sumX += dx);
    }
    if (0 === n) return {
        min: min,
        max: max,
        n: n,
        X: 0,
        SSE: 0,
        Sxx: 0
    };
    const X = sumX / n;
    let SSE = 0, Sxx = 0;
    for (let i = 0; i < data.length; i++) {
        const d = data[i];
        let dx = x(d), dy = y(d);
        if (!isNil(dx) && (dx = +dx) >= dx && !isNil(dy) && (dy = +dy) >= dy) {
            const r = dy - predict(dx);
            SSE += r * r;
            const dxc = dx - X;
            Sxx += dxc * dxc;
        }
    }
    return {
        min: min,
        max: max,
        n: n,
        X: X,
        SSE: SSE,
        Sxx: Sxx
    };
}

export function stdErrorsAt(px, comps) {
    const {n: n, X: X, Sxx: Sxx, SSE: SSE} = comps, s2 = n > 2 ? SSE / (n - 2) : 0;
    return {
        seMean: Sxx > 0 ? Math.sqrt(s2 * (1 / n + (px - X) * (px - X) / Sxx)) : Math.sqrt(s2 / n),
        sePred: Math.sqrt(s2 * (1 + 1 / n + (Sxx > 0 ? (px - X) * (px - X) / Sxx : 0)))
    };
}

export default {
    invNorm: invNorm,
    computeLinearCIComponents: computeLinearCIComponents,
    stdErrorsAt: stdErrorsAt
};
//# sourceMappingURL=regression-utils.js.map
