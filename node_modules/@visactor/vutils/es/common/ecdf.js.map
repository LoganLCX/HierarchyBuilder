{"version":3,"sources":["../src/common/ecdf.ts"],"names":[],"mappings":"AAeA,MAAM,UAAU,IAAI,CAAC,IAAc;IACjC,MAAM,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC;IACtB,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;IAElD,SAAS,cAAc,CAAC,CAAS;QAC/B,IAAI,CAAC,KAAK,CAAC,EAAE;YACX,OAAO,CAAC,CAAC;SACV;QAED,IAAI,EAAE,GAAG,CAAC,CAAC;QACX,IAAI,EAAE,GAAG,CAAC,CAAC;QACX,OAAO,EAAE,GAAG,EAAE,EAAE;YACd,MAAM,GAAG,GAAG,CAAC,EAAE,GAAG,EAAE,CAAC,KAAK,CAAC,CAAC;YAC5B,IAAI,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;gBACpB,EAAE,GAAG,GAAG,GAAG,CAAC,CAAC;aACd;iBAAM;gBACL,EAAE,GAAG,GAAG,CAAC;aACV;SACF;QACD,OAAO,EAAE,GAAG,CAAC,CAAC;IAChB,CAAC;IAED,SAAS,QAAQ,CAAC,CAAoB;QACpC,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE;YACpB,MAAM,GAAG,GAAa,EAAE,CAAC;YACzB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBACjC,GAAG,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;aAChC;YACD,OAAO,GAAG,CAAC;SACZ;QACD,OAAO,cAAc,CAAC,CAAW,CAAC,CAAC;IACrC,CAAC;IAED,SAAS,YAAY,CAAC,CAAS;QAC7B,MAAM,GAAG,GAA+B,EAAE,CAAC;QAC3C,IAAI,CAAC,IAAI,CAAC,EAAE;YACV,OAAO,GAAG,CAAC;SACZ;QACD,IAAI,CAAC,KAAK,CAAC,EAAE;YACX,OAAO,GAAG,CAAC;SACZ;QACD,MAAM,GAAG,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;QACtB,MAAM,GAAG,GAAG,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;QAC1B,IAAI,GAAG,KAAK,GAAG,EAAE;YACf,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;gBAC1B,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;aAC5B;YACD,OAAO,GAAG,CAAC;SACZ;QACD,MAAM,IAAI,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;QACnC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;YAC1B,MAAM,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,GAAG,IAAI,GAAG,CAAC,CAAC;YAE7C,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,cAAc,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;SACvC;QACD,OAAO,GAAG,CAAC;IACb,CAAC;IAED,OAAO;QACL,QAAQ,EAAE,QAAe;QACzB,YAAY;QACZ,CAAC;KACF,CAAC;AACJ,CAAC;AAED,eAAe,IAAI,CAAC","file":"ecdf.js","sourcesContent":["/**\n * Empirical Cumulative Distribution Function (ECDF)\n * Returns a factory that builds an evaluator over provided samples.\n * The evaluator exposes:\n * - evaluate(x:number) => proportion of samples <= x\n * - evaluate(xs:number[]) => number[]\n * - evaluateGrid(N:number) => { points: number[], cdf: number[] } over sample range\n */\n\nexport interface ECDFEvaluator {\n  evaluate: (x: number | number[]) => number | number[];\n  evaluateGrid: (N: number) => { x: number; y: number }[];\n  n: number;\n}\n\nexport function ecdf(data: number[]): ECDFEvaluator {\n  const n = data.length;\n  const sorted = data.slice().sort((a, b) => a - b);\n\n  function evaluateSingle(x: number) {\n    if (n === 0) {\n      return 0;\n    }\n    // count of values <= x (upper bound index)\n    let lo = 0;\n    let hi = n; // exclusive\n    while (lo < hi) {\n      const mid = (lo + hi) >>> 1;\n      if (sorted[mid] <= x) {\n        lo = mid + 1;\n      } else {\n        hi = mid;\n      }\n    }\n    return lo / n;\n  }\n\n  function evaluate(x: number | number[]) {\n    if (Array.isArray(x)) {\n      const out: number[] = [];\n      for (let i = 0; i < x.length; i++) {\n        out.push(evaluateSingle(x[i]));\n      }\n      return out;\n    }\n    return evaluateSingle(x as number);\n  }\n\n  function evaluateGrid(N: number) {\n    const out: { x: number; y: number }[] = [];\n    if (N <= 0) {\n      return out;\n    }\n    if (n === 0) {\n      return out;\n    }\n    const min = sorted[0];\n    const max = sorted[n - 1];\n    if (min === max) {\n      for (let i = 0; i < N; i++) {\n        out.push({ x: min, y: 1 });\n      }\n      return out;\n    }\n    const step = (max - min) / (N - 1);\n    for (let i = 0; i < N; i++) {\n      const x = i === N - 1 ? max : min + step * i;\n\n      out.push({ x, y: evaluateSingle(x) });\n    }\n    return out;\n  }\n\n  return {\n    evaluate: evaluate as any,\n    evaluateGrid,\n    n\n  };\n}\n\nexport default ecdf;\n"]}