"use strict";

var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        default: mod
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.regressionLinear = exports.rSquared = exports.visitPoints = exports.ordinaryLeastSquares = void 0;

const isNil_1 = __importDefault(require("./isNil")), regression_utils_1 = require("./regression-utils");

function ordinaryLeastSquares(uX, uY, uXY, uX2) {
    const denom = uX2 - uX * uX;
    if (Math.abs(denom) < Number.EPSILON) return {
        a: uY,
        b: 0
    };
    const b = (uXY - uX * uY) / denom;
    return {
        a: uY - b * uX,
        b: b
    };
}

function visitPoints(data, x, y, callback) {
    for (let i = 0; i < data.length; i++) {
        const d = data[i];
        let xi = x(d), yi = y(d);
        !(0, isNil_1.default)(xi) && (xi = +xi) >= xi && !(0, isNil_1.default)(yi) && (yi = +yi) >= yi && callback(xi, yi, i);
    }
}

function rSquared(data, x, y, uY, predict) {
    let ssr = 0, sst = 0;
    for (let i = 0; i < data.length; i++) {
        const d = data[i];
        let yi = y(d);
        if (!(0, isNil_1.default)(yi) && (yi = +yi) >= yi) {
            const r = yi - predict(x(d));
            ssr += r * r;
            const t = yi - uY;
            sst += t * t;
        }
    }
    return 0 === sst ? 0 : 1 - ssr / sst;
}

function regressionLinear(data, x = (d => d.x), y = (d => d.y), options) {
    var _a;
    const alpha = null !== (_a = null == options ? void 0 : options.alpha) && void 0 !== _a ? _a : .05;
    let n = 0, meanX = 0, meanY = 0, meanXY = 0, meanX2 = 0;
    visitPoints(data, x, y, ((xi, yi) => {
        n++, meanX += (xi - meanX) / n, meanY += (yi - meanY) / n, meanXY += (xi * yi - meanXY) / n, 
        meanX2 += (xi * xi - meanX2) / n;
    }));
    const {a: a, b: b} = ordinaryLeastSquares(meanX, meanY, meanXY, meanX2), predict = xx => a + b * xx, comps = (0, 
    regression_utils_1.computeLinearCIComponents)(data, x, y, predict);
    return {
        coef: {
            a: a,
            b: b
        },
        predict: predict,
        rSquared: rSquared(data, x, y, meanY, predict),
        evaluateGrid: function(N) {
            const out = [];
            if (0 === comps.n || N <= 0) return out;
            if (comps.min === comps.max) {
                for (let i = 0; i < N; i++) out.push({
                    x: comps.min,
                    y: predict(comps.min)
                });
                return out;
            }
            const step = (comps.max - comps.min) / (N - 1);
            for (let i = 0; i < N; i++) {
                const px = i === N - 1 ? comps.max : comps.min + step * i;
                out.push({
                    x: px,
                    y: predict(px)
                });
            }
            return out;
        },
        confidenceInterval: function(N = 50) {
            const out = [];
            if (0 === comps.n || N <= 0) return out;
            const z = (0, regression_utils_1.invNorm)(1 - alpha / 2);
            if (comps.min === comps.max) {
                const m = predict(comps.min), errs = (0, regression_utils_1.stdErrorsAt)(comps.min, comps);
                for (let i = 0; i < N; i++) out.push({
                    x: comps.min,
                    mean: m,
                    lower: m - z * errs.seMean,
                    upper: m + z * errs.seMean,
                    predLower: m - z * errs.sePred,
                    predUpper: m + z * errs.sePred
                });
                return out;
            }
            const step = (comps.max - comps.min) / (N - 1);
            for (let i = 0; i < N; i++) {
                const px = i === N - 1 ? comps.max : comps.min + step * i, m = predict(px), errs = (0, 
                regression_utils_1.stdErrorsAt)(px, comps);
                out.push({
                    x: px,
                    mean: m,
                    lower: m - z * errs.seMean,
                    upper: m + z * errs.seMean,
                    predLower: m - z * errs.sePred,
                    predUpper: m + z * errs.sePred
                });
            }
            return out;
        }
    };
}

exports.ordinaryLeastSquares = ordinaryLeastSquares, exports.visitPoints = visitPoints, 
exports.rSquared = rSquared, exports.regressionLinear = regressionLinear, exports.default = {
    ordinaryLeastSquares: ordinaryLeastSquares,
    visitPoints: visitPoints,
    rSquared: rSquared,
    regressionLinear: regressionLinear
};
//# sourceMappingURL=regression-linear.js.map
