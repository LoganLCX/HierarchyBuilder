"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.regressionLowess = void 0;

const regression_linear_1 = require("./regression-linear"), regression_utils_1 = require("./regression-utils");

function tricube(u) {
    const uu = Math.abs(u);
    if (uu >= 1) return 0;
    const t = 1 - uu * uu * uu;
    return t * t * t;
}

function stratifiedSample(sortedData, maxSamples) {
    const n = sortedData.length;
    if (n <= maxSamples) return sortedData;
    const sampled = [], step = n / maxSamples;
    for (let i = 0; i < maxSamples; i++) {
        const idx = Math.min(Math.floor(i * step), n - 1);
        sampled.push(sortedData[idx]);
    }
    return sampled;
}

function regressionLowess(data, x = (d => d.x), y = (d => d.y), options = {}) {
    var _a;
    const span = options.span || .3, degree = 0 === options.degree ? 0 : 1, alpha = null !== (_a = options.alpha) && void 0 !== _a ? _a : .05, iterations = null == options.iterations ? 2 : options.iterations, maxSamples = options.maxSamples || 1e3, rawPoints = [];
    (0, regression_linear_1.visitPoints)(data, x, y, ((dx, dy) => {
        rawPoints.push({
            x: dx,
            y: dy
        });
    })), rawPoints.sort(((a, b) => a.x - b.x));
    const sampledPoints = stratifiedSample(rawPoints, maxSamples), n = sampledPoints.length, ptsX = new Array(n), ptsY = new Array(n);
    for (let i = 0; i < n; i++) ptsX[i] = sampledPoints[i].x, ptsY[i] = sampledPoints[i].y;
    function predictSingle(x0, robustWeights) {
        if (0 === n) return 0;
        let left = 0, right = n;
        for (;left < right; ) {
            const mid = left + right >> 1;
            ptsX[mid] < x0 ? left = mid + 1 : right = mid;
        }
        const m = Math.max(2, Math.min(n, Math.floor(span * n))), start = Math.max(0, left - Math.floor(m / 2)), end = Math.min(n, start + m), actualStart = Math.max(0, end - m);
        let maxDist = 0;
        const windowSize = end - actualStart, distances = new Array(windowSize);
        for (let i = actualStart; i < end; i++) {
            const dist = Math.abs(ptsX[i] - x0);
            distances[i - actualStart] = dist, dist > maxDist && (maxDist = dist);
        }
        let sumw = 0;
        const w = new Array(windowSize);
        for (let i = 0; i < windowSize; i++) {
            let wi = tricube(0 === maxDist ? 0 : distances[i] / maxDist);
            robustWeights && null != robustWeights[actualStart + i] && (wi *= robustWeights[actualStart + i]), 
            w[i] = wi, sumw += wi;
        }
        if (0 === sumw) {
            return ptsY[left < n ? left : n - 1];
        }
        if (0 === degree) {
            let s = 0;
            for (let i = 0; i < w.length; i++) s += w[i] * ptsY[actualStart + i];
            return s / sumw;
        }
        let sw = 0, sx = 0, sy = 0, sxx = 0, sxy = 0;
        for (let i = actualStart; i < end; i++) {
            const idx = i - actualStart, xi = ptsX[i], yi = ptsY[i], wi = w[idx];
            sw += wi, sx += wi * xi, sy += wi * yi, sxx += wi * xi * xi, sxy += wi * xi * yi;
        }
        const meanX = sx / sw, meanY = sy / sw, denom = sxx - sx * meanX, slope = Math.abs(denom) < 1e-12 ? 0 : (sxy - sx * meanY) / denom;
        return meanY - slope * meanX + slope * x0;
    }
    function predict(x0) {
        if (Array.isArray(x0)) {
            const len = x0.length, out = new Array(len);
            for (let i = 0; i < len; i++) out[i] = predictSingle(x0[i]);
            return out;
        }
        return predictSingle(x0);
    }
    return {
        predict: predict,
        evaluate: predict,
        evaluateGrid: function(N) {
            if (N <= 0) return [];
            if (0 === n) return [];
            const out = new Array(N), min = ptsX[0], max = ptsX[n - 1];
            if (min === max) {
                const v = predictSingle(min);
                for (let i = 0; i < N; i++) out[i] = {
                    x: min,
                    y: v
                };
                return out;
            }
            const step = (max - min) / (N - 1);
            let robustWeights;
            const effectiveIterations = null != options.iterations ? iterations : n > 500 ? 0 : iterations;
            if (effectiveIterations > 0) for (let iter = 0; iter < effectiveIterations; iter++) {
                const fits = new Array(n), res = new Array(n);
                for (let i = 0; i < n; i++) fits[i] = predictSingle(ptsX[i], robustWeights), res[i] = Math.abs(ptsY[i] - fits[i]);
                const med = res.slice().sort(((a, b) => a - b))[Math.floor(n / 2)] || 0;
                robustWeights = new Array(n);
                for (let i = 0; i < n; i++) {
                    const u = 0 === med ? 0 : res[i] / (6 * med), w = Math.abs(u) >= 1 ? 0 : (1 - u * u) * (1 - u * u);
                    robustWeights[i] = w;
                }
            }
            for (let i = 0; i < N; i++) {
                const px = i === N - 1 ? max : min + step * i;
                out[i] = {
                    x: px,
                    y: predictSingle(px, robustWeights)
                };
            }
            return out;
        },
        confidenceInterval: function(N = 50) {
            const out = [];
            if (N <= 0) return out;
            if (0 === n) return out;
            const min = ptsX[0], max = ptsX[n - 1];
            if (void 0 === min || void 0 === max || min === 1 / 0 || max === -1 / 0) return out;
            const comps = (0, regression_utils_1.computeLinearCIComponents)(data, x, y, (xx => predictSingle(xx)));
            if (0 === comps.n) return out;
            const z = Math.abs((0, regression_utils_1.invNorm)(1 - alpha / 2));
            if (comps.min === comps.max) {
                const v = predictSingle(comps.min), errs = (0, regression_utils_1.stdErrorsAt)(comps.min, comps);
                for (let i = 0; i < N; i++) out.push({
                    x: comps.min,
                    mean: v,
                    lower: v - z * errs.seMean,
                    upper: v + z * errs.seMean,
                    predLower: v - z * errs.sePred,
                    predUpper: v + z * errs.sePred
                });
                return out;
            }
            const step = (max - min) / (N - 1);
            for (let i = 0; i < N; i++) {
                const px = i === N - 1 ? max : min + step * i, yh = predictSingle(px), errs = (0, 
                regression_utils_1.stdErrorsAt)(px, comps);
                out.push({
                    x: px,
                    mean: yh,
                    lower: yh - z * errs.seMean,
                    upper: yh + z * errs.seMean,
                    predLower: yh - z * errs.sePred,
                    predUpper: yh + z * errs.sePred
                });
            }
            return out;
        }
    };
}

exports.regressionLowess = regressionLowess, exports.default = regressionLowess;
//# sourceMappingURL=regression-lowess.js.map
