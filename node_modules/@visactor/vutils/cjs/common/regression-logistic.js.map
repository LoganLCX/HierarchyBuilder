{"version":3,"sources":["../src/common/regression-logistic.ts"],"names":[],"mappings":"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","file":"regression-logistic.js","sourcesContent":["import { visitPoints } from './regression-linear';\nimport { computeLinearCIComponents, invNorm, stdErrorsAt } from './regression-utils';\n\n/**\n * Simple logistic regression (binary) using Newton-Raphson (IRLS).\n * Returns { coef, predict, evaluateGrid }\n * - coef: [intercept, beta]\n * - predict(x): probability p(y=1|x)\n */\nexport function regressionLogistic(\n  data: any[],\n  x: (d: any) => number = d => d.x,\n  y: (d: any) => number = d => d.y,\n  options?: { maxIteration?: number; tol?: number; alpha?: number }\n) {\n  const maxIter = options?.maxIteration ?? 25;\n  const tol = options?.tol ?? 1e-6;\n  const alpha = options?.alpha ?? 0.05;\n  // build arrays\n  const xs: number[] = [];\n  const ys: number[] = [];\n  visitPoints(data, x, y, (dx, dy) => {\n    xs.push(dx);\n    ys.push(dy ? 1 : 0);\n  });\n\n  const n = xs.length;\n  if (n === 0) {\n    return {\n      coef: [0, 0],\n      predict: (_x: number) => 0,\n      evaluateGrid: (N: number) => [] as { x: number; y: number }[],\n      confidenceInterval: (N: number = 50) =>\n        [] as { x: number; mean: number; lower: number; upper: number; predLower: number; predUpper: number }[]\n    };\n  }\n\n  // initial coef via linear regression rough guess\n  let intercept = 0;\n  let beta = 0;\n\n  for (let iter = 0; iter < maxIter; iter++) {\n    const p: number[] = new Array(n);\n    let converged = true;\n    for (let i = 0; i < n; i++) {\n      const z = intercept + beta * xs[i];\n      const pi = 1 / (1 + Math.exp(-z));\n      p[i] = pi;\n    }\n\n    // compute gradient and hessian\n    let g0 = 0;\n    let g1 = 0;\n    let h00 = 0;\n    let h01 = 0;\n    let h11 = 0;\n    for (let i = 0; i < n; i++) {\n      const wi = p[i] * (1 - p[i]);\n      const diff = ys[i] - p[i];\n      g0 += diff;\n      g1 += diff * xs[i];\n      h00 += wi;\n      h01 += wi * xs[i];\n      h11 += wi * xs[i] * xs[i];\n    }\n\n    // solve 2x2 system H * delta = g\n    const det = h00 * h11 - h01 * h01;\n    if (Math.abs(det) < 1e-12) {\n      break;\n    }\n    const delta0 = (h11 * g0 - h01 * g1) / det;\n    const delta1 = (-h01 * g0 + h00 * g1) / det;\n\n    intercept += delta0;\n    beta += delta1;\n\n    if (Math.abs(delta0) > tol || Math.abs(delta1) > tol) {\n      converged = false;\n    }\n    if (converged) {\n      break;\n    }\n  }\n\n  const predict = (xx: number) => {\n    const z = intercept + beta * xx;\n    return 1 / (1 + Math.exp(-z));\n  };\n\n  function evaluateGrid(N: number) {\n    const out: { x: number; y: number }[] = [];\n    if (N <= 0) {\n      return out;\n    }\n    let min = Infinity;\n    let max = -Infinity;\n    visitPoints(data, x, y, dx => {\n      if (dx < min) {\n        min = dx;\n      }\n      if (dx > max) {\n        max = dx;\n      }\n    });\n    if (min === Infinity || max === -Infinity) {\n      return out;\n    }\n    if (min === max) {\n      const v = predict(min);\n      for (let i = 0; i < N; i++) {\n        out.push({ x: min, y: v });\n      }\n      return out;\n    }\n    const step = (max - min) / (N - 1);\n    for (let i = 0; i < N; i++) {\n      const px = i === N - 1 ? max : min + step * i;\n      out.push({ x: px, y: predict(px) });\n    }\n    return out;\n  }\n\n  function confidenceInterval(N: number = 50) {\n    const out: { x: number; mean: number; lower: number; upper: number; predLower: number; predUpper: number }[] = [];\n\n    if (N <= 0) {\n      return out;\n    }\n\n    const comps = computeLinearCIComponents(data, x, y, predict);\n    if (comps.n === 0) {\n      return out;\n    }\n\n    const z = Math.abs(invNorm(1 - alpha / 2));\n    if (comps.min === comps.max) {\n      const v = predict(comps.min);\n      const errs = stdErrorsAt(comps.min, comps);\n      for (let i = 0; i < N; i++) {\n        out.push({\n          x: comps.min,\n          mean: v,\n          lower: v - z * errs.seMean,\n          upper: v + z * errs.seMean,\n          predLower: v - z * errs.sePred,\n          predUpper: v + z * errs.sePred\n        });\n      }\n      return out;\n    }\n\n    const step = (comps.max - comps.min) / (N - 1);\n    for (let i = 0; i < N; i++) {\n      const px = i === N - 1 ? comps.max : comps.min + step * i;\n      const yh = predict(px);\n      const errs = stdErrorsAt(px, comps);\n      out.push({\n        x: px,\n        mean: yh,\n        lower: yh - z * errs.seMean,\n        upper: yh + z * errs.seMean,\n        predLower: yh - z * errs.sePred,\n        predUpper: yh + z * errs.sePred\n      });\n    }\n    return out;\n  }\n\n  return {\n    coef: [intercept, beta],\n    predict,\n    evaluateGrid,\n    confidenceInterval\n  };\n}\n\nexport default regressionLogistic;\n"]}