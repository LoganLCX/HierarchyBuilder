"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.kde = exports.silverman = exports.scott = exports.epanechnikov = exports.gaussian = void 0;

const gaussian = u => 1 / Math.sqrt(2 * Math.PI) * Math.exp(-.5 * u * u);

exports.gaussian = gaussian;

const epanechnikov = u => Math.abs(u) <= 1 ? .75 * (1 - u * u) : 0;

function scott(n, std, dim = 1) {
    return n <= 0 || 0 === std ? 0 : std * Math.pow(n, -1 / (dim + 4));
}

function silverman(n, std, dim = 1) {
    if (n <= 0 || 0 === std) return 0;
    return Math.pow(4 / (dim + 2), 1 / (dim + 4)) * std * Math.pow(n, -1 / (dim + 4));
}

function std(values) {
    const n = values.length;
    if (0 === n) return 0;
    let mean = 0;
    for (let i = 0; i < n; i++) mean += values[i];
    mean /= n;
    let s = 0;
    for (let i = 0; i < n; i++) {
        const d = values[i] - mean;
        s += d * d;
    }
    return Math.sqrt(s / n);
}

function kde(data, options = {}) {
    const n = data.length, kernel = options.kernel || exports.gaussian;
    let h = options.bandwidth;
    if (!h || h <= 0) {
        const sd = std(data) || 0, method = options.bandwidthMethod || "scott";
        h = "silverman" === method ? silverman(n, sd, 1) : scott(n, sd, 1);
    }
    if (!h || h <= 0) {
        return {
            bandwidth: 0,
            kernel: kernel,
            evaluate: x => {
                if (Array.isArray(x)) {
                    const out = [];
                    for (let i = 0; i < x.length; i++) out.push(0);
                    return out;
                }
                return 0;
            },
            evaluateGrid: N => {
                const out = [];
                if (N <= 0) return out;
                let min = 1 / 0, max = -1 / 0;
                for (let j = 0; j < n; j++) {
                    const v = data[j];
                    v < min && (min = v), v > max && (max = v);
                }
                if (min === 1 / 0 || max === -1 / 0) {
                    for (let i = 0; i < N; i++) out.push({
                        x: 0,
                        y: 0
                    });
                    return out;
                }
                for (let i = 0; i < N; i++) out.push({
                    x: min,
                    y: 0
                });
                return out;
            }
        };
    }
    const invNh = 1 / (n * h);
    function evalPoint(x) {
        let sum = 0;
        for (let j = 0; j < n; j++) sum += kernel((x - data[j]) / h);
        return sum * invNh;
    }
    return {
        bandwidth: h,
        kernel: kernel,
        evaluate: function(x) {
            if (Array.isArray(x)) {
                const out = [];
                for (let i = 0; i < x.length; i++) out.push(evalPoint(x[i]));
                return out;
            }
            return evalPoint(x);
        },
        evaluateGrid(N) {
            const out = [];
            if (N <= 0) return out;
            let min = 1 / 0, max = -1 / 0;
            for (let i = 0; i < n; i++) {
                const v = data[i];
                v < min && (min = v), v > max && (max = v);
            }
            if (min === 1 / 0 || max === -1 / 0) return out;
            if (min === max) {
                for (let i = 0; i < N; i++) out.push({
                    x: min,
                    y: evalPoint(min)
                });
                return out;
            }
            const step = (max - min) / (N - 1);
            for (let i = 0; i < N; i++) {
                const x = i === N - 1 ? max : min + step * i;
                out.push({
                    x: x,
                    y: evalPoint(x)
                });
            }
            return out;
        }
    };
}

exports.epanechnikov = epanechnikov, exports.scott = scott, exports.silverman = silverman, 
exports.kde = kde, exports.default = kde;
//# sourceMappingURL=kde.js.map
