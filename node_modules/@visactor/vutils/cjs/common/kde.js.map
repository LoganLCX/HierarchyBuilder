{"version":3,"sources":["../src/common/kde.ts"],"names":[],"mappings":"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","file":"kde.js","sourcesContent":["/**\n * Kernel Density Estimation (KDE) utilities\n *\n * Exports:\n * - Kernel functions: gaussian, epanechnikov\n * - bandwidth selectors: scott, silverman\n * - kde: main function to compute density estimates at provided points\n */\n\nexport type Kernel = (u: number) => number;\n\n/** Gaussian kernel (standard normal) */\nexport const gaussian: Kernel = (u: number) => {\n  const invSqrt2Pi = 1 / Math.sqrt(2 * Math.PI);\n  return invSqrt2Pi * Math.exp(-0.5 * u * u);\n};\n\n/** Epanechnikov kernel (compact support) */\nexport const epanechnikov: Kernel = (u: number) => {\n  const absu = Math.abs(u);\n  return absu <= 1 ? 0.75 * (1 - u * u) : 0;\n};\n\n/**\n * Bandwidth selectors\n * - scott: h = n^{-1/(d+4)} * std\n * - silverman: h = ( (4/(d+2))^{1/(d+4)} ) * n^{-1/(d+4)} * std\n */\nexport function scott(n: number, std: number, dim = 1) {\n  if (n <= 0 || std === 0) {\n    return 0;\n  }\n  return std * Math.pow(n, -1 / (dim + 4));\n}\n\nexport function silverman(n: number, std: number, dim = 1) {\n  if (n <= 0 || std === 0) {\n    return 0;\n  }\n  const factor = Math.pow(4 / (dim + 2), 1 / (dim + 4));\n  return factor * std * Math.pow(n, -1 / (dim + 4));\n}\n\nexport interface KDEOptions {\n  kernel?: Kernel;\n  bandwidth?: number; // fixed bandwidth\n  bandwidthMethod?: 'scott' | 'silverman';\n  // if bandwidth not provided, compute from data using method\n}\n\n/**\n * Compute standard deviation for numeric array\n */\nfunction std(values: number[]) {\n  const n = values.length;\n  if (n === 0) {\n    return 0;\n  }\n  let mean = 0;\n  for (let i = 0; i < n; i++) {\n    mean += values[i];\n  }\n  mean /= n;\n  let s = 0;\n  for (let i = 0; i < n; i++) {\n    const d = values[i] - mean;\n    s += d * d;\n  }\n  return Math.sqrt(s / n);\n}\n\nexport interface KDEEvaluator {\n  bandwidth: number;\n  kernel: Kernel;\n  /**\n   * Evaluate density at a single point or array of points.\n   * - If given a number, returns a number.\n   * - If given an array, returns an array aligned with input.\n   */\n  evaluate: ((x: number) => number) & ((xs: number[]) => number[]);\n  /**\n   * Produce N uniformly spaced points across the data range and evaluate densities.\n   * Returns an array { x: number, y: number }[].\n   */\n  evaluateGrid: (N: number) => { x: number; y: number }[];\n}\n\n/**\n * Factory: create a KDE evaluator for given data and options.\n * Usage: const model = kde(data, options); model.evaluate(x) or model.evaluate([x1,x2])\n */\nexport function kde(data: number[], options: KDEOptions = {}): KDEEvaluator {\n  const n = data.length;\n  const kernel = options.kernel || gaussian;\n\n  let h = options.bandwidth;\n  if (!h || h <= 0) {\n    const sd = std(data) || 0;\n    const method = options.bandwidthMethod || 'scott';\n    if (method === 'silverman') {\n      h = silverman(n, sd, 1);\n    } else {\n      h = scott(n, sd, 1);\n    }\n  }\n\n  // if still zero (constant data), evaluator returns zeros\n  if (!h || h <= 0) {\n    const zerosEval = (x: number | number[]) => {\n      if (Array.isArray(x)) {\n        const out: number[] = [];\n        for (let i = 0; i < x.length; i++) {\n          out.push(0);\n        }\n        return out;\n      }\n      return 0;\n    };\n    const zerosGrid = (N: number) => {\n      const out: { x: number; y: number }[] = [];\n      if (N <= 0) {\n        return out;\n      }\n      // compute data min (use data range if available)\n      let min = Infinity;\n      let max = -Infinity;\n      for (let j = 0; j < n; j++) {\n        const v = data[j];\n        if (v < min) {\n          min = v;\n        }\n        if (v > max) {\n          max = v;\n        }\n      }\n      if (min === Infinity || max === -Infinity) {\n        for (let i = 0; i < N; i++) {\n          out.push({ x: 0, y: 0 });\n        }\n        return out;\n      }\n      for (let i = 0; i < N; i++) {\n        out.push({ x: min, y: 0 });\n      }\n      return out;\n    };\n    return {\n      bandwidth: 0,\n      kernel,\n      evaluate: zerosEval as any,\n      evaluateGrid: zerosGrid\n    };\n  }\n\n  const invNh = 1 / (n * h);\n\n  function evalPoint(x: number) {\n    let sum = 0;\n    for (let j = 0; j < n; j++) {\n      sum += kernel((x - data[j]) / h);\n    }\n    return sum * invNh;\n  }\n\n  function evaluate(x: number | number[]) {\n    if (Array.isArray(x)) {\n      const out: number[] = [];\n      for (let i = 0; i < x.length; i++) {\n        out.push(evalPoint(x[i]));\n      }\n      return out;\n    }\n    return evalPoint(x as number);\n  }\n\n  return {\n    bandwidth: h,\n    kernel,\n    evaluate: evaluate as any,\n    evaluateGrid(N: number) {\n      const out: { x: number; y: number }[] = [];\n      if (N <= 0) {\n        return out;\n      }\n      // compute data range\n      let min = Infinity;\n      let max = -Infinity;\n      for (let i = 0; i < n; i++) {\n        const v = data[i];\n        if (v < min) {\n          min = v;\n        }\n        if (v > max) {\n          max = v;\n        }\n      }\n      if (min === Infinity || max === -Infinity) {\n        return out;\n      }\n      if (min === max) {\n        // single point repeated\n        for (let i = 0; i < N; i++) {\n          out.push({ x: min, y: evalPoint(min) });\n        }\n        return out;\n      }\n\n      const step = (max - min) / (N - 1);\n      for (let i = 0; i < N; i++) {\n        const x = i === N - 1 ? max : min + step * i;\n        out.push({ x, y: evalPoint(x) });\n      }\n      return out;\n    }\n  };\n}\n\nexport default kde;\n"]}