{"version":3,"sources":["../src/transform/bin.ts"],"names":[],"mappings":"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","file":"bin.js","sourcesContent":["import { isNil, isArray } from '@visactor/vutils';\nimport type { Transform } from '.';\n\nexport interface IBinOptions {\n  /**\n   * numeric field to bin\n   */\n  field: string;\n  /**\n   * count of numeric field\n   */\n  countField?: string;\n  /**\n   *  number of bins (default 10)\n   */\n  bins?: number;\n  /**\n   *  explicit bin edges\n   */\n  thresholds?: number[];\n  /**\n   * optional fixed bin width (interval step). If provided, overrides bins.\n   */\n  step?: number;\n  /**\n   * optional [min, max] to use instead of data-driven\n   */\n  extent?: [number, number];\n  /**\n   * whether to keep the original items in each bin\n   */\n  includeValues?: boolean;\n  /** optional grouping field(s): when provided, counts are aggregated per group per bin (groups counted as units) */\n  groupField?: string | string[];\n  /** subView Field */\n  facetField?: string | string[];\n  /**\n   * the field name of output data\n   */\n  outputNames?: { x0?: string; x1?: string; count?: string; values?: string; percentage?: string };\n}\n\ninterface ISubBinOptions extends IBinOptions {\n  numBins: number;\n  countName: string;\n  countField: string;\n  valuesName: string;\n  percentageName: string;\n  field: string;\n  thresholds: number[];\n  n: number;\n  x0Name: string;\n  x1Name: string;\n}\n\nconst subBin: Transform = (data: Array<object>, options: ISubBinOptions) => {\n  const { numBins, thresholds, countName, percentageName, valuesName, countField, field, n, x0Name, x1Name } = options;\n\n  const groupField = options.groupField;\n  const usingGroup = Array.isArray(groupField) ? groupField.length > 0 : !!groupField;\n\n  // we'll build outputs later; if no grouping, pre-create per-bin outputs\n  const out: any[] = [];\n  if (!usingGroup) {\n    for (let i = 0; i < numBins; i++) {\n      const rec: any = { [x0Name]: thresholds[i], [x1Name]: thresholds[i + 1], [countName]: 0 };\n      if (options.includeValues) {\n        rec[valuesName] = [] as object[];\n      }\n      out.push(rec);\n    }\n  }\n\n  // when grouping, keep per-bin maps from groupKey -> aggregated weight, values and representative group object\n  const binGroupCounts: Array<Map<string, number>> = usingGroup ? new Array(numBins).fill(0).map(() => new Map()) : [];\n  const binGroupValues: Array<Map<string, any[]>> = usingGroup ? new Array(numBins).fill(0).map(() => new Map()) : [];\n  const groupKeyOrder: string[] = [];\n  const groupKeySet = new Set<string>();\n  const groupRepr = new Map<string, any>();\n\n  for (let i = 0; i < n; i++) {\n    const v: any = (data[i] as any)[field];\n    if (v == null) {\n      continue;\n    }\n    const num = +v;\n    if (!Number.isFinite(num)) {\n      continue;\n    }\n\n    // find bin index (linear scan is fine for moderate bin counts)\n    for (let j = 0; j < numBins; j++) {\n      const left = thresholds[j];\n      const right = thresholds[j + 1];\n      const isLast = j === numBins - 1;\n      if ((num >= left && num < right) || (isLast && num <= right)) {\n        const datumCount = (data[i] as any)[countField] ?? 1;\n        if (usingGroup) {\n          // compute group key\n          let gk: string;\n          if (isArray(groupField)) {\n            gk = (groupField as string[]).map(f => String((data[i] as any)[f])).join('||');\n          } else {\n            gk = String((data[i] as any)[groupField as string]);\n          }\n          const m = binGroupCounts[j];\n          const prev = m.get(gk) ?? 0;\n          m.set(gk, prev + datumCount);\n          if (!groupKeySet.has(gk)) {\n            groupKeySet.add(gk);\n            groupKeyOrder.push(gk);\n            if (isArray(groupField)) {\n              groupRepr.set(gk, Object.fromEntries((groupField as string[]).map(f => [f, (data[i] as any)[f]])));\n            } else {\n              groupRepr.set(gk, (data[i] as any)[groupField as string]);\n            }\n          }\n          // collect values per group if needed\n          if (options && options.includeValues) {\n            const vv = binGroupValues[j];\n            if (!vv.has(gk)) {\n              vv.set(gk, []);\n            }\n            const arr = vv.get(gk);\n            if (arr) {\n              arr.push(data[i]);\n            }\n          }\n        } else {\n          out[j][countName] += datumCount;\n        }\n        if (options && options.includeValues && !usingGroup) {\n          out[j][valuesName].push(data[i]);\n        }\n        break;\n      }\n    }\n  }\n\n  // compute counts and totalCount, and build final outputs\n  let totalCount = 0;\n  const finalOut: any[] = [];\n  if (usingGroup) {\n    for (let j = 0; j < numBins; j++) {\n      for (const gk of groupKeyOrder) {\n        const sum = binGroupCounts[j].get(gk) ?? 0;\n        const rec: any = { [x0Name]: thresholds[j], [x1Name]: thresholds[j + 1], [countName]: sum };\n        const repr = groupRepr.get(gk) ?? {};\n        if (isArray(groupField)) {\n          for (const f of groupField as string[]) {\n            rec[f] = repr[f];\n          }\n        } else if (groupField) {\n          rec[groupField as string] = repr;\n        }\n        if (options && options.includeValues) {\n          rec[valuesName] = binGroupValues[j].get(gk) || [];\n        }\n        finalOut.push(rec);\n        totalCount += sum;\n      }\n    }\n    const denominator = totalCount;\n    for (const r of finalOut) {\n      r[percentageName] = denominator > 0 ? r[countName] / denominator : 0;\n    }\n  } else {\n    for (let i = 0, len = out.length; i < len; i++) {\n      totalCount += out[i][countName];\n    }\n    for (let i = 0, len = out.length; i < len; i++) {\n      out[i][percentageName] = totalCount > 0 ? out[i][countName] / totalCount : 0;\n      finalOut.push(out[i]);\n    }\n  }\n\n  return finalOut;\n};\n/**\n * Bin transform: converts numeric field into histogram bins.\n * Returns an array of bins: { x0, x1, count, values? }\n */\nexport const bin: Transform = (data: Array<object>, options?: IBinOptions) => {\n  const field = options?.field;\n  if (!field) {\n    return [];\n  }\n  const countField = options.countField;\n  const n = data.length;\n  // compute data-driven extent\n  let min = Infinity;\n  let max = -Infinity;\n\n  if (options.extent) {\n    min = options.extent[0];\n    max = options.extent[1];\n  } else {\n    for (let i = 0; i < n; i++) {\n      const v: any = (data[i] as any)[field];\n      if (isNil(v)) {\n        continue;\n      }\n      const num = +v;\n      if (Number.isFinite(num)) {\n        if (num < min) {\n          min = num;\n        }\n        if (num > max) {\n          max = num;\n        }\n      }\n    }\n  }\n\n  if (!Number.isFinite(min) || !Number.isFinite(max) || n === 0) {\n    return [];\n  }\n\n  // build thresholds\n  let thresholds: number[] | undefined;\n  if (options.thresholds && options.thresholds.length) {\n    // explicit thresholds provided by user\n    thresholds = options.thresholds.slice();\n    thresholds.sort((a, b) => a - b);\n  } else if (typeof options.step === 'number' && options.step > 0) {\n    // fixed bin width (step) provided: compute number of bins to cover [min, max]\n    const stepSize = options.step;\n    let startMin = min;\n\n    if (!options.extent) {\n      startMin = Math.floor(min / stepSize) * stepSize;\n    }\n    thresholds = [startMin];\n\n    while (startMin <= max) {\n      startMin += stepSize;\n      thresholds.push(startMin);\n    }\n  } else {\n    // fallback to bins count (default 10)\n    let bins = options.bins && options.bins > 0 ? Math.floor(options.bins) : 10;\n    // If the data range is larger than 1, prefer integer thresholds when possible.\n    if (max - min > 1) {\n      const start = Math.floor(min);\n      const stepSizeInt = Math.ceil((max - start) / bins);\n      thresholds = new Array(bins + 1);\n      for (let i = 0; i <= bins; i++) {\n        thresholds[i] = start + stepSizeInt * i;\n        if (thresholds[i] > max) {\n          bins = i;\n          thresholds.length = bins + 1;\n          break;\n        }\n      }\n    } else {\n      const stepSize = (max - min) / bins;\n      thresholds = new Array(bins + 1);\n      for (let i = 0; i <= bins; i++) {\n        thresholds[i] = min + stepSize * i;\n        if (thresholds[i] > max) {\n          bins = i;\n          thresholds.length = bins + 1;\n          break;\n        }\n      }\n    }\n  }\n\n  const numBins = Math.max(0, thresholds.length - 1);\n  if (numBins === 0) {\n    return [];\n  }\n\n  const x0Name = options.outputNames?.x0 ?? 'x0';\n  const x1Name = options.outputNames?.x1 ?? 'x1';\n  const countName = options.outputNames?.count ?? 'count';\n  const valuesName = options.outputNames?.values ?? 'values';\n  const percentageName = options.outputNames?.percentage ?? 'percentage';\n\n  const facetField = isArray(options?.facetField)\n    ? options?.facetField\n    : options?.facetField\n    ? [options.facetField]\n    : [];\n\n  const groupField = isArray(options?.groupField)\n    ? options?.groupField\n    : options?.groupField\n    ? [options.groupField]\n    : [];\n  const normalizedGroupField = groupField.length ? groupField : undefined;\n  const subViewOptions = {\n    ...options,\n    numBins,\n    thresholds,\n    countName,\n    percentageName,\n    valuesName,\n    countField,\n    field,\n    n,\n    x0Name,\n    x1Name,\n    groupField: normalizedGroupField\n  };\n  if (!facetField.length) {\n    return subBin(data, subViewOptions);\n  }\n  const subViewMap: Record<string, Array<object>> = {};\n  data.forEach((dataItem: any) => {\n    const subViewKey = facetField.map(field => dataItem?.[field]).join('-&&-');\n    if (!subViewMap[subViewKey]) {\n      subViewMap[subViewKey] = [dataItem];\n    } else {\n      subViewMap[subViewKey].push(dataItem);\n    }\n  });\n  return Object.values(subViewMap)\n    .map(subDataset => {\n      const combinedGroupField = [...groupField, ...facetField];\n      return subBin(subDataset, {\n        ...subViewOptions,\n        groupField: combinedGroupField.length ? combinedGroupField : undefined,\n        n: subDataset.length\n      });\n    })\n    .flat();\n};\n\nexport default bin;\n"]}