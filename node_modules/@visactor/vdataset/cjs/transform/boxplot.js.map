{"version":3,"sources":["../src/transform/boxplot.ts"],"names":[],"mappings":"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","file":"boxplot.js","sourcesContent":["import { clamp, isArray, isNil, quantileSorted } from '@visactor/vutils';\nimport type { Transform } from '.';\n\nexport interface IBoxplotOptions {\n  /** categorical/grouping field; if omitted, the whole dataset is treated as one group */\n  // single field name or array of field names to group by; if omitted, the whole dataset is treated as one group\n  groupField?: string | string[];\n  /** numeric field to compute boxplot stats on */\n  field: string;\n  /** whether to include the original values array in the output */\n  includeValues?: boolean;\n  /**\n   * Paramater that controls whisker length.\n   * If scalar, whiskers are drawn to the farthest datapoint within whis * IQR from the nearest hinge.\n   * If a tuple, it is interpreted as percentiles that whiskers represent.\n   */\n  whiskers?: number | number[];\n  /** output field name mapping */\n  outputNames?: {\n    key?: string;\n    count?: string;\n    mean?: string;\n    q1?: string;\n    median?: string;\n    q3?: string;\n    iqr?: string;\n    min?: string;\n    max?: string;\n    lowerWhisker?: string;\n    upperWhisker?: string;\n    outliers?: string;\n    values?: string;\n  };\n}\n\n/**\n * Boxplot transform: group by a discrete field and compute statistics for numeric values.\n * Returns an array of objects, one per group, with fields: key, count, mean, q1, median, q3,\n * iqr, min (data min), max (data max), lowerWhisker, upperWhisker, outliers?, values?\n */\nexport const boxplot: Transform = (data: Array<object>, options?: IBoxplotOptions) => {\n  const field = options?.field;\n  if (!field) {\n    return [];\n  }\n\n  const groupField = options?.groupField;\n  let whiskers = options?.whiskers ?? 1.5;\n  const includeValues = !!options?.includeValues;\n\n  const names = options?.outputNames ?? {};\n  // default key name behavior:\n  // - if outputNames.key is provided, always use it\n  // - else if groupField is a single string, use that field name as the key\n  // - else if groupField is an array (multiple fields), we will NOT create a single key field by default;\n  //   instead we will copy each group field to the output top-level (so keyName=null indicates this behavior)\n  // - else (no grouping), default to 'key'\n  const keyName: string | null = names.key ?? (isArray(groupField) ? null : (groupField as any) ?? 'key');\n  const countName = names.count ?? 'count';\n  const meanName = names.mean ?? 'mean';\n  const q1Name = names.q1 ?? 'q1';\n  const medianName = names.median ?? 'median';\n  const q3Name = names.q3 ?? 'q3';\n  const iqrName = names.iqr ?? 'iqr';\n  const minName = names.min ?? 'min';\n  const maxName = names.max ?? 'max';\n  const lowerWhiskerName = names.lowerWhisker ?? 'lowerWhisker';\n  const upperWhiskerName = names.upperWhisker ?? 'upperWhisker';\n  const outliersName = names.outliers ?? 'outliers';\n  const valuesName = names.values ?? 'values';\n\n  // group values\n  const groups = new Map<string, number[]>();\n  const rawValues = new Map<string, any[]>();\n  // map from composite key string -> representative group value (scalar for single field, object for multiple fields)\n  const keyToGroup = new Map<string, any>();\n\n  const n = data.length;\n  for (let i = 0; i < n; i++) {\n    const d: any = data[i] as any;\n    const v: any = d[field];\n    if (isNil(v)) {\n      continue;\n    }\n    const num = +v;\n    if (!Number.isFinite(num)) {\n      continue;\n    }\n\n    let key: string;\n    if (isArray(groupField)) {\n      // build a stable composite key from multiple fields\n      key = (groupField as string[]).map((f: string) => String((d as any)[f])).join('||');\n    } else {\n      key = groupField ? String((d as any)[groupField as string]) : '___all';\n    }\n    if (!groups.has(key)) {\n      groups.set(key, []);\n      if (includeValues) {\n        rawValues.set(key, []);\n      }\n      // store representative group value(s) for output\n      if (isArray(groupField)) {\n        keyToGroup.set(key, Object.fromEntries((groupField as string[]).map(f => [f, (d as any)[f]])));\n      } else {\n        keyToGroup.set(key, groupField ? (d as any)[groupField as string] : null);\n      }\n    }\n    const arr = groups.get(key);\n    if (arr) {\n      arr.push(num);\n    }\n    if (includeValues) {\n      const rv = rawValues.get(key);\n      if (rv) {\n        rv.push(d);\n      }\n    }\n  }\n\n  if (isArray(whiskers)) {\n    const min = clamp(Math.min.apply(null, whiskers), 0, 1);\n    const max = clamp(Math.max.apply(null, whiskers), 0, 1);\n\n    whiskers = [min, max];\n  }\n\n  const out: any[] = [];\n  for (const [key, vals] of groups) {\n    if (!vals || vals.length === 0) {\n      continue;\n    }\n    const sorted = vals.slice().sort((a, b) => a - b);\n    const count = sorted.length;\n    const dataMin = sorted[0];\n    const dataMax = sorted[sorted.length - 1];\n    let sum = 0;\n    for (let i = 0; i < sorted.length; i++) {\n      sum += sorted[i];\n    }\n    const mean = sum / count;\n    const q1 = quantileSorted(sorted, 0.25);\n    const median = quantileSorted(sorted, 0.5);\n    const q3 = quantileSorted(sorted, 0.75);\n    const iqr = q3 - q1;\n    const lowerBound = isArray(whiskers) ? quantileSorted(sorted, whiskers[0]) : q1 - whiskers * iqr;\n    const upperBound = isArray(whiskers) ? quantileSorted(sorted, whiskers[1]) : q3 + whiskers * iqr;\n\n    const outliers: number[] = [];\n    for (let i = 0; i < sorted.length; i++) {\n      if (sorted[i] < lowerBound || sorted[i] > upperBound) {\n        outliers.push(sorted[i]);\n      }\n    }\n\n    const obj: any = {};\n    // attach the group key(s):\n    // - if keyName is a string, set that property to the representative group value (scalar or object depending on settings)\n    // - if keyName is null (means multi-field grouping and no explicit outputNames.key provided), copy each group field to top-level\n    const representative = keyToGroup.get(key);\n    if (keyName !== null) {\n      obj[keyName] = representative;\n    } else if (isArray(groupField)) {\n      // copy each group field into the output object as top-level properties\n      const groupObj = representative || {};\n      for (const f of groupField as string[]) {\n        obj[f] = groupObj[f];\n      }\n    }\n    obj[countName] = count;\n    obj[meanName] = mean;\n    obj[q1Name] = q1;\n    obj[medianName] = median;\n    obj[q3Name] = q3;\n    obj[iqrName] = iqr;\n    obj[minName] = dataMin;\n    obj[maxName] = dataMax;\n    obj[lowerWhiskerName] = lowerBound;\n    obj[upperWhiskerName] = upperBound;\n    obj[outliersName] = outliers;\n    if (includeValues) {\n      obj[valuesName] = rawValues.get(key) || [];\n    }\n\n    out.push(obj);\n  }\n\n  return out;\n};\n\nexport default boxplot;\n"]}